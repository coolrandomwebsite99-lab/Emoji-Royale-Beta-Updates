<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Royale</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Google Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script>
        window.isLocalFile = window.location.protocol === 'file:';
        if (!window.isLocalFile) {
            document.documentElement.setAttribute('data-no-debug', 'true');
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            background-color: #2a623d; /* Arena green */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
            display: block;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            /* cursor: pointer; */ /* REMOVED - We use custom cursor logic */
            transition: background-color 0.5s ease; /* For arena theme change */
        }
        /* Arena Themes */
        canvas.arena-2 { background-color: #6abf82; }
        canvas.arena-3 { 
            background-color: #4a4a4a;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
        }
        /* NEW ARENA 4 STYLE */
        canvas.arena-4 { 
            background-color: #ca8a04; /* yellow-600 */
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
        }
        /* NEW ARENA 5 STYLE */
        canvas.arena-5 { 
            background-color: #3730a3; /* indigo-800 */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
        }
        /* NEW ARENA 6 STYLE */
        canvas.arena-6 { 
            background-color: #7c2d12; /* brown-900 */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
        }

        /* NEW ARENA 7 STYLE */
        canvas.arena-7 {
            background-color: #3b0764; /* deep purple */
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.04) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.04) 1px, transparent 1px);
        }
        /* NEW ARENA 8 STYLE */
        canvas.arena-8 {
            background-color: #1f1f3d; /* dark navy/chaos */
            background-image:
                linear-gradient(rgba(147, 51, 234, 0.08) 1px, transparent 1px),
                linear-gradient(90deg, rgba(147, 51, 234, 0.08) 1px, transparent 1px);
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        #messageOverlay, #chestOpenOverlay, #debugPasswordOverlay, #saveDataOverlay, #loadDataOverlay, #updateLogOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: none;
            /* Update Log Modal Card Frame */
            #updateLogOverlay > div {
                background: #374151;
                border-radius: 16px;
                border: 4px solid #fde047;
                box-shadow: 0 4px 24px 0 rgba(0,0,0,0.4);
                padding: 2rem 1.5rem;
                max-width: 400px;
                width: 100%;
                margin: 0 auto;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            color: white;
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            border-radius: 8px;
            z-index: 50;
            padding: 1rem;
        }
        #messageOverlay button, #chestOpenOverlay button, .login-btn, .debug-btn, #debugPasswordOverlay button,
        #saveDataOverlay button, #loadDataOverlay button, #updateLogOverlay button, .arena-btn { /* Added arena-btn */
            font-size: 1rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            margin-top: 20px;
            background-color: #4f46e5;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 80%;
            max-width: 300px;
        }
        #messageOverlay button:hover, #chestOpenOverlay button:hover, .login-btn:hover, .debug-btn:hover, #debugPasswordOverlay button:hover,
        #saveDataOverlay button:hover, #loadDataOverlay button:hover, #updateLogOverlay button:hover, .arena-btn:hover { /* Added arena-btn */
            background-color: #4338ca;
        }
        .login-btn.google {
            background-color: #dc2626; /* red-600 */
        }
        .login-btn.google:hover {
            background-color: #b91c1c; /* red-700 */
        }
        .login-btn.guest {
            background-color: #6b7280; /* gray-500 */
        }
        .login-btn.guest:hover {
            background-color: #4b5563; /* gray-600 */
        }
        /* Debug Password Input */
        #debugPasswordInput, #loadKeyInput {
            font-size: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            border: 2px solid #6b7280;
            background-color: #1f2937;
            color: white;
            margin-top: 20px;
            width: 80%;
            max-width: 300px;
            text-align: center;
        }
        #debugPasswordOverlay .cancel-btn, #saveDataOverlay .cancel-btn, #loadDataOverlay .cancel-btn {
            background-color: #dc2626; /* red-600 */
        }
        #debugPasswordOverlay .cancel-btn:hover, #saveDataOverlay .cancel-btn:hover, #loadDataOverlay .cancel-btn:hover {
            background-color: #b91c1c; /* red-700 */
        }
        /* Save Key Text Area */
        #saveKeyOutput {
            font-size: 0.9rem;
            padding: 0.75rem;
            border-radius: 8px;
            border: 2px solid #6b7280;
            background-color: #1f2937;
            color: #d1d5db; /* gray-300 */
            margin-top: 20px;
            width: 90%;
            max-width: 350px;
            height: 120px;
            word-wrap: break-word;
            word-break: break-all;
            -webkit-user-select: text; /* Safari */
            -ms-user-select: text; /* IE 10+ */
            user-select: text; /* Standard */
            text-align: left;
            overflow-y: auto;
        }
        #saveDataOverlay button:disabled {
            background-color: #4b5563;
            cursor: not-allowed;
            opacity: 0.7;
        }

        html[data-no-debug] [data-screen="debug"],
        html[data-no-debug] #debugScreen {
            display: none !important;
            visibility: hidden !important;
            pointer-events: none !important;
        }

        /* Hide screens by default */
        .screen {
            display: none;
            width: 100%;
            height: 100vh;
            overflow-y: auto;
        }
        /* Show the active screen */
        .screen.active {
            display: flex;
        }
        /* Loading Screen Animation */
        @keyframes pulse-king {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .animate-pulse-king {
            animation: pulse-king 2s infinite;
        }
        /* Bottom Nav */
        #bottomNav {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            max-width: 400px;
            margin: 0 auto;
            z-index: 20;
        }
        /* Card Style */
        .card-ui {
            width: 80px;
            height: 112px;
            background-color: #4b5563; /* gray-600 */
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            padding: 4px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: white;
            cursor: pointer;
            user-select: none;
            border: 4px solid #374151; /* gray-700 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            overflow: hidden;
        }
        .card-ui.selected {
            border-color: #ec4899; /* pink-500 */
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 0 20px #ec4899;
        }
        .card-ui.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(80%);
        }
        .card-ui-small {
            width: 60px;
            height: 84px;
            border-radius: 6px;
        }
        .card-ui-name {
            font-size: 0.7rem;
            background-color: rgba(0,0,0,0.6);
            padding: 0 4px;
            border-radius: 4px;
            z-index: 2;
        }
        .card-ui-emoji {
            font-size: 2.5rem;
            line-height: 1;
            z-index: 2;
        }
         .card-ui-small .card-ui-emoji {
            font-size: 2rem;
        }
        .card-ui-type {
            font-size: 0.6rem;
            color: #d1d5db; /* gray-300 */
            z-index: 2;
        }
        .card-ui-cost {
            position: absolute;
            top: 2px;
            left: 2px;
            background-color: #7e22ce;
            border: 2px solid #a855f7;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            z-index: 3;
        }
        .card-ui-level {
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 0.7rem;
            font-weight: 800;
            background-color: rgba(0,0,0,0.7);
            color: #fde047; /* yellow-300 */
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 3;
        }
        .card-ui-progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background-color: #1f2937; /* gray-800 */
            z-index: 1;
        }
        .card-ui-progress {
            height: 100%;
            background-color: #3b82f6; /* blue-500 */
            transition: width 0.3s;
        }
        .card-ui .can-upgrade {
            background-color: #fde047; /* yellow-300 */
        }
        /* NEW: Locked Card Styles */
        .card-ui-locked {
            filter: grayscale(100%);
            opacity: 0.6;
        }
        .card-ui-locked-arena {
            position: absolute;
            bottom: 4px;
            left: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            background-color: rgba(0,0,0,0.8);
            color: #fde047;
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 3;
        }


        /* Card Info Modal */
        #cardInfoModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #cardInfoModalContent {
            background-color: #374151; /* gray-700 */
            border-radius: 12px;
            padding: 1.5rem;
            width: 90%;
            max-width: 350px;
            border: 4px solid #4b5563; /* gray-600 */
            position: relative;
        }
        #cardInfoCloseBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 2rem;
            line-height: 1;
            cursor: pointer;
            color: #9ca3af; /* gray-400 */
        }
        #cardInfoStats, #towerInfoStats {
            font-size: 0.9rem;
            color: #d1d5db; /* gray-300 */
        }
        #cardInfoStats span, #towerInfoStats span {
            color: white;
            font-weight: 600;
        }
        .modal-btn {
            width: 100%;
            font-size: 1.1rem;
            font-weight: 600;
            padding: 0.75rem;
            margin-top: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .modal-btn.add { background-color: #16a34a; color: white; }
        .modal-btn.remove { background-color: #dc2626; color: white; }
        .modal-btn.upgrade { background-color: #16a34a; color: white; }
        .modal-btn:disabled {
            background-color: #6b7280; /* gray-500 */
            color: #d1d5db; /* gray-300 */
            cursor: not-allowed;
        }
        #cardInfoProgressContainer, #towerInfoProgressContainer {
            width: 100%;
            background-color: #1f2937;
            border-radius: 5px;
            height: 20px;
            margin-top: 8px;
            position: relative;
            overflow: hidden;
        }
        #cardInfoProgressBar, #towerInfoProgressBar {
            height: 100%;
            background-color: #3b82f6;
        }
        #cardInfoProgressText, #towerInfoProgressText {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            font-weight: 600;
            color: white;
        }
        /* Troop Ghost & Spell Radius */
        #placementIndicator {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            display: none;
            z-index: 20;
            font-size: 2rem;
            opacity: 0.7;
            text-align: center;
            line-height: 1;
            transform: translate(-50%, -50%); /* Keep this for centering */
        }
        #placementIndicator.spell {
            border: 4px dashed white;
            background: rgba(255, 255, 255, 0.2);
        }
        #placementIndicator.cant-place {
            background: rgba(220, 38, 38, 0.4);
            border-color: #dc2626;
        }
        /* Chest Reward Styles */
        #chestRewardList {
            font-size: 1.2rem;
            margin-top: 1rem;
        }
        #chestRewardList div {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        /* Red 'Can't Place' Overlay */
        #placementOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                rgba(220, 38, 38, 0.2),
                rgba(220, 38, 38, 0.2) 10px,
                rgba(220, 38, 38, 0.3) 10px,
                rgba(220, 38, 38, 0.3) 20px
            );
            z-index: 10;
            pointer-events: none;
            display: none;
            /* clip-path: polygon(0% 0%, 100% 0%, 100% 50%, 0% 50%); */
            /* NEW: Switched to path() for multi-area clipping */
            clip-path: path("M0 0 L400 0 L400 250 L0 250 Z");
        }
        
        /* NEW: Unauthorized Screen Overlay */
        #unauthorizedScreen {
            display: none; /* Hidden by default */
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7); /* Greys out the background */
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 1rem;
        }
        #imagineText {
            font-size: 2.5rem;
            font-weight: 800;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        #errorReasonText {
            font-size: 1rem;
            color: #fca5a5; /* red-300 */
            margin-top: 1rem;
        }
        
        /* NEW: Fade overlay for demo loop */
        #demoFadeOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
            z-index: 101; /* Above the "imagine" text */
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center p-2">
    
    <!-- 
    ========================================================
    SCREEN: INTRO (NEW)
    ========================================================
    -->
    <div id="introScreen" class="screen active flex-col justify-center items-center bg-gray-900">
        <div class="text-8xl animate-pulse-king">üëë</div>
    </div>

    <!-- 
    ========================================================
    SCREEN: LOGIN (FIXED)
    ========================================================
    -->
    <div id="loginScreen" class="screen flex-col justify-center items-center">
        <div class="text-6xl">üëë</div>
        <h1 class="text-4xl font-bold mt-4">Emoji Royale</h1>
        <p class="text-lg mt-2 text-gray-300">Choose your way to play!</p>
        <p id="loginError" class="text-lg mt-2 text-red-500 font-bold h-6"></p> 
        
        <!-- NEW: Load Save Key Button -->
        <button id="loadKeyBtn" class="login-btn bg-blue-600 hover:bg-blue-700">
            Enter Save Key
        </button>
        
        <!-- "Play as Guest (No Save)" button -->
        <button id="trueGuestLoginBtn" class="login-btn guest">
            Play without Save
        </button>
        
        <!-- Google Sign-in (hidden for now, but logic exists) -->
        <button id="googleLoginBtn" class="login-btn google hidden">
            <svg class="w-6 h-6 mr-3" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><path fill="#FFC107" d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z"></path><path fill="#FF3D00" d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z"></path><path fill="#4CAF50" d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.202,0-9.619-3.317-11.283-7.946l-6.522,5.025C9.505,39.556,16.227,44,24,44z"></path><path fill="#1976D2" d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.574l6.19,5.238C42.018,36.341,44,30.606,44,24C44,22.659,43.862,21.35,43.611,20.083z"></path></svg>
            Sign in with Google
        </button>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: LOADING
    ========================================================
    -->
    <div id="loadingScreen" class="screen flex-col justify-center items-center bg-gray-900">
        <div class="text-8xl animate-pulse-king">üëë</div>
        <h1 class="text-3xl font-bold mt-4">Emoji Royale</h1>
        <p class="text-lg mt-2 text-gray-300">Loading...</p>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: MENU (HOME)
    ========================================================
    -->
    <div id="menuScreen" class="screen flex-col items-center p-4">
        <!-- Main Content Area -->
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <!-- Header -->
            <div class="flex justify-between items-center w-full">
                <div class="bg-gray-800 px-4 py-2 rounded-lg">
                    <span id="goldDisplay" class="text-xl font-bold text-yellow-400">üí∞ 500</span>
                </div>
                <div class="bg-gray-800 px-4 py-2 rounded-lg">
                    <span id="trophyDisplay" class="text-xl font-bold text-blue-400">üèÜ 0</span>
                </div>
            </div>
            
            <!-- Arena Display -->
            <div class="flex flex-col items-center my-8">
                <span id="arenaEmoji" class="text-8xl">üèûÔ∏è</span>
                <h2 id="arenaName" class="text-2xl font-bold mt-2">Arena 1: Emoji Valley</h2>
            </div>

            <!-- Mode Selector -->
            <div class="flex w-3/4 mb-4 bg-gray-700 rounded-lg p-1">
                <button id="modeNormal" class="mode-tab flex-1 py-2 rounded-md text-lg font-bold transition bg-red-600 text-white">Normal</button>
                <button id="mode2v2" class="mode-tab flex-1 py-2 rounded-md text-lg font-bold transition text-gray-400">2v2</button>
            </div>

            <!-- Battle Button -->
            <button id="battleButton" class="bg-red-600 hover:bg-red-700 text-white w-3/4 py-4 rounded-lg shadow-lg text-3xl font-extrabold transition transform hover:scale-105">
                BATTLE!
            </button>
            
            <!-- NEW: Arena Button -->
            <button id="arenaButton" class="arena-btn bg-blue-600 hover:bg-blue-700 mt-4 w-3/4 py-3 text-xl font-bold">
                Arenas
            </button>
            
            <!-- Chest Slots -->
            <div class="mt-8 w-full">
                <h3 class="text-xl font-bold text-center mb-2">Your Chests</h3>
                <div id="chestSlots" class="grid grid-cols-4 gap-2">
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                </div>
            </div>

            <!-- NEW: Save Data Button -->
            <button id="saveDataBtn" class="login-btn guest mt-8 w-3/4">
                Save Data
            </button>

        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-yellow-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <!-- NEW: Debug Button -->
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: DECK
    ========================================================
    -->
    <div id="deckScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 id="deckCount" class="text-2xl font-bold">Deck (0 / 8)</h1>
            <div id="deckCardGrid" class="grid grid-cols-4 gap-2 my-4">
                <!-- Deck cards injected by JS -->
            </div>
            
            <hr class="border-gray-600 w-full my-4">
            
            <h2 class="text-2xl font-bold">Your Collection</h2>
            <div id="collectionCardGrid" class="grid grid-cols-4 gap-2 my-4">
                <!-- Collection cards injected by JS -->
            </div>

            <!-- NEW: Locked Cards Section -->
            <hr class="border-gray-600 w-full my-4">
            <h2 class="text-2xl font-bold">Not Unlocked</h2>
            <div id="lockedCardGrid" class="grid grid-cols-4 gap-2 my-4">
                <!-- Locked cards injected by JS -->
            </div>

        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-yellow-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    SCREEN: TOWER
    ========================================================
    -->
    <div id="towerScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold">Tower Power</h1>
            <p id="towerLevelDisplay" class="text-lg text-yellow-300 font-bold">Tower Level 1</p>
            <div class="text-8xl my-4">üëë</div>
            
            <!-- Stats -->
            <div class="bg-gray-800 p-4 rounded-lg mt-4 w-full space-y-2">
                <h3 class="text-xl font-bold text-center">Tower Stats</h3>
                <div id="towerInfoStats" class="grid grid-cols-2 gap-2">
                    <!-- Stats injected by JS -->
                </div>
            </div>
            
            <!-- Upgrade -->
            <div class="bg-gray-800 p-4 rounded-lg mt-8 w-full">
                <h3 class="text-xl font-bold text-center">Upgrade Tower</h3>
                <div id="towerInfoProgressContainer">
                    <div id="towerInfoProgressBar" style="width: 0%;"></div>
                    <div id="towerInfoProgressText">0 / 0</div>
                </div>
                <button id="towerUpgradeButton" class="modal-btn upgrade" disabled>
                    Upgrade
                </button>
            </div>
        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn active flex flex-col items-center text-yellow-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    SCREEN: ARENAS (NEW)
    ========================================================
    -->
    <div id="arenaScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold mb-8">Arenas</h1>
            
            <div class="space-y-4 w-full">
                <!-- Arena 1 -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üèûÔ∏è</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 1: Emoji Valley</h2>
                        <p class="text-yellow-400">0+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 2 -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üèòÔ∏è</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 2: Laughing Village</h2>
                        <p class="text-yellow-400">250+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 3 -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üåã</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 3: Lava Town</h2>
                        <p class="text-yellow-400">500+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 4 -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üöú</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 4: The Farm</h2>
                        <p class="text-yellow-400">750+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 5 (NEW) -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üíÄ</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 5: Skull Kingdom</h2>
                        <p class="text-yellow-400">1000+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 6 (NEW) -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üîÆ</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 6: Warlock's Workshop</h2>
                        <p class="text-yellow-400">1250+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 7 (NEW) -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">ü™¶</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 7: Mages Graveyard</h2>
                        <p class="text-yellow-400">1500+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 8 (NEW) -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">‚ö°</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 8: Chaos Canyon</h2>
                        <p class="text-yellow-400">1750+ Trophies üèÜ</p>
                    </div>
                </div>
            </div>
            
            <button id="arenaBackButton" class="arena-btn bg-gray-600 hover:bg-gray-700 mt-8 w-3/4">
                Back to Menu
            </button>
        </div>
        
        <!-- Bottom Nav (Hidden, but keeps layout consistent) -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2 invisible">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center"><span class="text-4xl">‚öîÔ∏è</span><span class="text-xs">Battle</span></button>
                <button class="nav-btn flex flex-col items-center"><span class="text-4xl">üÉè</span><span class="text-xs">Deck</span></button>
                <button class="nav-btn flex flex-col items-center"><span class="text-4xl">üëë</span><span class="text-xs">Tower</span></button>
                <button class="nav-btn flex flex-col items-center"><span class="text-4xl">üß™</span><span class="text-xs">Debug</span></button>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    SCREEN: DEBUG (NEW)
    ========================================================
    -->
    <div id="debugScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold">Debug Menu</h1>
            <p class="text-gray-400 text-center my-4">For testing only!</p>
            
            <button id="debugArena2" class="debug-btn bg-green-600 hover:bg-green-700">Jump to Arena 2 (250 üèÜ)</button>
            <button id="debugArena3" class="debug-btn bg-red-600 hover:bg-red-700">Jump to Arena 3 (500 üèÜ)</button>
            <button id="debugArena4" class="debug-btn bg-yellow-600 hover:bg-yellow-700">Jump to Arena 4 (750 üèÜ)</button>
            <button id="debugArena5" class="debug-btn bg-indigo-600 hover:bg-indigo-700">Jump to Arena 5 (1000 üèÜ)</button> <!-- NEW -->
                    <button id="debugArena6" class="debug-btn bg-orange-900 hover:bg-orange-800">Jump to Arena 6 (1250 üèÜ)</button>
                    <button id="debugArena7" class="debug-btn bg-gray-900 hover:bg-gray-800">Jump to Arena 7 (1500 üèÜ)</button>
                    <button id="debugArena8" class="debug-btn bg-purple-900 hover:bg-purple-800">Jump to Arena 8 (1750 üèÜ)</button>
            <button id="debugUnlockAll" class="debug-btn bg-blue-600 hover:bg-blue-700">Unlock All Cards</button>
            <button id="debugUpgradeAll" class="debug-btn bg-purple-600 hover:bg-purple-700">Upgrade All Cards +1 Lvl</button>
            <button id="debugGetChest" class="debug-btn bg-yellow-600 hover:bg-yellow-700">Get a Free Chest üì¶</button>
            <button id="debugAddGold" class="debug-btn bg-yellow-400 text-gray-900 hover:bg-yellow-300">Get 1000 Gold üí∞</button>
            <button id="debugReset" class="debug-btn bg-gray-600 hover:bg-gray-700">Reset Account (New User)</button>

        </div>
        
        <!-- Bottom Nav Bar -->
        <div id="bottomNav" class="bg-gray-800 w-full rounded-t-lg shadow-inner p-2">
            <div class="flex justify-around">
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="menu">
                    <span class="text-4xl">‚öîÔ∏è</span>
                    <span class="text-xs">Battle</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="deck">
                    <span class="text-4xl">üÉè</span>
                    <span class="text-xs">Deck</span>
                </button>
                <button class="nav-btn flex flex-col items-center text-gray-400" data-screen="tower">
                    <span class="text-4xl">üëë</span>
                    <span class="text-xs">Tower</span>
                </button>
                <button class="nav-btn active flex flex-col items-center text-yellow-400" data-screen="debug">
                    <span class="text-4xl">üß™</span>
                    <span class="text-xs">Debug</span>
                </button>
            </div>
        </div>
    </div>


    <!-- 
    ========================================================
    SCREEN: GAME
    ========================================================
    -->
    <div id="gameScreen" class="screen flex-col items-center p-2">
        <div id="gameContainer">
            <div id="timerDisplay" class="absolute top-2 right-2 text-2xl font-bold bg-black bg-opacity-50 px-4 py-1 rounded-lg z-10">2:00</div>
            <!-- AI Teammate UI (2v2) -->
            <div id="aiTeammateUI" class="absolute bottom-[-350px] left-1/2 transform -translate-x-1/2 flex flex-col items-center gap-1 pointer-events-none" style="display:none;">
                <div class="flex justify-center items-end space-x-2">
                    <div class="flex flex-col items-center">
                        <span class="text-xs mb-1">NEXT</span>
                        <div id="aiTeammateNext" class="card-ui-small"></div>
                    </div>
                    <div id="aiTeammateHand" class="flex justify-center space-x-2"></div>
                </div>
                <div class="flex items-center gap-2">
                    <div class="text-white text-xs">Teammate Elixir</div>
                    <div class="w-24 h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div id="aiTeammateElixirBar" class="h-full bg-purple-500 transition-all duration-300" style="width: 0%"></div>
                    </div>
                    <div id="aiTeammateElixirCount" class="text-white text-xs">0/10</div>
                </div>
            </div>
            <!-- NEW: Placement Overlay -->
            <div id="placementOverlay"></div>
            <canvas id="gameCanvas" width="400" height="500"></canvas>
            <div id="messageOverlay">
                <span id="messageText"></span>
                <button id="startButton">Start Game</button>
                <button id="menuButton" class="bg-red-600 hover:bg-red-700">Back to Menu</button>
            </div>
            <!-- Placement "Ghost" Indicator -->
            <div id="placementIndicator"></div>
            
            <!-- NEW: Unauthorized Screen Overlay -->
            <div id="unauthorizedScreen">
                <h1 id="imagineText">Imagine... what could have been.</h1>
                <p id="errorReasonText">Error: This game is not authorized to run on this domain.</p>
                <!-- NEW: Fade overlay for demo loop -->
                <div id="demoFadeOverlay"></div>
            </div>
        </div>

        <!-- Card UI Bar -->
        <div class="bg-gray-800 p-4 shadow-inner w-full max-w-md mt-2 rounded-lg" style="padding-bottom: env(safe-area-inset-bottom, 1rem);">
            <div class="max-w-md mx-auto">
                <!-- Elixir Bar -->
                <div class="mb-4">
                    <div class="w-full bg-gray-700 rounded-full h-6 border-2 border-gray-900 shadow-inner">
                        <div id="elixirBar" class="bg-purple-500 h-full rounded-full transition-all duration-100 ease-linear text-right pr-2 font-bold" style="width: 30%;">
                            <span id="elixirText">3</span>
                        </div>
                    </div>
                </div>
                
                <!-- 4-Card Hand + Next Card -->
                <div class="flex justify-center items-end space-x-2">
                    <div class="flex flex-col items-center">
                        <span class="text-xs mb-1">NEXT</span>
                        <div id="nextCardSlot" class="card-ui-small"></div>
                    </div>
                    <div id="cardHand" class="flex justify-center space-x-2"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    CARD INFO MODAL
    ========================================================
    -->
    <div id="cardInfoModal">
        <div id="cardInfoModalContent">
            <span id="cardInfoCloseBtn">&times;</span>
            <div class="flex items-center space-x-4">
                <div id="cardInfoDisplay" class="flex-shrink-0"></div>
                <div>
                    <h2 id="cardInfoName" class="text-2xl font-bold">Card Name</h2>
                    <p id="cardInfoType" class="text-lg text-gray-400">Card Type</p>
                    <p id="cardInfoLevel" class="text-lg font-bold text-yellow-300">Level 1</p>
                </div>
            </div>
            <hr class="border-gray-500 my-4">
            <div id="cardInfoStats" class="space-y-1"></div>
            <!-- NEW: Add/Remove Button container -->
            <div id="cardInfoButtons">
                <!-- Add/Remove button injected by JS -->
            </div>
            <div id="cardInfoProgressContainer">
                <div id="cardInfoProgressBar" style="width: 0%;"></div>
                <div id="cardInfoProgressText">0 / 0</div>
            </div>
            <button id="cardInfoButton" class="modal-btn"></button>
        </div>
    </div>
    
    <!-- 
    ========================================================
    CHEST OPENING MODAL
    ========================================================
    -->
    <div id="chestOpenOverlay">
        <h2 class="text-4xl font-bold">Chest Unlocked!</h2>
        <div class="text-7xl my-4">üì¶</div>
        <div id="chestRewardList">
            <!-- Rewards injected by JS -->
        </div>
        <button id="chestCloseButton">Awesome!</button>
    </div>

    <!-- 
    ========================================================
    DEBUG PASSWORD MODAL (NEW)
    ========================================================
    -->
    <div id="debugPasswordOverlay">
        <h2 class="text-2xl font-bold">Enter Debug Password</h2>
        <input type="password" id="debugPasswordInput" placeholder="Password">
        <button id="debugPasswordSubmit">Enter</button>
        <button id="debugPasswordCancel" class="cancel-btn">Cancel</button>
    </div>

    <!-- 
    ========================================================
    SAVE DATA MODAL (NEW)
    ========================================================
    -->
    <div id="saveDataOverlay">
        <h2 class="text-2xl font-bold">Your Save Key</h2>
        <p class="text-sm font-normal text-gray-300 mt-2">Copy this key and save it somewhere safe!</p>
        <textarea id="saveKeyOutput" readonly>Generating key...</textarea>
        <button id="generateKeyBtn">Generate New Key</button>
        <button id="saveDataCancel" class="cancel-btn">Close</button>
    </div>

    <!-- 
    ========================================================
    LOAD DATA MODAL (NEW)
    ========================================================
    -->
    <div id="loadDataOverlay">
        <h2 class="text-2xl font-bold">Load Save Key</h2>
        <p class="text-sm font-normal text-gray-300 mt-2">Paste your save key below to load progress.</p>
        <input type="text" id="loadKeyInput" placeholder="Paste your key here">
        <button id="loadKeySubmit">Load Progress</button>
        <button id="loadDataCancel" class="cancel-btn">Cancel</button>
    </div>

    <!-- 
    ========================================================
    UPDATE LOG MODAL (NEW)
    ========================================================
    -->
    <div id="updateLogOverlay">
        <h2 class="text-3xl font-bold mb-4">üìã Update Log</h2>
        <div id="updateLogContent" class="text-left text-sm max-h-96 overflow-y-auto w-full max-w-md px-4 space-y-3">
            <!-- Update log content will be injected by JS -->
        </div>
        <button id="updateLogClose" class="mt-4">Continue</button>
    </div>


    <!-- 
    ========================================================
    MAIN SCRIPT
    ========================================================
    -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyCnaXKjDvPDXP2tF5ZmtB7naYjCuLGUsd4",
          authDomain: "emoji-royale-8fb68.firebaseapp.com",
          projectId: "emoji-royale-8fb68",
          storageBucket: "emoji-royale-8fb68.firebasestorage.app",
          messagingSenderId: "1021589049311",
          appId: "1:1021589049311:web:61ce6353950831e298be6a",
          measurementId: "G-FDQ9L0MQGM"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();
        // setLogLevel('debug'); // Uncomment for debugging Firestore
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Use __app_id
        let userDocRef; // Reference to the user's document in Firestore
        let userId; // The user's unique ID
        
        // --- Global State ---
        let currentScreen = 'intro'; // Start on intro screen
        let trophies = 0;
        let gold = 500;
        let trophyChests = [];
        let allCards = {};
        let cardCollection = {};
        let playerDeck = [];
        let playerDeck2v2 = [];
        let gameDeck = [];
        let hand = [];
        let nextCard = null;
        let discardPile = [];
        let aiDeck = [];
        let aiHand = [];
        let aiNextCard = null;
        let aiDiscardPile = [];
        let towerLevel = 1;
        let towerCardCount = 0;
        // --- NEW: Level Cap at 15 ---
        const towerUpgradeCosts = {
            1: { cards: 2, gold: 50 }, 2: { cards: 4, gold: 150 }, 3: { cards: 10, gold: 400 },
            4: { cards: 20, gold: 1000 }, 5: { cards: 50, gold: 2000 }, 6: { cards: 100, gold: 4000 },
            7: { cards: 200, gold: 8000 }, 8: { cards: 400, gold: 16000 }, 9: { cards: 800, gold: 32000 },
            10: { cards: 1000, gold: 50000 }, 11: { cards: 1500, gold: 75000 }, 12: { cards: 2000, gold: 100000 },
            13: { cards: 3000, gold: 150000 }, 14: { cards: 5000, gold: 200000 },
        };
        const towerStats = {
            1: { kingHealth: 2000, princessHealth: 1000, damage: 50, hitSpeed: 1 },
            2: { kingHealth: 2200, princessHealth: 1100, damage: 55, hitSpeed: 1 },
            3: { kingHealth: 2420, princessHealth: 1210, damage: 60, hitSpeed: 1 },
            4: { kingHealth: 2662, princessHealth: 1331, damage: 66, hitSpeed: 1 },
            5: { kingHealth: 2928, princessHealth: 1464, damage: 72, hitSpeed: 1 },
            6: { kingHealth: 3220, princessHealth: 1610, damage: 79, hitSpeed: 1 },
            7: { kingHealth: 3542, princessHealth: 1771, damage: 87, hitSpeed: 1 },
            8: { kingHealth: 3896, princessHealth: 1948, damage: 96, hitSpeed: 1 },
            9: { kingHealth: 4285, princessHealth: 2142, damage: 105, hitSpeed: 1 },
            10: { kingHealth: 4713, princessHealth: 2356, damage: 116, hitSpeed: 1 },
            11: { kingHealth: 5184, princessHealth: 2591, damage: 128, hitSpeed: 1 },
            12: { kingHealth: 5702, princessHealth: 2850, damage: 141, hitSpeed: 1 },
            13: { kingHealth: 6272, princessHealth: 3135, damage: 155, hitSpeed: 1 },
            14: { kingHealth: 6899, princessHealth: 3448, damage: 170, hitSpeed: 1 },
            15: { kingHealth: 7589, princessHealth: 3793, damage: 187, hitSpeed: 1 },
        };

        let selectedSpawningUnit = null;
        let isSpawningSpell = false;
        let spellRadius = 0;
        let placementRadius = 0;
        let canPlace = false;
        const arenaFloors = { 0: "Arena 1: Emoji Valley", 250: "Arena 2: Laughing Village", 500: "Arena 3: Lava Town", 750: "Arena 4: The Farm", 1000: "Arena 5: Skull Kingdom", 1250: "Arena 6: Warlock's Workshop", 1500: "Arena 7: Mages Graveyard", 1750: "Arena 8: Chaos Canyon" };
        let currentArenaFloor = 0;
        let currentArenaTheme = 'arena-1'; // For canvas styling

        // --- NEW: Level Cap at 15 ---
        const upgradeCosts = {
            1: { cards: 2, gold: 50 }, 2: { cards: 4, gold: 150 }, 3: { cards: 10, gold: 400 },
            4: { cards: 20, gold: 1000 }, 5: { cards: 50, gold: 2000 }, 6: { cards: 100, gold: 4000 },
            7: { cards: 200, gold: 8000 }, 8: { cards: 400, gold: 16000 }, 9: { cards: 800, gold: 32000 },
            10: { cards: 1000, gold: 50000 }, 11: { cards: 1500, gold: 75000 }, 12: { cards: 2000, gold: 100000 },
            13: { cards: 3000, gold: 150000 }, 14: { cards: 5000, gold: 200000 },
        };
        let isDataSaved = true; // Flag to control saving
        let isInitialAuthCheck = true; // Flag to stop auto-login
        let loadTimeout; // Timer for stuck loads
        let isLoading = false; // Flag to prevent double-loads
        let hasShownUpdateLog = false; // Flag to track if update log has been shown this session
        let generateKeyTimeout; // NEW: Timer for save key generation
        
        // --- NEW: Demo Mode ---
        let isDemoMode = false;
        let demoLoopTimer = 15 * 60; // 15 seconds
        const DEMO_LOOP_TIME = 15 * 60;
        let demoFadingOut = false; // NEW
        let demoFadeTimer = 0; // NEW
        const DEMO_FADE_TIME = 30; // 0.5 seconds

        // --- NEW: 2v2 Mode State ---
        let gameMode = 'normal'; // 'normal' or '2v2'
        let is2v2Friend = false;
        let is2v2AITeammate = false;
        let twoVtwoLobbyCode = null;
        let twoVtwoLobbyLocked = false;
        let twoVtwoInFriendMatch = false;
        let twoVtwoPlayAgainRequested = false;

        // --- Start Game ---
        window.onload = () => {

            // --- Domain Lock Security ---
            const isLocalFile = window.location.protocol === 'file:';
            const allowedHosts = [
                'coolrandomwebsite99-lab.github.io',
                'scf.usercontent.goog'
            ];
            const currentHost = window.location.hostname;
            const isLocalhost = currentHost === "localhost" || currentHost === "";
            
            const isAllowed = allowedHosts.some(host => currentHost.endsWith(host)) || isLocalhost;

            if (!isAllowed) {
                console.error("Game running on unauthorized domain:", currentHost);
                
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('introScreen').style.display = 'none';
                const gameScreen = document.getElementById('gameScreen');
                if (gameScreen) gameScreen.style.display = 'flex';
                
                const unauthScreen = document.getElementById('unauthorizedScreen');
                if (unauthScreen) {
                    unauthScreen.style.display = 'flex';
                    unauthScreen.querySelector('#errorReasonText').textContent = 'Error: This game is not authorized to run on this domain.';
                    unauthScreen.querySelector('#imagineText').textContent = 'Imagine... what could have been.';
                }

                document.getElementById('cardHand').style.display = 'none';
                document.getElementById('nextCardSlot').parentElement.style.display = 'none';
                document.getElementById('elixirBar').parentElement.parentElement.style.display = 'none';
                document.getElementById('timerDisplay').style.display = 'none';
                document.getElementById('menuButton').style.display = 'none';

                isDemoMode = true;
                lastTime = performance.now();
            }

            if (!isLocalFile) {
                const debugButtons = document.querySelectorAll('[data-screen="debug"]');
                debugButtons.forEach(btn => btn.style.display = 'none');
                const debugScreen = document.getElementById('debugScreen');
                if (debugScreen) debugScreen.style.display = 'none';
            }
            // --- END: Domain Lock Security ---


            // --- Game Constants ---
            const WIDTH = 400; // Define constants first
            const HEIGHT = 500;
            const RIVER_Y = HEIGHT / 2;
            const BRIDGE_Y = RIVER_Y;
            const PLAYER_SPAWN_LIMIT_Y = RIVER_Y;
            const AI_SPAWN_LIMIT_Y = RIVER_Y;
            const AI_SPAWN_ZONE_LIMIT = HEIGHT * 0.3; // NEW: 30% from top
            const LANE_LEFT_X = WIDTH / 4;
            const LANE_RIGHT_X = (WIDTH / 4) * 3;
            const MAX_ELIXIR = 10;
            const BASE_ELIXIR_REGEN_RATE = 0.008;
            const REGULATION_TIME = 120 * 60;
            const OVERTIME_TIME = 120 * 60;
            
            // NEW: Drag sensitivity
            const DRAG_SENSITIVITY = 10; // Pixels
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;

            // --- Enemy AI (2v2: two AIs) ---
            let aiThinkTimer = 0;
            let ai2ThinkTimer = 0;
            let aiElixir = 0;
            let ai2Elixir = 0;
            let aiHand = [];
            let ai2Hand = [];
            let aiDeck = [];
            let ai2Deck = [];
            let aiDiscardPile = [];
            let ai2DiscardPile = [];
            let aiNextCard = null;
            let ai2NextCard = null; // Add NEXT card for second AI
            let aiTowerLevel = 1;
            let ai2TowerLevel = 1;
            let currentAiStatLevel = 1;
            let currentAi2StatLevel = 1;
            let gameTimer = REGULATION_TIME;
            let isOvertime = false;
            let currentElixirRate = BASE_ELIXIR_REGEN_RATE;
            let isTieBreaker = false;
            let tieBreakerTick = 0;
            let overtimeInitialPlayerTowers = 0; // NEW: For sudden death
            let overtimeInitialAiTowers = 0; // NEW: For sudden death
            // NEW: Track destroyed towers for spawn zones
            let playerLeftTowerDestroyed = false;
            let playerRightTowerDestroyed = false;
            let aiLeftTowerDestroyed = false;
            let aiRightTowerDestroyed = false;

            // --- Game State ---
            let gameObjects = [];
            let playerElixir = 3;
            let gameRunning = false;
            let gameLoopId = 0;
            let lastTime = 0;

            // --- DOM Elements ---
            const screens = document.querySelectorAll('.screen');
            const navButtons = document.querySelectorAll('.nav-btn');
            const loginScreen = document.getElementById('loginScreen');
            const googleLoginBtn = document.getElementById('googleLoginBtn');
            const trueGuestLoginBtn = document.getElementById('trueGuestLoginBtn'); // FIXED
            const loginError = document.getElementById('loginError'); 
            const loadingScreen = document.getElementById('loadingScreen');
            const menuScreen = document.getElementById('menuScreen');
            const gameScreen = document.getElementById('gameScreen');
            const deckScreen = document.getElementById('deckScreen');
            const towerScreen = document.getElementById('towerScreen');
            const arenaScreen = document.getElementById('arenaScreen'); // NEW
            const debugScreen = document.getElementById('debugScreen'); // NEW
            const battleButton = document.getElementById('battleButton');
            const modeNormal = document.getElementById('modeNormal');
            const mode2v2 = document.getElementById('mode2v2');
            const arenaButton = document.getElementById('arenaButton'); // NEW
            const arenaBackButton = document.getElementById('arenaBackButton'); // NEW
            const trophyDisplay = document.getElementById('trophyDisplay');
            const goldDisplay = document.getElementById('goldDisplay');
            const chestSlots = document.getElementById('chestSlots');
            const arenaName = document.getElementById('arenaName');
            const arenaEmoji = document.getElementById('arenaEmoji');
            const deckCardGrid = document.getElementById('deckCardGrid');
            const collectionCardGrid = document.getElementById('collectionCardGrid');
            const lockedCardGrid = document.getElementById('lockedCardGrid'); 
            const deckCount = document.getElementById('deckCount');
            const teammateChoiceModal = document.getElementById('teammateChoiceModal');
            const aiTeammateBtn = document.getElementById('aiTeammateBtn');
            const friendTeammateBtn = document.getElementById('friendTeammateBtn');
            const cancelTeammateBtn = document.getElementById('cancelTeammateBtn');
            const friendCodeModal = document.getElementById('friendCodeModal');
            const createCodeBtn = document.getElementById('createCodeBtn');
            const joinCodeBtn = document.getElementById('joinCodeBtn');
            const cancelFriendBtn = document.getElementById('cancelFriendBtn');
            const createCodeModal = document.getElementById('createCodeModal');
            const generatedCode = document.getElementById('generatedCode');
            const cancelCreateBtn = document.getElementById('cancelCreateBtn');
            const joinCodeModal = document.getElementById('joinCodeModal');
            const codeInput = document.getElementById('codeInput');
            const confirmJoinBtn = document.getElementById('confirmJoinBtn');
            const cancelJoinBtn = document.getElementById('cancelJoinBtn');
            const aiTeammateUI = document.getElementById('aiTeammateUI');
            const aiTeammateHand = document.getElementById('aiTeammateHand');
            const aiTeammateNext = document.getElementById('aiTeammateNext');
            const aiTeammateElixirBar = document.getElementById('aiTeammateElixirBar');
            const aiTeammateElixirCount = document.getElementById('aiTeammateElixirCount');
            const cardHandEl = document.getElementById('cardHand');
            const nextCardSlotEl = document.getElementById('nextCardSlot');
            const placementIndicator = document.getElementById('placementIndicator');
            const placementOverlay = document.getElementById('placementOverlay'); // NEW
            const menuButton = document.getElementById('menuButton');
            const towerLevelDisplay = document.getElementById('towerLevelDisplay');
            const towerInfoStats = document.getElementById('towerInfoStats');
            const towerInfoProgressContainer = document.getElementById('towerInfoProgressContainer');
            const towerInfoProgressBar = document.getElementById('towerInfoProgressBar');
            const towerInfoProgressText = document.getElementById('towerInfoProgressText');
            const towerUpgradeButton = document.getElementById('towerUpgradeButton');
            const cardInfoModal = document.getElementById('cardInfoModal');
            const cardInfoCloseBtn = document.getElementById('cardInfoCloseBtn');
            const cardInfoDisplay = document.getElementById('cardInfoDisplay');
            const cardInfoName = document.getElementById('cardInfoName');
            const cardInfoType = document.getElementById('cardInfoType');
            const cardInfoLevel = document.getElementById('cardInfoLevel');
            const cardInfoStats = document.getElementById('cardInfoStats');
            const cardInfoButtons = document.getElementById('cardInfoButtons'); 
            const cardInfoProgressContainer = document.getElementById('cardInfoProgressContainer');
            const cardInfoProgressBar = document.getElementById('cardInfoProgressBar');
            const cardInfoProgressText = document.getElementById('cardInfoProgressText');
            const cardInfoButton = document.getElementById('cardInfoButton');
            const chestOpenOverlay = document.getElementById('chestOpenOverlay');
            const chestRewardList = document.getElementById('chestRewardList');
            const chestCloseButton = document.getElementById('chestCloseButton');
            // Debug Buttons
            const debugArena2 = document.getElementById('debugArena2');
            const debugArena3 = document.getElementById('debugArena3');
            const debugArena4 = document.getElementById('debugArena4'); // NEW
            const debugArena5 = document.getElementById('debugArena5'); // NEW
            const debugUnlockAll = document.getElementById('debugUnlockAll');
            const debugUpgradeAll = document.getElementById('debugUpgradeAll');
            const debugGetChest = document.getElementById('debugGetChest');
            const debugAddGold = document.getElementById('debugAddGold');
            const debugReset = document.getElementById('debugReset');
            // Debug Password
            const debugPasswordOverlay = document.getElementById('debugPasswordOverlay');
            const debugPasswordInput = document.getElementById('debugPasswordInput');
            const debugPasswordSubmit = document.getElementById('debugPasswordSubmit');
            const debugPasswordCancel = document.getElementById('debugPasswordCancel');
            // NEW: Save/Load Data
            const saveDataBtn = document.getElementById('saveDataBtn');
            const saveDataOverlay = document.getElementById('saveDataOverlay');
            const generateKeyBtn = document.getElementById('generateKeyBtn');
            const saveKeyOutput = document.getElementById('saveKeyOutput');
            const saveDataCancel = document.getElementById('saveDataCancel');
            const loadKeyBtn = document.getElementById('loadKeyBtn');
            const loadDataOverlay = document.getElementById('loadDataOverlay');
            const loadKeyInput = document.getElementById('loadKeyInput');
            const loadKeySubmit = document.getElementById('loadKeySubmit');
            const loadDataCancel = document.getElementById('loadDataCancel');
            // Update Log
            const updateLogOverlay = document.getElementById('updateLogOverlay');
            const updateLogContent = document.getElementById('updateLogContent');
            const updateLogClose = document.getElementById('updateLogClose');


            // --- Game Elements (from gameScreen) ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const elixirBar = document.getElementById('elixirBar');
            const elixirText = document.getElementById('elixirText');
            const messageOverlay = document.getElementById('messageOverlay');
            const messageText = document.getElementById('messageText');
            const startButton = document.getElementById('startButton');
            const timerDisplay = document.getElementById('timerDisplay');


            // ==============================================
            // FIREBASE & USER DATA
            // ==============================================
            
            // This is the function that runs after a login attempt
            async function handleAuth(user) {
                // This 'if' block stops the auto-login on page load
                if (isInitialAuthCheck) {
                    isInitialAuthCheck = false;
                    
                    // --- REFERENCEERROR FIX ---
                    // initCardSystem() call REMOVED from here. It's now called *after* classes are defined.
                    // --- END FIX ---
                    
                    return;
                }
                
                // If the login was real (not auto), and not a guest
                if (user && !user.isAnonymous) {
                    // Prevent this from running twice if it's already loading
                    if (isLoading) return;
                    isLoading = true;

                    userId = user.uid;
                    userDocRef = doc(db, 'artifacts', appId, 'users', userId);
                    isDataSaved = true; // Assume we can save unless timer fires
                    
                    showScreen('loading');
                    loadingScreen.querySelector('p').textContent = 'Loading Progress...';
                    
                    // Clear any old timer
                    clearTimeout(loadTimeout);
                    
                    // --- NEW: The 8-second "failsafe" timer ---
                    loadTimeout = setTimeout(() => {
                        console.warn("Firebase load took too long! (8s)");
                        // If it's still loading, force it to stop and start a new game
                        if (isLoading) {
                            isLoading = false;
                            isDataSaved = false; // Disable saving to prevent overwrite
                            initNewUser(); // Load a blank game locally
                            showScreen('menu'); // Go to menu
                        }
                    }, 8000); // 8 seconds

                    try {
                        await loadUserData();
                    } catch (error) {
                        console.error("Error in loadUserData:", error);
                        initNewUser(); // If loading fails, start a new game
                    } finally {
                        // This code runs *only if* loading finishes *before* the 8-second timer
                        if (isLoading) {
                            clearTimeout(loadTimeout); // Cancel the failsafe timer
                            isLoading = false;
                            showScreen('menu'); // Go to menu normally
                        }
                    }

                } else {
                    // Not logged in or is anonymous
                    userId = null;
                    userDocRef = null;
                    isDataSaved = false;
                    isLoading = false;
                    showScreen('login');
                }
            }

            function initNewUser() {
                trophies = 0;
                gold = 500;
                towerLevel = 1;
                towerCardCount = 0;
                trophyChests = [];
                cardCollection = initNewUserCards(false);
                playerDeck = initNewUserCards(true);
                playerDeck2v2 = [];
                // We don't save here, we let the game save after a win/loss
            }

            // NEW: "Guest (No Save)" logic
            function initGuestSession() {
                initNewUser(); // Load default data
                
                // Disable saving
                userDocRef = null; 
                userId = null;
                isDataSaved = false; // Prevent save attempts
            }

            async function loadUserData(dataToLoad = null) {
                // Load from a manual save key (guest-style)
                if (dataToLoad) {
                    trophies = dataToLoad.trophies || 0;
                    gold = dataToLoad.gold || 500;
                    towerLevel = dataToLoad.towerLevel || 1;
                    towerCardCount = dataToLoad.towerCardCount || 0;
                    trophyChests = dataToLoad.trophyChests || [];
                    cardCollection = dataToLoad.cardCollection || initNewUserCards(false);
                    playerDeck = dataToLoad.playerDeck || initNewUserCards(true);
                    playerDeck2v2 = dataToLoad.playerDeck2v2 || [];
                    return;
                }

                // Normal Firebase-backed load
                if (!userDocRef) {
                    // No user doc; just start a new user locally
                    initNewUser();
                    return;
                }

                try {
                    const docSnap = await getDoc(userDocRef);
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        trophies = data.trophies || 0;
                        gold = data.gold || 500;
                        towerLevel = data.towerLevel || 1;
                        towerCardCount = data.towerCardCount || 0;
                        trophyChests = data.trophyChests || [];
                        cardCollection = data.cardCollection || initNewUserCards(false);
                        playerDeck = data.playerDeck || initNewUserCards(true);
                        playerDeck2v2 = data.playerDeck2v2 || [];
                    } else {
                        // First time user: init defaults
                        initNewUser();
                    }
                } catch (error) {
                    console.error("Error loading user data:", error);
                    // If loading fails, just start a new game locally and disable saving
                    isDataSaved = false;
                    initNewUser();
                }
            }

            function initNewUserCards(deckOnly = false) {
                let newCollection = {};
                
                // Add all cards to collection with count 0 (except Arena 1)
                for (const cardId in allCards) {
                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Don't add tower or internal mini to collection
                    newCollection[cardId] = { level: 1, count: 0, unlocked: false }; // ADDED unlocked
                }
                
                // Add Arena 1 cards with count 1
                for (const cardId in allCards) {
                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Don't add tower or internal mini to collection
                    if (allCards[cardId].arena === 1) {
                        newCollection[cardId] = { level: 1, count: 1, unlocked: true }; // ADDED unlocked
                    }
                }
                
                if (deckOnly) {
                    // FIX: Filter out 'tower' from starting deck
                    return Object.keys(allCards).filter(id => allCards[id].arena === 1 && id !== 'tower' && id !== 'stoneGiant' && id !== 'miniStoneGiant');
                }
                return newCollection;
            }

            async function saveUserData() {
                if (!isDataSaved) return; // This will be false for guests
                
                // Use Firebase if logged in
                if (userDocRef) {
                    isDataSaved = false; // Prevent multiple saves
                    try {
                        const dataToSave = {
                            trophies,
                            gold,
                            towerLevel,
                            towerCardCount,
                            trophyChests,
                            cardCollection,
                            playerDeck,
                            playerDeck2v2,
                            lastSaved: new Date().toISOString()
                        };
                        await setDoc(userDocRef, dataToSave, { merge: true });
                    } catch (error) {
                        console.error("Error saving user data:", error);
                    }
                    isDataSaved = true; // Allow saving again
                }
                // If not logged in (e.g., guest mode), we simply don't save.
            }
            
            googleLoginBtn.addEventListener('click', async () => {
                loginError.textContent = '';
                try {
                    // This will trigger the onAuthStateChanged listener
                    await signInWithPopup(auth, provider);
                } catch (error) {
                    isLoading = false; // Make sure loading stops on fail
                    if (error.code === 'auth/unauthorized-domain') {
                        loginError.textContent = 'Google Sign-in is not set up.';
                    } else if (error.code === 'auth/popup-blocked') {
                        loginError.textContent = 'Pop-up blocked! Please allow pop-ups.';
                    } else {
                        loginError.textContent = 'Could not sign in. Please try again.';
                    } 
                }
            });
            
            // "Play as Guest (No Save)" button
            trueGuestLoginBtn.addEventListener('click', () => {
                loginError.textContent = ''; // Clear errors
                initGuestSession(); // Load default data, disable saving
                showScreen('loading');
                loadingScreen.querySelector('p').textContent = 'Starting Guest Game...';
                setTimeout(() => showScreen('menu'), 1000); // Short delay
            });

            // --- NEW: Save/Load Key Logic ---
            saveDataBtn.addEventListener('click', () => {
                saveKeyOutput.value = "Generating key...";
                generateKeyBtn.disabled = true;
                generateKeyBtn.textContent = 'Generate New Key (30s)';
                saveDataOverlay.style.display = 'flex';

                // Generate key
                const dataToSave = {
                    trophies, gold, towerLevel, towerCardCount, 
                    trophyChests, cardCollection, playerDeck, playerDeck2v2
                };
                const jsonString = JSON.stringify(dataToSave);
                const saveKey = btoa(jsonString); // Base64 encode
                saveKeyOutput.value = saveKey;

                // Start cooldown
                let cooldown = 30;
                generateKeyBtn.textContent = `Generate New Key (${cooldown}s)`;
                clearTimeout(generateKeyTimeout);
                generateKeyTimeout = setInterval(() => {
                    cooldown--;
                    generateKeyBtn.textContent = `Generate New Key (${cooldown}s)`;
                    if (cooldown <= 0) {
                        clearInterval(generateKeyTimeout);
                        generateKeyBtn.textContent = 'Generate New Key';
                        generateKeyBtn.disabled = false;
                    }
                }, 1000);
            });
            saveDataCancel.addEventListener('click', () => {
                saveDataOverlay.style.display = 'none';
                clearInterval(generateKeyTimeout);
                generateKeyBtn.disabled = false;
                generateKeyBtn.textContent = 'Generate New Key';
            });
            generateKeyBtn.addEventListener('click', () => {
                // Re-generate key and start cooldown
                saveDataBtn.click(); // Just re-click the main button
            });
            loadKeyBtn.addEventListener('click', () => {
                loadKeyInput.value = '';
                loadKeyInput.placeholder = 'Paste your key here';
                loadDataOverlay.style.display = 'flex';
            });
            loadDataCancel.addEventListener('click', () => {
                loadDataOverlay.style.display = 'none';
            });

            // --- Mode Selector Logic ---
            function updateModeUI() {
                if (gameMode === '2v2') {
                    modeNormal.classList.remove('bg-red-600', 'text-white');
                    modeNormal.classList.add('text-gray-400');
                    mode2v2.classList.remove('text-gray-400');
                    mode2v2.classList.add('bg-red-600', 'text-white');
                } else {
                    modeNormal.classList.remove('text-gray-400');
                    modeNormal.classList.add('bg-red-600', 'text-white');
                    mode2v2.classList.remove('bg-red-600', 'text-white');
                    mode2v2.classList.add('text-gray-400');
                }
            }

            modeNormal.addEventListener('click', () => {
                gameMode = 'normal';
                updateModeUI();
                renderDeckScreen(); // Re-render deck for new mode
                updateBattleButtonState(); // Update button for new mode
            });

            mode2v2.addEventListener('click', () => {
                gameMode = '2v2';
                updateModeUI();
                renderDeckScreen(); // Re-render deck for new mode
                updateBattleButtonState(); // Update button for new mode
            });

            // Initialize mode UI
            updateModeUI();

            // --- 2v2 Teammate Choice Modal ---
            function show2v2TeammateChoice() {
                teammateChoiceModal.style.display = 'flex';
            }

            function hide2v2TeammateChoice() {
                teammateChoiceModal.style.display = 'none';
            }

            aiTeammateBtn.addEventListener('click', () => {
                hide2v2TeammateChoice();
                is2v2AITeammate = true;
                is2v2Friend = false;
                // TODO: replace with 2v2 initGame2v2 later
                menuScreen.classList.remove('active');
                loadingScreen.classList.add('active');
                loadingScreen.querySelector('p').textContent = 'Finding 2v2 Match...';
                setTimeout(() => {
                    showScreen('game');
                    messageText.textContent = 'Get Ready!';
                    startButton.style.display = 'none';
                    menuButton.style.display = 'none';
                    messageOverlay.style.display = 'flex';
                    setTimeout(() => {
                        initGame(); // TEMP: use normal init until 2v2 logic is added
                        lastTime = performance.now();
                        gameLoopId = requestAnimationFrame(gameLoop);
                    }, 1500);
                }, 1000);
            });

            friendTeammateBtn.addEventListener('click', () => {
                hide2v2TeammateChoice();
                is2v2Friend = true;
                is2v2AITeammate = false;
                showFriendCodeModal();
            });

            cancelTeammateBtn.addEventListener('click', () => {
                hide2v2TeammateChoice();
            });

            // --- Friend Code Flow ---
            function showFriendCodeModal() {
                friendCodeModal.style.display = 'flex';
            }

            function hideFriendCodeModal() {
                friendCodeModal.style.display = 'none';
            }

            function showCreateCodeModal() {
                const code = Math.floor(10000 + Math.random() * 90000).toString();
                generatedCode.textContent = code;
                createCodeModal.style.display = 'flex';
                // TODO: In real version, we'd listen for joins. For now, just start after a delay.
                setTimeout(() => {
                    if (createCodeModal.style.display !== 'none') {
                        // Simulate friend joining
                        startFriend2v2Match();
                    }
                }, 5000);
            }

            function hideCreateCodeModal() {
                createCodeModal.style.display = 'none';
            }

            function showJoinCodeModal() {
                joinCodeModal.style.display = 'flex';
                codeInput.value = '';
            }

            function hideJoinCodeModal() {
                joinCodeModal.style.display = 'none';
            }

            function startFriend2v2Match() {
                hideCreateCodeModal();
                hideJoinCodeModal();
                is2v2Friend = true;
                is2v2AITeammate = false;
                // Start the match
                menuScreen.classList.remove('active');
                loadingScreen.classList.add('active');
                loadingScreen.querySelector('p').textContent = 'Starting 2v2 with Friend...';
                setTimeout(() => {
                    showScreen('game');
                    messageText.textContent = 'Get Ready!';
                    startButton.style.display = 'none';
                    menuButton.style.display = 'none';
                    messageOverlay.style.display = 'flex';
                    setTimeout(() => {
                        initGame(); // TEMP: use normal init until 2v2 logic is added
                        lastTime = performance.now();
                        gameLoopId = requestAnimationFrame(gameLoop);
                    }, 1500);
                }, 1000);
            }

            friendTeammateBtn.addEventListener('click', () => {
                hide2v2TeammateChoice();
                showFriendCodeModal();
            });

            cancelFriendBtn.addEventListener('click', () => {
                hideFriendCodeModal();
            });

            createCodeBtn.addEventListener('click', () => {
                hideFriendCodeModal();
                showCreateCodeModal();
            });

            cancelCreateBtn.addEventListener('click', () => {
                hideCreateCodeModal();
            });

            joinCodeBtn.addEventListener('click', () => {
                hideFriendCodeModal();
                showJoinCodeModal();
            });

            confirmJoinBtn.addEventListener('click', () => {
                const code = codeInput.value.trim();
                if (code.length === 5) {
                    // Simulate successful join
                    startFriend2v2Match();
                } else {
                    alert('Enter a 5-digit code.');
                }
            });

            cancelJoinBtn.addEventListener('click', () => {
                hideJoinCodeModal();
            });
            loadKeySubmit.addEventListener('click', async () => {
                const saveKey = loadKeyInput.value;
                if (!saveKey) return;
                try {
                    const jsonString = atob(saveKey); // Base64 decode
                    const dataToLoad = JSON.parse(jsonString);
                    
                    // We're loading a key, so treat as a "Guest" session (no Firebase save)
                    initGuestSession(); 
                    // Now, load the data from the key
                    await loadUserData(dataToLoad); 

                    loadDataOverlay.style.display = 'none';
                    showScreen('loading');
                    loadingScreen.querySelector('p').textContent = 'Loading Progress...';
                    setTimeout(() => showScreen('menu'), 1000);

                } catch (error) {
                    console.error("Failed to load save key:", error);
                    loadKeyInput.value = '';
                    loadKeyInput.placeholder = 'Invalid key! Please try again.';
                }
            });


            // ==============================================
            // SCREEN & NAVIGATION LOGIC
            // ==============================================
            function showScreen(screenId) {
                currentScreen = screenId;
                screens.forEach(s => { s.id === screenId + 'Screen' ? s.classList.add('active') : s.classList.remove('active'); });
                
                if (screenId === 'menu' || screenId === 'deck' || screenId === 'tower' || screenId === 'debug') {
                    navButtons.forEach(btn => { if (btn.dataset.screen === screenId) { btn.classList.add('text-yellow-400'); btn.classList.remove('text-gray-400'); } else { btn.classList.remove('text-yellow-400'); btn.classList.add('text-gray-400'); } });
                }
                
                if (screenId === 'deck') { renderDeckScreen(); }
                if (screenId === 'tower') { renderTowerScreen(); }
                if (screenId === 'menu') { 
                    updateArena(); 
                    trophyDisplay.textContent = `üèÜ ${trophies}`; 
                    goldDisplay.textContent = `üí∞ ${gold}`; 
                    renderChests(); 
                    updateBattleButtonState(); 
                    // Show update log once after loading screen
                    if (!hasShownUpdateLog) {
                        hasShownUpdateLog = true;
                        setTimeout(() => showUpdateLog(), 300); // Small delay to ensure menu is visible
                    }
                }
            }

            function showDebugPassword() {
                if (!isLocalFile) return;
                debugPasswordInput.value = '';
                debugPasswordOverlay.style.display = 'flex';
                debugPasswordInput.focus();
            }
            debugPasswordSubmit.addEventListener('click', () => {
                if (!isLocalFile) return;
                if (debugPasswordInput.value.toUpperCase() === 'GEOMETRIC') {
                    debugPasswordOverlay.style.display = 'none';
                    showScreen('debug');
                } else {
                    debugPasswordInput.value = '';
                    debugPasswordInput.placeholder = 'Wrong! Try again.';
                }
            });
            debugPasswordCancel.addEventListener('click', () => {
                debugPasswordOverlay.style.display = 'none';
            });


            function updateArena() {
                let currentTrophyFloor = 0;
                let arenaDisplayName = "Arena 1: Emoji Valley";
                let emoji = "üèûÔ∏è";
                currentArenaTheme = 'arena-1';
                
                for (const floor in arenaFloors) { if (trophies >= parseInt(floor)) { currentTrophyFloor = parseInt(floor); arenaDisplayName = arenaFloors[floor]; } }
                currentArenaFloor = currentTrophyFloor;
                
                if (arenaDisplayName.includes("Laughing Village")) {
                    emoji = "üèòÔ∏è";
                    currentArenaTheme = 'arena-2';
                } else if (arenaDisplayName.includes("Lava Town")) {
                    emoji = "üåã";
                    currentArenaTheme = 'arena-3';
                } else if (arenaDisplayName.includes("Mages Graveyard")) {
                    emoji = "ü™¶";
                    currentArenaTheme = 'arena-7';
                } else if (arenaDisplayName.includes("The Farm")) { // NEW
                    emoji = "üöú"; // NEW
                    currentArenaTheme = 'arena-4'; // NEW
                } else if (arenaDisplayName.includes("Skull Kingdom")) { // NEW
                    emoji = "üíÄ"; // NEW
                    currentArenaTheme = 'arena-5'; // NEW
                } else if (arenaDisplayName.includes("Warlock's Workshop")) { // NEW
                    emoji = "üîÆ"; // NEW
                    currentArenaTheme = 'arena-6'; // NEW
                } else if (arenaDisplayName.includes("Chaos Canyon")) { // NEW
                    emoji = "‚ö°"; // NEW
                    currentArenaTheme = 'arena-8'; // NEW
                }
                arenaName.textContent = arenaDisplayName;
                arenaEmoji.textContent = emoji;
                canvas.className = currentArenaTheme;
            }

            function renderChests() {
                const slots = document.querySelectorAll('#chestSlots .chest-slot');
                slots.forEach((slot, index) => {
                    slot.innerHTML = '';
                    slot.onclick = null;
                    if (trophyChests[index]) {
                        slot.innerHTML = `üì¶`;
                        slot.classList.remove('text-gray-500', 'bg-gray-700');
                        slot.classList.add('bg-yellow-700', 'cursor-pointer');
                        slot.onclick = () => openChest(index);
                    } else {
                        slot.innerHTML = ``;
                        slot.classList.add('text-gray-500', 'bg-gray-700');
                        slot.classList.remove('bg-yellow-700', 'cursor-pointer');
                    }
                });
            }
            
            function getChestRewardMultiplier() {
                const arenaLevel = getAILevel();
                const multipliers = {
                    1: 1.0,
                    2: 1.2,
                    3: 1.4,
                    4: 1.6,
                    5: 1.8,
                    6: 2.0,
                    7: 2.3,
                    8: 2.6
                };
                return multipliers[arenaLevel] || 1.0;
            }
            
            function openChest(index) {
                const chest = trophyChests[index];
                if (!chest) return;
                trophyChests.splice(index, 1);
                
                const multiplier = getChestRewardMultiplier();
                const rewardGold = Math.floor((50 + Math.floor(Math.random() * 50)) * multiplier);
                gold += rewardGold;
                let rewardsHTML = `<div><span class="text-3xl">üí∞</span> <span class="text-yellow-400">${rewardGold} Gold</span></div>`;
                
                const unlockedCards = getUnlockedCards(true);
                const numCardStacks = Math.floor((2 + Math.floor(Math.random() * 2)) * multiplier);
                
                for(let i = 0; i < numCardStacks; i++) {
                    const cardId = unlockedCards[Math.floor(Math.random() * unlockedCards.length)];
                    const cardCount = Math.floor((3 + Math.floor(Math.random() * 5)) * multiplier);
                    
                    if (cardId === 'tower') {
                        towerCardCount += cardCount;
                        rewardsHTML += `<div><span class="text-3xl">üëë</span> ${cardCount}x Tower Cards</div>`;
                    } else {
                        if (!cardCollection[cardId]) {
                            cardCollection[cardId] = { level: 1, count: 0, unlocked: false };
                        }
                        if (!cardCollection[cardId].unlocked) {
                            cardCollection[cardId].unlocked = true;
                        }
                        cardCollection[cardId].count += cardCount;
                        rewardsHTML += `<div><span class="text-3xl">${allCards[cardId].emoji}</span> ${cardCount}x ${allCards[cardId].name}</div>`;
                    }
                }
                
                chestRewardList.innerHTML = rewardsHTML;
                chestOpenOverlay.style.display = 'flex';
                
                renderChests();
                updateArena();
                saveUserData();
            }
            chestCloseButton.addEventListener('click', () => {
                chestOpenOverlay.style.display = 'none';
            });

            navButtons.forEach(btn => { 
                btn.addEventListener('click', () => { 
                    if (btn.dataset.screen === 'debug') {
                        if (isLocalFile) {
                            showDebugPassword();
                        }
                    } else {
                        showScreen(btn.dataset.screen); 
                    }
                }); 
            });
            // NEW: Show update log function
            function showUpdateLog() {
                const updates = [
                    { date: '11/25/2025', title: 'Latest Update', items: [
                        'Added 2v2 Mode: Team up with an AI teammate against two AI opponents',
                        'New King Tower Visuals: Combined king tower in 2v2 mode shows two crowns',
                        'AI Improvements: 2v2 AI opponents and teammates now use all available cards',
                        'UI Updates: Added health text display on all towers',
                        'Fixed various bugs with card restrictions and deck initialization'
                    ]},
                    { date: '11/24/2025', title: 'Previous Update', items: [
                        'Added Arena 8: Chaos Canyon (1750+ trophies) with custom card classes',
                        'Added Chaos Elemental card - Melee unit with high damage and speed (üëπ)',
                        'Added Shadow Clone card - Ranged unit with moderate damage (üë§)',
                        'Added Void Trap spell - Area damage spell for area control (‚ö´)',
                        'Added Stone Giant card - Tank unit with high health (üóø)',
                        'Added Chaos Orb spell - Damage spell for offense (üåÄ)',
                        'Buffed all Spirits: health increased from 50 to 150 (now takes 3 tower hits to kill)',
                        'Updated AI difficulty scaling per arena: Arena 1 lvl 1, Arena 2 lvl 1-2, Arena 3 lvl 2-3, Arena 4 lvl 2-3, Arena 5 lvl 4-5, Arena 6 lvl 4-5, Arena 7 lvl 5-6, Arena 8 lvl 5-6',
                        'Chests now give more money and cards in higher arenas'
                    ]},
                    { date: '11/22/2025', title: 'Previous Update', items: [
                        'Added Arena 7: Mages Graveyard (1500+ trophies)',
                        'Added Mage card - Ranged unit with splash damage, attacks ground and air. Every 5 seconds, spawns 4 Skeletons in a square around her.',
                        'Added Phantom Knight card: Spawns invisible and cannot be seen by enemy troops. Only attacks ground units. When attacking, becomes fully visible and can be targeted by enemy troops. Returns to invisible after 3 seconds of not attacking. Spells still hit invisible Phantom Knights. Spirits cannot see invisible Phantom Knights. Visual effect shows semi-transparent ghost when invisible.',
                        'Added Spirit Lantern card - Spawns a random spirit (Zap, Cold, or Life Spirit) every 6 seconds.',
                        'Added Arena 6: Warlock\'s Workshop (1250+ trophies)',
                        'Added Warlock card - Ranged unit with splash damage, attacks ground and air',
                        'Added Zap Spirit - Jumps on enemies and chains electricity to up to 10 targets',
                        'Added Cold Spirit - Jumps and freezes enemies in area for 3 seconds',
                        'Added Life Spirit - Jumps and creates healing circle for friendly units (3 seconds)',
                        'Added Bomb Spirit - Jumps and explodes damaging enemies in area',
                        'Added Spear Goblins card - Spawns 3 spear goblins (unlocks Arena 2)',
                        'Added Anger spell - Purple pool that gives 2x damage and 1.5x attack speed (5 seconds, persists 3s after leaving)',
                        'Buffed Skeletons and Skeleton Group: damage increased from 2 to 5'
                    ]},
                    { date: 'Previous Updates', title: 'Previous Features', items: [
                        'Arena system with 5 arenas',
                        'Card collection and deck building',
                        'Tower upgrades',
                        'Chest system',
                        'Multiple unit types and spells',
                        'AI opponents',
                        'Save/load system'
                    ]}
                ];
                
                let html = '';
                updates.forEach(update => {
                    html += `<div class="mb-4"><h3 class="font-bold text-lg text-yellow-400 mb-2">${update.title} - ${update.date}</h3><ul class="list-disc list-inside space-y-1">`;
                    update.items.forEach(item => {
                        html += `<li>${item}</li>`;
                    });
                    html += `</ul></div>`;
                });
                updateLogContent.innerHTML = html;
                updateLogOverlay.style.display = 'flex';
            }
            
            updateLogClose.addEventListener('click', () => {
                updateLogOverlay.style.display = 'none';
            });
            
            battleButton.addEventListener('click', () => {
                if (battleButton.disabled) return;
                if (gameMode === '2v2') {
                    if (playerDeck2v2.length !== 8) {
                        alert('Add 8 cards to your 2v2 deck first!');
                        showScreen('deck');
                        return;
                    }
                    // Show teammate choice modal
                    show2v2TeammateChoice();
                } else {
                    // Normal flow
                    menuScreen.classList.remove('active');
                    loadingScreen.classList.add('active');
                    loadingScreen.querySelector('p').textContent = 'Finding Opponent...';
                    setTimeout(() => {
                        showScreen('game');
                        messageText.textContent = 'Get Ready!';
                        startButton.style.display = 'none';
                        menuButton.style.display = 'none';
                        messageOverlay.style.display = 'flex';
                        setTimeout(() => {
                            initGame();
                            lastTime = performance.now();
                            gameLoopId = requestAnimationFrame(gameLoop);
                        }, 1500);
                    }, 1000);
                }
            });
            // NEW: Arena screen buttons
            arenaButton.addEventListener('click', () => {
                showScreen('arena');
            });
            arenaBackButton.addEventListener('click', () => {
                showScreen('menu');
            });
            menuButton.addEventListener('click', () => { showScreen('menu'); gameRunning = false; cancelAnimationFrame(gameLoopId); });

            // ==============================================
            if (isLocalFile) {
                debugArena2.addEventListener('click', () => {
                    trophies = 250;
                    updateArena();
                    saveUserData();
                    showScreen('menu');
                });
                debugArena3.addEventListener('click', () => {
                    trophies = 500;
                    updateArena();
                    saveUserData();
                    showScreen('menu');
                });
                debugArena4.addEventListener('click', () => {
                    trophies = 750;
                    updateArena();
                    saveUserData();
                    showScreen('menu');
                });
                debugArena5.addEventListener('click', () => {
                    trophies = 1000;
                    updateArena();
                    saveUserData();
                    showScreen('menu');
                });
                const debugArena6 = document.getElementById('debugArena6');
                if (debugArena6) {
                    debugArena6.addEventListener('click', () => {
                        trophies = 1250;
                        updateArena();
                        saveUserData();
                        showScreen('menu');
                    });
                }
                const debugArena7 = document.getElementById('debugArena7');
                if (debugArena7) {
                    debugArena7.addEventListener('click', () => {
                        trophies = 1500;
                        updateArena();
                        saveUserData();
                        showScreen('menu');
                    });
                }
                const debugArena8 = document.getElementById('debugArena8');
                if (debugArena8) {
                    debugArena8.addEventListener('click', () => {
                        trophies = 1750;
                        updateArena();
                        saveUserData();
                        showScreen('menu');
                    });
                }
                debugUnlockAll.addEventListener('click', () => {
                    for (const cardId in allCards) {
                        if (cardId === 'tower' || cardId === 'miniStoneGiant') continue;
                        if (!cardCollection[cardId]) {
                            cardCollection[cardId] = { level: 1, count: 1, unlocked: true };
                        } else {
                            cardCollection[cardId].unlocked = true;
                            if (cardCollection[cardId].count === 0) {
                                cardCollection[cardId].count = 1;
                            }
                        }
                    }
                    saveUserData();
                    console.log('All cards unlocked!');
                });
                debugUpgradeAll.addEventListener('click', () => {
                    for (const cardId in cardCollection) {
                        const cardData = cardCollection[cardId];
                        if (cardData.unlocked && cardData.level < 15) {
                            cardData.level++;
                        }
                    }
                    if (towerLevel < 15) towerLevel++;
                    saveUserData();
                    console.log('All owned cards and tower upgraded +1 level!');
                });
                debugGetChest.addEventListener('click', () => {
                    if (trophyChests.length < 4) {
                        trophyChests.push({ id: 'wood', openTime: 0 });
                        renderChests();
                        saveUserData();
                        console.log('Got a chest!');
                    } else {
                        console.log('Chest slots are full!');
                    }
                });
                debugAddGold.addEventListener('click', () => {
                    gold += 1000;
                    goldDisplay.textContent = `üí∞ ${gold}`;
                    saveUserData();
                    console.log('+1000 Gold!');
                });
                debugReset.addEventListener('click', () => {
                    if (true) {
                        initNewUser();
                        saveUserData();
                        showScreen('menu');
                        console.log('Account reset!');
                    }
                });
            }


            // ==============================================
            // CARD & DECK LOGIC
            // ==============================================

            function createCardDOM(cardId, isSmall = false, inHand = false) {
                const card = allCards[cardId];
                if (!card) return null;
                
                const cardData = cardCollection[cardId];
                // In 2v2 mode, treat all cards as unlocked and level 15
                const isLocked = (gameMode === '2v2') ? false : (!inHand && (!cardData || !cardData.unlocked));
                
                const cardEl = document.createElement('div');
                cardEl.className = `card-ui ${isSmall ? 'card-ui-small' : ''}`;
                cardEl.dataset.unit = cardId;
                
                if (isLocked) { // Removed !inHand check, it's now at the top
                    cardEl.classList.add('card-ui-locked');
                    cardEl.innerHTML = `
                        <div class="card-ui-cost">${card.cost}</div>
                        <span class="card-ui-name">${card.name}</span>
                        <span class="card-ui-emoji">${card.emoji}</span>
                        <span class="card-ui-type">${card.type}</span>
                        <div class="card-ui-locked-arena">Unlocks in Arena ${card.arena}</div>
                    `;
                    return cardEl;
                }

                const displayLevel = (gameMode === '2v2') ? 15 : ((cardData && cardData.level) ? cardData.level : 1);
                const displayCount = (cardData && cardData.count) ? cardData.count : 0;
                
                cardEl.dataset.cost = card.cost;
                cardEl.dataset.type = card.type;
                cardEl.dataset.emoji = card.emoji;
                cardEl.dataset.radius = card.placementRadius;
                if (card.radius) cardEl.dataset.spellRadius = card.radius;
                let progressBarHTML = '';
                let levelTextHTML = `<div class="card-ui-level">Lvl ${displayLevel}</div>`;
                if (!inHand) {
                    const costs = upgradeCosts[displayLevel];
                    let progress = 0;
                    let canUpgrade = false;
                    if (costs) {
                        progress = (displayCount / costs.cards) * 100;
                        if (displayCount >= costs.cards && gold >= costs.gold) { canUpgrade = true; }
                    } else { progress = 100; } // Max level
                    progressBarHTML = `<div class="card-ui-progress-bar"><div class="card-ui-progress ${canUpgrade ? 'can-upgrade' : ''}" style="width: ${Math.min(100, progress)}%;"></div></div>`;
                } else { levelTextHTML = ''; }
                cardEl.innerHTML = `<div class="card-ui-cost">${card.cost}</div><span class="card-ui-name">${card.name}</span><span class="card-ui-emoji">${card.emoji}</span><span class="card-ui-type">${card.type}</span>${levelTextHTML}${progressBarHTML}`;
                return cardEl;
            }

            function getUnlockedCards(includeTower = false, aiLevel = 0) {
                const unlocked = [];
                // Use AI level if provided, otherwise use player's trophies
                const arenaNum = aiLevel > 0 ? aiLevel : (currentArenaFloor === 0 ? 1 : (currentArenaFloor === 250 ? 2 : (currentArenaFloor === 500 ? 3 : (currentArenaFloor === 750 ? 4 : 5)))); // UPDATED
                
                for (const cardId in allCards) {
                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Never include tower or internal mini in this list
                    if (allCards[cardId].arena <= arenaNum) {
                        unlocked.push(cardId);
                    }
                }
                if (includeTower) {
                    unlocked.push('tower');
                }
                return unlocked;
            }

            function renderDeckScreen() {
                deckCardGrid.innerHTML = '';
                collectionCardGrid.innerHTML = '';
                lockedCardGrid.innerHTML = ''; 
                
                const currentDeck = gameMode === '2v2' ? playerDeck2v2 : playerDeck;
                deckCount.textContent = `Deck (${currentDeck.length} / 8)`;
                
                // Render Deck
                currentDeck.forEach(cardId => { 
                    const cardEl = createCardDOM(cardId, true); 
                    cardEl.addEventListener('click', () => openCardModal(cardId)); 
                    deckCardGrid.appendChild(cardEl); 
                });
                
                // Render Collection & Locked Cards
                for (const cardId in allCards) {
                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Don't show tower or internal mini in collection
                    
                    const cardData = cardCollection[cardId];
                    const isLocked = (gameMode === '2v2') ? false : (!cardData || !cardData.unlocked);
                    
                    const cardEl = createCardDOM(cardId, true);
                    cardEl.addEventListener('click', () => openCardModal(cardId));
                    
                    if (gameMode === '2v2') {
                        // In 2v2, all cards go to collection (unlocked)
                        collectionCardGrid.appendChild(cardEl);
                    } else {
                        // Normal mode: respect locks
                        if (isLocked) {
                            lockedCardGrid.appendChild(cardEl);
                        } else {
                            collectionCardGrid.appendChild(cardEl);
                        }
                    }
                }
                
                updateBattleButtonState();
            }
            
            function renderTowerScreen() {
                towerLevelDisplay.textContent = `Tower Level ${towerLevel}`;
                const stats = towerStats[towerLevel] || towerStats[Object.keys(towerStats).length];
                const dps = (stats.damage / stats.hitSpeed).toFixed(1);
                
                towerInfoStats.innerHTML = `
                    <div>King Health: <span>${stats.kingHealth}</span></div>
                    <div>Princess Health: <span>${stats.princessHealth}</span></div>
                    <div>Damage: <span>${stats.damage}</span></div>
                    <div>Hit Speed: <span>${stats.hitSpeed}s</span></div>
                    <div class="col-span-2 text-center">DPS: <span>${dps}</span></div>
                `;
                
                const costs = towerUpgradeCosts[towerLevel];
                if (costs) {
                    towerInfoProgressContainer.style.display = 'block';
                    const progress = (towerCardCount / costs.cards);
                    towerInfoProgressBar.style.width = `${Math.min(100, progress * 100)}%`;
                    towerInfoProgressText.textContent = `${towerCardCount} / ${costs.cards}`;
                    
                    const canUpgrade = towerCardCount >= costs.cards && gold >= costs.gold;
                    towerUpgradeButton.textContent = `Upgrade (üí∞ ${costs.gold})`;
                    towerUpgradeButton.disabled = !canUpgrade;
                } else {
                    towerInfoProgressContainer.style.display = 'none';
                    towerUpgradeButton.textContent = 'Max Level (15)';
                    towerUpgradeButton.disabled = true;
                }
            }
            towerUpgradeButton.addEventListener('click', () => {
                const costs = towerUpgradeCosts[towerLevel];
                if (costs && towerCardCount >= costs.cards && gold >= costs.gold) {
                    towerCardCount -= costs.cards;
                    gold -= costs.gold;
                    towerLevel++;
                    goldDisplay.textContent = `üí∞ ${gold}`;
                    renderTowerScreen();
                    saveUserData();
                }
            });


            function updateBattleButtonState() {
                const currentDeck = gameMode === '2v2' ? playerDeck2v2 : playerDeck;
                if (currentDeck.length === 8) {
                    battleButton.disabled = false;
                    battleButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    battleButton.textContent = 'BATTLE!';
                } else {
                    battleButton.disabled = true;
                    battleButton.classList.add('opacity-50', 'cursor-not-allowed');
                    battleButton.textContent = `Deck must have 8 cards (${currentDeck.length}/8)`;
                }
            }

            // --- FUNCTION MOVED ---
            // initCardSystem() was here, but it needs to be after classes are defined.

            // --- ERROR FIX: Added checks for card and card.stats ---
            function openCardModal(cardId) {
                const card = allCards[cardId];
                const cardData = cardCollection[cardId];
                if (!card) return; // Exit if card invalid
                
                // In 2v2 mode, treat all cards as unlocked and level 15 for display only
                const isLocked = (gameMode === '2v2') ? false : (!cardData || !cardData.unlocked);
                const displayLevel = (gameMode === '2v2') ? 15 : ((cardData && cardData.level) ? cardData.level : 1);
                
                // --- FIX: Check if card.stats exists ---
                const stats = card.stats ? card.stats[displayLevel] : null;

                cardInfoDisplay.innerHTML = '';
                cardInfoDisplay.appendChild(createCardDOM(cardId, false));
                cardInfoName.textContent = card.name;
                cardInfoType.textContent = card.type || 'Special'; // Fallback
                cardInfoLevel.textContent = isLocked ? "Not Unlocked" : `Level ${displayLevel}`;
                
                cardInfoStats.innerHTML = `<div>Targets: <span>${card.targets || '-'}</span></div>`;
                if (card.isFlying) cardInfoStats.innerHTML += `<div>Placement: <span>Air</span></div>`;
                else if (card.type !== 'Spell' && card.type !== 'Building') cardInfoStats.innerHTML += `<div>Placement: <span>Ground</span></div>`;
                

                // --- FIX: Only loop stats if stats is not null ---
                if (stats) {
                    for (const [key, value] of Object.entries(stats)) { 
                        if (key !== 'barbLevel') cardInfoStats.innerHTML += `<div>${key.charAt(0).toUpperCase() + key.slice(1).replace('_', ' ')}: <span>${value}</span></div>`; 
                    }
                    if (card.type === 'Spell') { cardInfoStats.innerHTML += `<div>Radius: <span>${card.radius}</span></div>`; }
                    if (stats.damage && stats.hitSpeed) { const dps = (stats.damage / stats.hitSpeed).toFixed(1); cardInfoStats.innerHTML += `<div>DPS: <span>${dps}</span></div>`; }
                }

                // Show skeleton stats for Mage card
                if (cardId === 'mage') {
                    // Skeletons spawned by Mage use the base skeleton stats (level 1)
                    const skelStats = allCards['skeletons'] && allCards['skeletons'].stats ? allCards['skeletons'].stats[1] : null;
                    if (skelStats) {
                        cardInfoStats.innerHTML += `<div class='mt-2 font-bold text-yellow-300'>Spawns 4 Skeletons every 5s:</div>`;
                        cardInfoStats.innerHTML += `<div>Skeleton HP: <span>${skelStats.health}</span></div>`;
                        cardInfoStats.innerHTML += `<div>Skeleton Damage: <span>${skelStats.damage}</span></div>`;
                        cardInfoStats.innerHTML += `<div>Skeleton Hit Speed: <span>${skelStats.hitSpeed}</span></div>`;
                        cardInfoStats.innerHTML += `<div>Skeleton Speed: <span>${skelStats.speed}</span></div>`;
                        cardInfoStats.innerHTML += `<div>Skeleton Aggro Range: <span>100</span></div>`;
                    }
                }

                if (cardId === 'stoneGiant') {
                    const miniStats = allCards['stoneGiant'] && allCards['stoneGiant'].miniStats ? allCards['stoneGiant'].miniStats[1] : null;
                    if (miniStats) {
                        cardInfoStats.innerHTML += `<div class='mt-2 font-bold text-yellow-300'>Splits into 2 Mini Stone Giants:</div>`;
                        cardInfoStats.innerHTML += `<div>Mini HP: <span>${miniStats.health}</span></div>`;
                        cardInfoStats.innerHTML += `<div>Mini Damage: <span>${miniStats.damage}</span></div>`;
                        cardInfoStats.innerHTML += `<div>Mini Hit Speed: <span>${miniStats.hitSpeed}</span></div>`;
                    }
                }

                cardInfoButtons.innerHTML = '';
                cardInfoProgressContainer.style.display = 'none';
                cardInfoButton.style.display = 'none';

                // --- FIX: Also check for !stats ---
                if (isLocked || !stats) {
                    if(isLocked) cardInfoLevel.textContent = `Unlocks in Arena ${card.arena}`;
                } else {
                    // Is unlocked and has stats: Show buttons and progress
                    const currentDeck = gameMode === '2v2' ? playerDeck2v2 : playerDeck;
                    const isInDeck = currentDeck.includes(cardId);
                    let addRemoveBtn = document.createElement('button');
                    addRemoveBtn.id = 'addRemoveBtn';
                    if (isInDeck) {
                        addRemoveBtn.textContent = 'Remove from Deck';
                        addRemoveBtn.className = 'modal-btn remove';
                        addRemoveBtn.disabled = false;
                        addRemoveBtn.onclick = () => removeFromDeck(cardId);
                    } else {
                        addRemoveBtn.textContent = 'Add to Deck';
                        addRemoveBtn.className = 'modal-btn add';
                        addRemoveBtn.onclick = () => addToDeck(cardId);
                        addRemoveBtn.disabled = currentDeck.length >= 8;
                        if (currentDeck.length >= 8) addRemoveBtn.textContent = 'Deck is Full (8/8)';
                    }
                    cardInfoButtons.appendChild(addRemoveBtn);
                    cardInfoProgressContainer.style.display = 'block';
                    cardInfoButton.style.display = 'block';
                    
                    const displayCount = cardData.count || 0;
                    const costs = upgradeCosts[displayLevel];
                    
                    if (costs) {
                        const progress = (displayCount / costs.cards);
                        cardInfoProgressBar.style.width = `${Math.min(100, progress * 100)}%`;
                        cardInfoProgressText.textContent = `${displayCount} / ${costs.cards}`;
                        const canUpgrade = displayCount >= costs.cards && gold >= costs.gold;
                        cardInfoProgressBar.classList.toggle('can-upgrade', canUpgrade);
                        cardInfoButton.className = 'modal-btn upgrade';
                        cardInfoButton.textContent = `Upgrade (üí∞ ${costs.gold})`;
                        cardInfoButton.disabled = !canUpgrade;
                        cardInfoButton.onclick = () => upgradeCard(cardId);
                    } else {
                        // Is max level
                        cardInfoProgressContainer.style.display = 'none';
                        cardInfoButton.className = 'modal-btn';
                        cardInfoButton.textContent = 'Max Level (15)';
                        cardInfoButton.disabled = true;
                    }
                }
                cardInfoModal.style.display = 'flex';
            }
            
            // --- SYNTAX ERROR FIX ---
            // The extra '}' was removed and this function was defined correctly
            function closeModal() {
                cardInfoModal.style.display = 'none';
            }
            
            async function addToDeck(cardId) {
                const currentDeck = gameMode === '2v2' ? playerDeck2v2 : playerDeck;
                if (currentDeck.length < 8) {
                    currentDeck.push(cardId);
                    renderDeckScreen();
                    updateBattleButtonState(); // Update battle button immediately
                    openCardModal(cardId);
                    await saveUserData();
                }
            }
            async function removeFromDeck(cardId) {
                const currentDeck = gameMode === '2v2' ? playerDeck2v2 : playerDeck;
                const index = currentDeck.indexOf(cardId);
                if (index > -1) {
                    currentDeck.splice(index, 1);
                    renderDeckScreen();
                    updateBattleButtonState(); // Update battle button immediately
                    openCardModal(cardId);
                    await saveUserData();
                }
            }
            async function upgradeCard(cardId) {
                const cardData = cardCollection[cardId];
                const costs = upgradeCosts[cardData.level];
                if (costs && cardData.count >= costs.cards && gold >= costs.gold) {
                    cardData.count -= costs.cards;
                    gold -= costs.gold;
                    cardData.level++;
                    goldDisplay.textContent = `üí∞ ${gold}`;
                    renderDeckScreen();
                    openCardModal(cardId);
                    await saveUserData();
                }
            }

            function shuffleDeck(deck) {
                let shuffled = [...deck]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } return shuffled;
            }

            function startGameDecks() {
                // Player
                gameDeck = shuffleDeck(playerDeck);
                hand = [];
                discardPile = [];
                for (let i = 0; i < 4; i++) { hand.push(gameDeck.pop()); }
                nextCard = gameDeck.pop();
                renderHand();
                
                // AI
                const aiArenaLevel = getAILevel(); // This is 1, 2, 3, 4 or 5
                
                // AI gets cards from its arena level, NO tower card
                const aiArenaCards = getUnlockedCards(false, aiArenaLevel);
                
                // Build a random 8-card deck
                aiDeck = [];
                let availableCards = [...aiArenaCards];
                for (let i = 0; i < 8; i++) {
                    if (availableCards.length === 0) availableCards = [...aiArenaCards]; // Refill if needed
                    let cardIndex = Math.floor(Math.random() * availableCards.length);
                    aiDeck.push(availableCards.splice(cardIndex, 1)[0]);
                }
                
                aiDeck = shuffleDeck(aiDeck);
                aiHand = [];
                aiDiscardPile = [];
                for (let i = 0; i < 4; i++) { if(aiDeck.length > 0) aiHand.push(aiDeck.pop()); }
                if(aiDeck.length > 0) aiNextCard = aiDeck.pop();
            }
            
            function aiPlayCard(cardId) {
                if (!allCards[cardId]) return; // Safety check
                aiElixir -= allCards[cardId].cost;
                aiDiscardPile.push(cardId);
                const handIndex = aiHand.indexOf(cardId);
                if (handIndex > -1) { aiHand.splice(handIndex, 1); }
                aiHand.push(aiNextCard);
                if (aiDeck.length === 0) { aiDeck = shuffleDeck(aiDiscardPile); aiDiscardPile = []; }
                aiNextCard = aiDeck.pop() || null;
            }

            function renderHand() {
                cardHandEl.innerHTML = '';
                hand.forEach((cardId, index) => {
                    const cardEl = createCardDOM(cardId, false, true);
                    cardEl.dataset.handIndex = index;
                    // Handle touch/mouse down for card selection
                    cardEl.addEventListener('mousedown', (e) => selectCard(e, cardEl, cardId));
                    cardEl.addEventListener('touchstart', (e) => selectCard(e, cardEl, cardId), { passive: false });
                    cardHandEl.appendChild(cardEl);
                });
                nextCardSlotEl.innerHTML = '';
                if (nextCard) {
                    nextCardSlotEl.appendChild(createCardDOM(nextCard, true, true));
                }
                updateCardUI();
            }

            function selectCard(e, cardEl, cardId) {
                e.preventDefault(); // Prevent scrolling/other actions
                if (!gameRunning) return;
                const card = allCards[cardId];
                if (card.cost > playerElixir) { console.log("Not enough elixir!"); return; }
                
                // Deselect if already selected
                if (selectedSpawningUnit && selectedSpawningUnit.id === cardId) {
                    cancelPlacement();
                    return;
                }

                // NEW: Click-to-select logic
                isDragging = false;
                let initialPos = (e.touches && e.touches[0]) ? e.touches[0] : e;
                dragStartX = initialPos.clientX;
                dragStartY = initialPos.clientY;

                document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));
                placementIndicator.style.display = 'block'; // FIX: Show immediately
                placementOverlay.style.display = 'block'; // Show red overlay
                placementIndicator.innerHTML = '';
                
                selectedSpawningUnit = {
                    id: cardId, cost: card.cost, type: card.type, radius: card.radius || 0, placementRadius: card.placementRadius,
                    emoji: card.emoji, isFlying: card.isFlying, handIndex: cardEl.dataset.handIndex
                };
                
                if (card.type === 'Spell') {
                    isSpawningSpell = true;
                    spellRadius = card.radius;
                    placementIndicator.className = 'spell';
                    placementIndicator.style.width = `${card.radius * 2}px`;
                    placementIndicator.style.height = `${card.radius * 2}px`;
                    if (cardId === 'poison') { // NEW: Poison color
                        placementIndicator.style.background = 'rgba(234, 179, 8, 0.2)';
                        placementIndicator.style.borderColor = '#eab308';
                    } else if (cardId === 'anger') { // NEW: Anger color
                        placementIndicator.style.background = 'rgba(147, 51, 234, 0.2)';
                        placementIndicator.style.borderColor = '#9333ea';
                    }
                } else if (card.type === 'Spirit') { // NEW: Handle spirits
                    isSpawningSpell = false;
                    placementRadius = card.placementRadius;
                    placementIndicator.className = '';
                    placementIndicator.style.width = `${placementRadius * 2}px`;
                    placementIndicator.style.height = `${placementRadius * 2}px`;
                    placementIndicator.innerHTML = card.emoji;
                } else {
                    isSpawningSpell = false;
                    placementRadius = card.placementRadius;
                    placementIndicator.className = '';
                    placementIndicator.style.width = `${placementRadius * 2}px`;
                    placementIndicator.style.height = `${placementRadius * 2}px`;
                    placementIndicator.innerHTML = card.emoji;
                }
                cardEl.classList.add('selected');
                
                // Update placement overlay based on destroyed towers
                updatePlacementOverlay();
                
                // Move indicator to initial touch/mouse position
                movePlacementIndicator(initialPos);
            }
            
            function cancelPlacement() {
                isSpawningSpell = false;
                placementIndicator.style.display = 'none';
                placementIndicator.style.background = 'rgba(255, 255, 255, 0.2)'; // NEW: Reset poison/anger color
                placementIndicator.style.borderColor = 'white';
                placementOverlay.style.display = 'none'; // Hide red overlay
                selectedSpawningUnit = null;
                isDragging = false; // NEW
                document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));
                updateCardUI();
            }

            function playCard(cardId, handIndex) {
                playerElixir -= allCards[cardId].cost;
                discardPile.push(cardId);
                hand.splice(handIndex, 1);
                hand.push(nextCard);
                if (gameDeck.length === 0) { gameDeck = shuffleDeck(discardPile); discardPile = []; }
                nextCard = gameDeck.pop();
                renderHand();
            }

            // --- NEW: Demo Mode AI for "Player" ---
            function demoRunPlayerAI() {
                if (playerElixir < 5) return; // Don't spam
                let affordableCards = hand.filter(id => allCards[id] && allCards[id].cost <= playerElixir && allCards[id].type !== 'Spell');
                if (affordableCards.length > 0) {
                    const cardId = affordableCards[Math.floor(Math.random() * affordableCards.length)];
                    const card = allCards[cardId];
                    const handIndex = hand.indexOf(cardId);
                    
                    // Find a valid spawn pos
                    const x = LANE_LEFT_X + Math.random() * (LANE_RIGHT_X - LANE_LEFT_X);
                    const y = RIVER_Y + 20 + Math.random() * 100; // Player's side

                    if (checkPlacement(x, y, card.placementRadius, card.type)) {
                        const level = (gameMode === '2v2') ? 15 : 5; // Demo level, force 15 in 2v2
                        // Safety check: ensure unitClass exists
                        if (!card.unitClass || typeof card.unitClass !== 'function') {
                            console.error('Invalid unitClass for card:', cardId, card);
                            return;
                        }
                        const newUnit = new card.unitClass(x, y, 'player', level);
                        if (newUnit instanceof GameObject) {
                            gameObjects.push(newUnit);
                        }
                        playCard(cardId, handIndex);
                    }
                }
            }


            // ==============================================
            // GAME OBJECTS (CLASSES)
            // ==============================================
            class GameObject {
                constructor(x, y, radius, team, health) { this.x = x; this.y = y; this.radius = radius; this.team = team; this.health = health; this.maxHealth = health; this.id = Math.random(); }
                // FIX: Removed bad code from here
                drawHealthBar(level) { 
                    const barWidth = this.radius * 2; 
                    const barHeight = 5; 
                    const barX = this.x - this.radius; 
                    const barY = this.y - this.radius - (this instanceof Tower ? 5 : 10); // Towers' bars are closer
                    
                    if (this.health < this.maxHealth) {
                        ctx.fillStyle = '#dc2626'; 
                        ctx.fillRect(barX, barY, barWidth, barHeight); 
                        ctx.fillStyle = '#16a34a'; 
                        ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight); 
                    } else {
                        ctx.fillStyle = '#16a34a'; 
                        ctx.fillRect(barX, barY, barWidth, barHeight); 
                    }
                    // Black outline
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                    
                    // Draw Level
                    if (level) {
                        ctx.font = 'bold 10px Inter';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillStyle = this.team === 'player' ? '#fff' : '#fde047'; // Player level white, AI yellow
                        
                        let textX = this.x;
                        let textY = this.y - this.radius - 12;
                        
                        // Adjust position for combined double king tower
                        if (this.isCombinedDoubleKing) {
                            textY = this.y - this.height/2 - 12;
                        }
                        
                        ctx.fillText(`Lvl ${level}`, textX, textY);
                    }
                }
                draw(color, emoji, level) { 
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); 
                    ctx.fillStyle = color; 
                    ctx.fill(); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.stroke(); 
                    if (emoji) { 
                        ctx.font = `${this.radius * 1.5}px Arial`; 
                        ctx.textAlign = 'center'; 
                        ctx.textBaseline = 'middle'; 
                        ctx.fillText(emoji, this.x, this.y); 
                    } 
                    this.drawHealthBar(level); 
                }
                update() {}
            }

            class Tower extends GameObject {
                constructor(x, y, team, isKing = false, level = 1, isCombinedDoubleKing = false) {
                    const s = towerStats[level] || towerStats[1];
                    const width = isCombinedDoubleKing ? 40 : (isKing ? 25 : 20);
                    const height = isCombinedDoubleKing ? 35 : (isKing ? 25 : 20);
                    super(x, y, width, team, isKing ? s.kingHealth : s.princessHealth);
                    this.isKing = isKing;
                    this.isCombinedDoubleKing = isCombinedDoubleKing;
                    this.height = height;
                    this.level = level; // Store level
                    this.attackRange = 150;
                    this.attackDamage = s.damage;
                    this.attackCooldown = s.hitSpeed * 60;
                    this.cooldownTimer = 0;
                    this.target = null;
                    this.isActive = isKing ? false : true; // Princess towers are active by default
                    this.activationAnimation = 0;
                    this.dyingAnimationTimer = 0;
                }
                findTarget() { 
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) { return; } 
                    this.target = null; 
                    let closestDist = this.attackRange; 
                    for (const obj of gameObjects) { 
                        if (obj.team !== this.team && (obj instanceof Unit)) {
                            if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                            const dist = getDistance(this, obj); 
                            if (dist < closestDist) { 
                                closestDist = dist; 
                                this.target = obj; 
                            } 
                        } 
                    } 
                }
                attack() { 
                    if (this.target) { 
                        if (this.isCombinedDoubleKing) {
                            // Fire two projectiles with slight horizontal offset
                            const offset = 8;
                            gameObjects.push(new Projectile(this.x - offset, this.y, this.target, this.team, this.attackDamage)); 
                            gameObjects.push(new Projectile(this.x + offset, this.y, this.target, this.team, this.attackDamage)); 
                        } else {
                            gameObjects.push(new Projectile(this.x, this.y, this.target, this.team, this.attackDamage)); 
                        }
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                }
                update() { 
                    if (this.health <= 0) return; 
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; } 
                    
                    let kingNeedsToActivate = false;
                    if (this.isKing) { 
                        const princessTowersDown = gameObjects.filter(t => t.team === this.team && !t.isKing && t.health > 0).length === 0; 
                        if (princessTowersDown || this.health < this.maxHealth) { 
                            if (!this.isActive) { 
                                this.isActive = true; 
                                this.activationAnimation = 30; 
                            } 
                            kingNeedsToActivate = true; 
                        } 
                        if (!kingNeedsToActivate) return; 
                    } 
                    
                    // Only active towers attack
                    if (this.isActive) {
                        this.findTarget(); 
                        if (this.target && this.cooldownTimer <= 0) { this.attack(); } 
                    }
                }
                draw() { 
                    ctx.save(); 
                    
                    // Draw the tower base (blue rectangle)
                    const fillColor = this.team === 'player' ? '#3b82f6' : '#ef4444';
                    ctx.fillStyle = fillColor;
                    
                    if (this.isCombinedDoubleKing) {
                        // Make the rectangle smaller but keep the same proportions for 2v2 king tower
                        const rectWidth = this.radius * 2.5;  // Reduced from 3.5 to 2.5
                        const rectHeight = this.radius * 1.6; // Reduced from 2.2 to 1.6 (keeping same ratio)
                        ctx.fillRect(
                            this.x - rectWidth/2, 
                            this.y - rectHeight/2, 
                            rectWidth, 
                            rectHeight
                        );
                        // Add border
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(
                            this.x - rectWidth/2, 
                            this.y - rectHeight/2, 
                            rectWidth, 
                            rectHeight
                        );
                    } else if (this.dyingAnimationTimer > 0) { 
                        ctx.globalAlpha = Math.max(0, this.dyingAnimationTimer / 30); 
                        const shakeX = (Math.random() - 0.5) * 4; 
                        const shakeY = (Math.random() - 0.5) * 4; 
                        ctx.fillRect(
                            this.x - this.radius + shakeX, 
                            this.y - this.radius + shakeY, 
                            this.radius * 2, 
                            this.radius * 2
                        );
                    } else {
                        // Regular tower drawing
                        ctx.fillRect(
                            this.x - this.radius, 
                            this.y - this.radius, 
                            this.radius * 2, 
                            this.radius * 2
                        );
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(
                            this.x - this.radius, 
                            this.y - this.radius, 
                            this.radius * 2, 
                            this.radius * 2
                        );
                    }
                    
                    // Draw the emoji on top
                    const emojiSize = this.isCombinedDoubleKing ? this.radius * 0.8 : this.radius * 1.5; // Reduced from 1.2 to 0.8 for 2v2
                    ctx.font = `${emojiSize}px Arial`; 
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle';
                    
                    if (this.isCombinedDoubleKing) {
                        // Draw two smaller crown emojis further apart
                        const emojiSpacing = this.radius * 0.8; // Increased spacing between emojis
                        ctx.fillText('üëë', this.x - emojiSpacing/2, this.y);
                        ctx.fillText('üëë', this.x + emojiSpacing/2, this.y);
                    } else {
                        const emoji = this.isKing ? 'üëë' : 'üë∏'; 
                        ctx.fillText(emoji, this.x, this.y);
                    } 
                    
                    // Draw activation animation if needed
                    if (this.activationAnimation > 0) { 
                        this.activationAnimation--; 
                        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 * (this.activationAnimation / 30)})`; 
                        ctx.beginPath(); 
                        ctx.arc(this.x, this.y, this.radius + 10, 0, Math.PI * 2); 
                        ctx.fill(); 
                    } 
                    
                    // Draw health bar
                    this.drawHealthBar(this.level);
                    
                    ctx.restore(); 
                }
            }

            class Building extends GameObject {
                constructor(x, y, team, level = 1, cardId) {
                    const s = allCards[cardId].stats[level];
                    super(x, y, 20, team, s.health);
                    this.level = level; // Store level
                    this.maxLifetime = parseFloat(s.lifetime) * 60;
                    this.lifetime = this.maxLifetime;
                    this.dyingAnimationTimer = 0;
                    this.spawnTimer = 0;
                    this.spawnRate = parseFloat(s.spawn_speed) * 60;
                    this.spawnLevel = level;
                    this.cardId = cardId;
                    this.emoji = allCards[cardId].emoji;
                }
                update() { 
                    if (this.health <= 0) return; 
                    this.lifetime--; 
                    
                    // --- BUILDING HEALTH DECAY FIX ---
                    // Calculate health decay per frame and subtract it
                    const decayPerFrame = this.maxHealth / this.maxLifetime;
                    this.health -= decayPerFrame;
                    // --- END FIX ---
                    
                    if (this.lifetime <= 0 || this.health <= 0) { // Check both
                        this.health = 0; 
                        return; 
                    } 
                    
                    this.spawnTimer--; 
                    if (this.spawnTimer <= 0) {
                        let unitToSpawn = null;
                        if (this.cardId === 'hut') unitToSpawn = Goblin;
                        if (this.cardId === 'barbarianHut') unitToSpawn = Barbarian;
                        
                        if (unitToSpawn) {
                            gameObjects.push(new unitToSpawn(this.x + (Math.random()*10-5), this.y + (Math.random()*10-5), this.team, this.spawnLevel));
                        }
                        this.spawnTimer = this.spawnRate; 
                    } 
                }
                draw() { 
                    ctx.save(); 
                    if (this.dyingAnimationTimer > 0) { 
                        ctx.globalAlpha = Math.max(0, this.dyingAnimationTimer / 30); 
                        const shakeX = (Math.random() - 0.5) * 4; 
                        const shakeY = (Math.random() - 0.5) * 4; 
                        ctx.translate(shakeX, shakeY); 
                    } 
                    const color = this.team === 'player' ? '#3b82f6' : '#ef4444'; 
                    ctx.fillStyle = color; 
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.font = `${this.radius * 1.5}px Arial`; 
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle'; 
                    ctx.fillText(this.emoji, this.x, this.y); 
                    this.drawHealthBar(this.level); // Pass level
                    ctx.restore(); 
                }
            }
            class GoblinHut extends Building { constructor(x, y, team, level = 1) { super(x, y, team, level, 'hut'); } }
            class BarbarianHut extends Building { constructor(x, y, team, level = 1) { super(x, y, team, level, 'barbarianHut'); } }


            class Unit extends GameObject {
                constructor(x, y, radius, team, health, speed, attackRange, attackDamage, attackCooldown, emoji, isFlying = false, targetsAir = false, level = 1, aggroRange = 100) {
                    super(x, y, radius, team, health);
                    this.level = level; // Store level
                    this.speed = speed;
                    this.attackRange = attackRange;
                    this.attackDamage = attackDamage;
                    this.attackCooldown = attackCooldown * 60;
                    this.cooldownTimer = 0;
                    this.target = null;
                    this.emoji = emoji;
                    this.isFlying = isFlying;
                    this.targetsAir = targetsAir;
                    this.aggroRange = aggroRange; // NEW
                }
                findTarget(forceFindTower = false) { // Add parameter
                    // --- NEW AGGRO AI (FIX) ---
                    let closestDist = this.aggroRange;
                    let bestTarget = null;
                    
                    // 1. Find closest troop, building, OR TOWER in aggro range
                    for (const obj of gameObjects) {
                        // --- THIS IS THE FIX ---
                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                            // Skip invisible Phantom Knights
                            if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                            // --- END FIX ---
                            if (!this.targetsAir && obj.isFlying) continue; 
                            
                            const dist = getDistance(this, obj);
                            if (dist < closestDist) {
                                closestDist = dist;
                                bestTarget = obj;
                            }
                        }
                    }
                    
                    // 2. If we found a distraction, return it.
                    if (bestTarget) {
                        return bestTarget;
                    }
        
                    // 3. If no troop/building in range, AND we are forced to (e.g., target died)
                    if (forceFindTower) {
                        let closestTowerDist = Infinity;
                        let towerTarget = null;
                        // Find closest Princess Tower in its lane
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {
                                if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {
                                    const dist = getDistance(this, obj);
                                    if (dist < closestTowerDist) { 
                                        closestTowerDist = dist; 
                                        towerTarget = obj; 
                                    }
                                }
                            }
                        }
                        // If no lane tower, find King
                        if (!towerTarget) {
                            for (const obj of gameObjects) {
                                if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {
                                    const dist = getDistance(this, obj);
                                    if (dist < closestTowerDist) { 
                                        closestTowerDist = dist; 
                                        towerTarget = obj; 
                                    }
                                }
                            }
                        }
                        return towerTarget; // Return the tower
                    }
                    
                    // 4. If no distraction and not forced, return null (keep current target)
                    return null;
                    // --- END AI FIX ---
                }
                move() {
                    if (!this.target || this.frozen) return; // NEW: Don't move if frozen
                    const dist = getDistance(this, this.target);
                    if (dist <= this.attackRange) { return; }
                    let targetX = this.target.x;
                    let targetY = this.target.y;
                    if (!this.isFlying) {
                        const needsToCross = (this.team === 'player' && this.y > RIVER_Y && this.target.y < RIVER_Y) || (this.team === 'ai' && this.y < RIVER_Y && this.target.y > RIVER_Y);
                        if (needsToCross) {
                            
                            let bridgeX = (this.x < WIDTH / 2) ? LANE_LEFT_X : LANE_RIGHT_X;
                            // FIX: This was the bug. It was pathing to the target's bridge, not its own.
                            // if(this.target.x < WIDTH / 2) bridgeX = LANE_LEFT_X;
                            // else bridgeX = LANE_RIGHT_X;
                            
                            if ( (this.team === 'player' && this.y > (RIVER_Y + 10)) || (this.team === 'ai' && this.y < (RIVER_Y - 10)) ) {
                                targetX = bridgeX;
                                targetY = BRIDGE_Y;
                            }
                        }
                    }
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;
                }
                attack() { 
                    if (this.target && this.cooldownTimer <= 0) { 
                        if (this.target instanceof PhantomKnight && this.target.isInvisible) {
                            return;
                        }
                        if (this.attackRange <= this.radius + this.target.radius + 5) { // Melee
                            this.target.health -= this.attackDamage; 
                        } else { // Ranged
                            let projectileType = Projectile;
                            let damage = this.attackDamage;
                            let splash = 0;
                            if (this.emoji === 'üê≤') {
                                projectileType = FireballProjectile;
                                splash = allCards['fireDragon'].stats[this.level].splashRadius;
                            }
                            gameObjects.push(new projectileType(this.x, this.y, this.target, this.team, damage, splash)); 
                        } 
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                } 
                update() {
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }
                    // NEW: Don't update if frozen
                    if (this.frozen) return;
                    
                    // --- AGGRO FIX ---
                    // 1. If we have a target and are in attack range, just attack. DO NOT look for new targets.
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack();
                        return; // <-- This is the key. Stop update here.
                    }
                    
                    // 2. We are not in attack range. Check for new distractions.
                    let distraction = this.findTarget(false); // 'false' means only scan aggro range
                    
                    // 3. If a distraction exists...
                    if (distraction) {
                        // ...and we don't have a target OR the distraction is closer than our current target
                        if (!this.target || this.target.health <= 0 || getDistance(this, distraction) < getDistance(this, this.target)) {
                            this.target = distraction;
                        }
                    } else {
                        // 4. No distraction. Check if our long-distance target is dead/gone
                        if (!this.target || this.target.health <= 0) {
                            this.target = this.findTarget(true); // Find a new tower
                        }
                        // 5. We have a valid long-distance target (troop, building, or tower), just keep it.
                    }
                    // --- END AI FIX ---

                    if (this.target && this.target.health > 0) {
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
                draw() { 
                    const color = this.team === 'player' ? '#60a5fa' : '#f87171'; 
                    super.draw(color, this.emoji, this.level);
                    // NEW: Draw purple effect for angered units
                    if (this.isAngered) {
                        ctx.save();
                        ctx.strokeStyle = '#9333ea'; // purple-600
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }

            class Knight extends Unit { constructor(x, y, team, level = 1) { const s = allCards['knight'].stats[level]; super(x, y, 12, team, s.health, 1.2, 25, s.damage, s.hitSpeed, '‚öîÔ∏è', false, false, level, allCards['knight'].aggroRange); } }
            class Archer extends Unit { constructor(x, y, team, level = 1) { const s = allCards['archer'].stats[level]; super(x, y, 10, team, s.health, 1.2, 120, s.damage, s.hitSpeed, 'üèπ', false, true, level, allCards['archer'].aggroRange); } }
            
            class Giant extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['giant'].stats[level];
                    super(x, y, 18, team, s.health, s.speed, 30, s.damage, s.hitSpeed, 'üí™', false, false, level, allCards['giant'].aggroRange);
                    this.targetLocked = false;
                }
                findTarget() {
                    // --- BUILDING-TARGETING AI FIX ---
        
                    // 1. Find the default tower target (closest tower in lane, or king)
                    let closestTowerDist = Infinity;
                    let towerTarget = null;
        
                    // Find closest Princess Tower in its lane
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {
                            if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {
                                const dist = getDistance(this, obj);
                                if (dist < closestTowerDist) { 
                                    closestTowerDist = dist; 
                                    towerTarget = obj; 
                                }
                            }
                        }
                    }
                    // If no lane tower, find King
                    if (!towerTarget) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {
                                const dist = getDistance(this, obj);
                                if (dist < closestTowerDist) { 
                                    closestTowerDist = dist; 
                                    towerTarget = obj; 
                                }
                            }
                        }
                    }
        
                    // 2. Find the closest building (as a potential distraction)
                    let closestBuildingDist = Infinity;
                    let buildingTarget = null;
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Building)) {
                            const dist = getDistance(this, obj);
                            if (dist < closestBuildingDist) { 
                                closestBuildingDist = dist; 
                                buildingTarget = obj; 
                            }
                        }
                    }
        
                    // 3. Decide: Is the building a valid, closer distraction?
                    // Use Infinity if no tower target exists
                    const towerDist = towerTarget ? closestTowerDist : Infinity;
                    
                    if (buildingTarget && closestBuildingDist <= this.aggroRange && closestBuildingDist < towerDist) {
                        // Attack the building
                        this.target = buildingTarget;
                    } else {
                        // No valid distraction, attack the tower
                        this.target = towerTarget;
                    }
                    
                    this.targetLocked = (this.target != null);
                    // --- END AI FIX ---
                }
                // FIX: Add custom update to ONLY use building-find logic
                update() {
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }
                    
                    // --- TARGET LOCK-ON FIX (FOR REAL) ---
                    // 1. If we have a target and are in attack range, just attack.
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack();
                        return; // Lock in combat
                    }
    
                    // 2. We do not have a valid target OR our target is a tower (so we can be distracted)
                    if (!this.target || this.target.health <= 0 || (this.target instanceof Tower)) {
                         this.findTarget(); // This will find a tower OR a closer building
                    }
                    // 3. If our target is a building, we are "locked on" and will NOT re-scan.
                    // --- END AI FIX ---
    
                    if (this.target && this.target.health > 0) {
                        // (This check is redundant, but safe)
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
            }
            class Goblin extends Unit { constructor(x, y, team, level = 1) { const s = allCards['goblins'].stats[level]; super(x, y, 8, team, s.health, 1.2, 20, s.damage, s.hitSpeed, 'üë∫', false, false, level, allCards['goblins'].aggroRange); } } // Speed 1.5 -> 1.2
            class Skeleton extends Unit { constructor(x, y, team, level = 1) { const s = allCards['skeletons'].stats[level]; super(x, y, 7, team, s.health, 1.4, 20, s.damage, s.hitSpeed, 'üíÄ', false, false, level, allCards['skeletons'].aggroRange); } } // Speed 1.6 -> 1.4
            class TinyBot extends Unit { constructor(x, y, team, level = 1) { const s = allCards['tinyBot'].stats[level]; super(x, y, 10, team, s.health, 1.0, 25, s.damage, s.hitSpeed, 'ü§ñ', false, false, level, allCards['tinyBot'].aggroRange); } } // Speed 1.2 -> 1.0
            class Goblins { constructor(x, y, team, level = 1) { const s = allCards['goblins'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Goblin(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            class Skeletons { constructor(x, y, team, level = 1) { const s = allCards['skeletons'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Skeleton(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            
            // --- NEW CARD CLASSES ---
            class SpearGoblin extends Unit { constructor(x, y, team, level = 1) { const s = allCards['goblinGang'].stats[level]; super(x, y, 8, team, s.spear_health, 1.2, 100, s.spear_damage, s.spear_hitSpeed, 'üéØ', false, true, level, allCards['goblinGang'].aggroRange); } } // Speed 1.5 -> 1.2
            class GoblinGang { constructor(x, y, team, level = 1) { const s = allCards['goblinGang'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Goblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } for (let i = 0; i < s.spear_count; i++) { gameObjects.push(new SpearGoblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } } }
            class SkeletonArmy { constructor(x, y, team, level = 1) { const s = allCards['skeletonArmy'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Skeleton(x + Math.random()*30-15, y + Math.random()*30-15, team, level)); } } }
            class Barbarian extends Unit { constructor(x, y, team, level = 1) { const s = allCards['barbarians'].stats[level]; super(x, y, 11, team, s.health, 0.9, 25, s.damage, s.hitSpeed, 'üßî', false, false, level, allCards['barbarians'].aggroRange); } } // Speed 1.1 -> 0.9
            class Barbarians { constructor(x, y, team, level = 1) { const s = allCards['barbarians'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Barbarian(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            class FireDragon extends Unit { constructor(x, y, team, level = 1) { const s = allCards['fireDragon'].stats[level]; super(x, y, 14, team, s.health, 1.0, 110, s.damage, s.hitSpeed, 'üê≤', true, true, level, allCards['fireDragon'].aggroRange); } } // Speed 1.2 -> 1.0
            class BattleRam extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['battleRam'].stats[level];
                    super(x, y, 15, team, s.health, 1.0, 25, s.damage, 1, 'üå≤', false, false, level, allCards['battleRam'].aggroRange); // Speed 1.2 -> 1.0
                    this.barbLevel = s.barbLevel;
                    this.chargeTimer = 3 * 60;
                    this.isCharging = false;
                    this.didHit = false; // Flag to prevent double spawns
                    this.targetLocked = false;
                }
                
                findTarget() {
                    // --- BUILDING-TARGETING AI FIX ---
        
                    // 1. Find the default tower target (closest tower in lane, or king)
                    let closestTowerDist = Infinity;
                    let towerTarget = null;
        
                    // Find closest Princess Tower in its lane
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {
                            if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {
                                const dist = getDistance(this, obj);
                                if (dist < closestTowerDist) { 
                                    closestTowerDist = dist; 
                                    towerTarget = obj; 
                                }
                            }
                        }
                    }
                    // If no lane tower, find King
                    if (!towerTarget) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {
                                const dist = getDistance(this, obj);
                                if (dist < closestTowerDist) { 
                                    closestTowerDist = dist; 
                                    towerTarget = obj; 
                                }
                            }
                        }
                    }
        
                    // 2. Find the closest building (as a potential distraction)
                    let closestBuildingDist = Infinity;
                    let buildingTarget = null;
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Building)) {
                            const dist = getDistance(this, obj);
                            if (dist < closestBuildingDist) { 
                                closestBuildingDist = dist; 
                                buildingTarget = obj; 
                            }
                        }
                    }
        
                    // 3. Decide: Is the building a valid, closer distraction?
                    // Use Infinity if no tower target exists
                    const towerDist = towerTarget ? closestTowerDist : Infinity;
                    
                    if (buildingTarget && closestBuildingDist <= this.aggroRange && closestBuildingDist < towerDist) {
                        // Attack the building
                        this.target = buildingTarget;
                    } else {
                        // No valid distraction, attack the tower
                        this.target = towerTarget;
                    }
                    
                    this.targetLocked = (this.target != null);
                    // --- END AI FIX ---
                }
                
                spawnBarbs() {
                    if (this.didHit) return; // Don't spawn twice
                    this.didHit = true;
                    gameObjects.push(new Barbarian(this.x + 5, this.y, this.team, this.barbLevel));
                    gameObjects.push(new Barbarian(this.x - 5, this.y, this.team, this.barbLevel));
                    this.health = 0; // Ram is destroyed
                }

                update() {
                    if (this.health <= 0 && !this.didHit) {
                        this.spawnBarbs(); // Spawn if killed by damage
                        return;
                    }
                    if (this.didHit) return; // Already spawned, do nothing
                    
                    if (this.chargeTimer > 0) { this.chargeTimer--; if(this.chargeTimer === 0) this.isCharging = true; }
                    if (this.isCharging) this.speed = 2.0; else this.speed = 1.0;
                    
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }
    
                    // --- TARGET LOCK-ON FIX (FOR REAL) ---
                    // 1. If we have a target and are in attack range, just attack.
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack(); // This will call spawnBarbs()
                        return; // Lock in combat
                    }
    
                    // 2. We do not have a valid target OR our target is a tower (so we can be distracted)
                    if (!this.target || this.target.health <= 0 || (this.target instanceof Tower)) {
                         this.findTarget(); // This will find a tower OR a closer building
                    }
                    // 3. If our target is a building, we are "locked on" and will NOT re-scan.
                    // --- END AI FIX ---
                    
                    if (this.target && this.target.health > 0) {
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
                attack() { // Ram only attacks when it hits
                    if (this.target && this.cooldownTimer <= 0) {
                        if (this.target instanceof PhantomKnight && this.target.isInvisible) {
                            return;
                        }
                        this.target.health -= this.attackDamage;
                        this.spawnBarbs(); // Spawn on hit
                    } 
                }
            }
            
            class AxeSwinger extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['axeSwinger'].stats[level];
                    super(x, y, 12, team, s.health, 1.0, 0, s.damage, s.hitSpeed, 'ü™ì', false, false, level, allCards['axeSwinger'].aggroRange); // Speed 1.2 -> 1.0
                    this.splashRadius = s.splashRadius;
                    this.attackAnimationTimer = 0; // NEW
                }
                attack() { 
                    if (this.cooldownTimer <= 0) { 
                        this.attackAnimationTimer = 20; // NEW: Start animation
                        for (const obj of gameObjects) {
                            // Hit all non-flying enemies in range
                            if (obj.team !== this.team && !obj.isFlying && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                // Skip invisible Phantom Knights
                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                if (getDistance(this, obj) < this.splashRadius) {
                                    obj.health -= this.attackDamage;
                                }
                            }
                        }
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                }
                // FIX: Custom update to allow attacking at splash range
                update() {
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }
                    if (this.attackAnimationTimer > 0) { this.attackAnimationTimer--; } // NEW

                    // --- AGGRO FIX (Copy from Unit) ---
                    // 1. If we have a target and are in attack range, just attack. DO NOT look for new targets.
                    let inSplashRange = false;
                    if (this.target && this.target.health > 0) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && !obj.isFlying && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                // Skip invisible Phantom Knights
                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                if (getDistance(this, obj) < this.splashRadius) {
                                    inSplashRange = true;
                                    break;
                                }
                            }
                        }
                    }

                    if (inSplashRange) {
                        this.attack();
                        return; // <-- This is the key. Stop update here.
                    }
                    
                    // 2. We are not in attack range. Check for new distractions.
                    let distraction = this.findTarget(false); // 'false' means only scan aggro range
                    
                    // 3. If a distraction exists...
                    if (distraction) {
                        // ...and we don't have a target OR the distraction is closer than our current target
                        if (!this.target || this.target.health <= 0 || getDistance(this, distraction) < getDistance(this, this.target)) {
                            this.target = distraction;
                        }
                    } else {
                        // 4. No distraction. Check if our long-distance target is dead/gone
                        if (!this.target || this.target.health <= 0) {
                            this.target = this.findTarget(true); // Find a new tower
                        }
                        // 5. We have a valid long-distance target (troop, building, or tower), just keep it.
                    }
                    // --- END AI FIX ---

                    if (this.target && this.target.health > 0) {
                        if (inSplashRange) { // Re-check
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
                // NEW: Draw attack animation
                draw() {
                    super.draw(); // Draw the unit first
                    if (this.attackAnimationTimer > 0) {
                        const progress = this.attackAnimationTimer / 20;
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.splashRadius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(220, 38, 38, ${0.5 * (1 - progress)})`; // Fade out
                        ctx.fill();
                        ctx.restore(); // <-- ADDED THIS MISSING LINE
                    }
                }
            } // <-- ADDED THIS MISSING CLOSING BRACE

            // --- FARMER (NEW) ---
            class Farmer extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['farmer'].stats[level];
                    super(x, y, 12, team, s.health, 1.0, 25, s.damage, s.hitSpeed, 'üë®‚Äçüåæ', false, false, level, allCards['farmer'].aggroRange); // Speed 1.2 -> 1.0
                    this.attackWidth = s.attackWidth;
                    this.attackHeight = s.attackHeight;
                    this.attackAnimationTimer = 0;
                    this.attackAngle = 0;
                }
                attack() { 
                    if (this.cooldownTimer <= 0) { 
                        this.attackAnimationTimer = 20; // Start animation
                        this.attackAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);

                        // Check for hits in a rectangle
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && !obj.isFlying && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                // Skip invisible Phantom Knights
                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                if (isInside(obj, this.x, this.y, this.attackWidth, this.attackHeight, this.attackAngle)) {
                                    obj.health -= this.attackDamage;
                                }
                            }
                        }
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                }
                update() {
                    if (this.attackAnimationTimer > 0) { this.attackAnimationTimer--; }
                    
                    // Standard unit update logic (copied from Unit)
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }
                    
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack();
                        return; 
                    }
                    let distraction = this.findTarget(false);
                    if (distraction) {
                        if (!this.target || this.target.health <= 0 || getDistance(this, distraction) < getDistance(this, this.target)) {
                            this.target = distraction;
                        }
                    } else {
                        if (!this.target || this.target.health <= 0) {
                            this.target = this.findTarget(true); 
                        }
                    }
                    if (this.target && this.target.health > 0) {
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
                draw() {
                    super.draw(); // Draw the unit
                    if (this.attackAnimationTimer > 0) {
                        const progress = this.attackAnimationTimer / 20;
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.attackAngle);
                        ctx.fillStyle = `rgba(220, 38, 38, ${0.5 * (1 - progress)})`;
                        // Draw rectangle in front of the unit
                        ctx.fillRect(this.radius, -this.attackWidth / 2, this.attackHeight, this.attackWidth);
                        ctx.restore();
                    }
                }
            }

            // --- PIG (NEW) ---
            class Pig extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['pigs'].stats[level];
                    super(x, y, 10, team, s.health, 1.4, 25, s.damage, s.hitSpeed, 'üê∑', false, false, level, allCards['pigs'].aggroRange); // Speed 1.8 -> 1.4
                    this.targetLocked = false;
                }
                // Use building-only targeting
                findTarget() {
                    // --- BUILDING-TARGETING AI FIX ---
        
                    // 1. Find the default tower target (closest tower in lane, or king)
                    let closestTowerDist = Infinity;
                    let towerTarget = null;
        
                    // Find closest Princess Tower in its lane
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {
                            if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {
                                const dist = getDistance(this, obj);
                                if (dist < closestTowerDist) { 
                                    closestTowerDist = dist; 
                                    towerTarget = obj; 
                                }
                            }
                        }
                    }
                    // If no lane tower, find King
                    if (!towerTarget) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {
                                const dist = getDistance(this, obj);
                                if (dist < closestTowerDist) { 
                                    closestTowerDist = dist; 
                                    towerTarget = obj; 
                                }
                            }
                        }
                    }
        
                    // 2. Find the closest building (as a potential distraction)
                    let closestBuildingDist = Infinity;
                    let buildingTarget = null;
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Building)) {
                            const dist = getDistance(this, obj);
                            if (dist < closestBuildingDist) { 
                                closestBuildingDist = dist; 
                                buildingTarget = obj; 
                            }
                        }
                    }
        
                    // 3. Decide: Is the building a valid, closer distraction?
                    // Use Infinity if no tower target exists
                    const towerDist = towerTarget ? closestTowerDist : Infinity;

                    if (buildingTarget && closestBuildingDist <= this.aggroRange && closestBuildingDist < towerDist) {
                        // Attack the building
                        this.target = buildingTarget;
                    } else {
                        // No valid distraction, attack the tower
                        this.target = towerTarget;
                    }
                    
                    this.targetLocked = (this.target != null);
                    // --- END AI FIX ---
                }
                update() { // Custom update to use building-only AI
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }
                    
                    // --- TARGET LOCK-ON FIX (FOR REAL) ---
                    // 1. If we have a target and are in attack range, just attack.
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack();
                        return; // Lock in combat
                    }
    
                    // 2. We do not have a valid target OR our target is a tower (so we can be distracted)
                    if (!this.target || this.target.health <= 0 || (this.target instanceof Tower)) {
                         this.findTarget(); // This will find a tower OR a closer building
                    }
                    // 3. If our target is a building, we are "locked on" and will NOT re-scan.
                    // --- END AI FIX ---
    
                    if (this.target && this.target.health > 0) {
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
            }
            class Pigs { constructor(x, y, team, level = 1) { const s = allCards['pigs'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Pig(x + Math.random()*20-10, y + Math.random()*20-10, team, level)); } } }
            
            // --- FLYING SKELETON (NEW) ---
            class FlyingSkeleton extends Unit { 
                constructor(x, y, team, level = 1) { 
                    const s = allCards['flyingSkeletons'].stats[level]; 
                    super(x, y, 9, team, s.health, 1.4, 25, s.damage, s.hitSpeed, 'üíÄü¶á', true, true, level, allCards['flyingSkeletons'].aggroRange); 
                } 
                // Removed custom draw() function to use the emoji
            }
            class FlyingSkeletons { constructor(x, y, team, level = 1) { const s = allCards['flyingSkeletons'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new FlyingSkeleton(x + Math.random()*20-10, y + Math.random()*20-10, team, level)); } } }
            
            // --- MEGA FLYING SKELETON (NEW) ---
            class MegaFlyingSkeleton extends Unit { 
                constructor(x, y, team, level = 1) { 
                    const s = allCards['megaFlyingSkeleton'].stats[level]; 
                    super(x, y, 14, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'üíÄü¶á', true, true, level, allCards['megaFlyingSkeleton'].aggroRange); 
                } 
                // Removed custom draw() function to use the emoji
            }
            
            // --- FLYING SKELETON GROUP (NEW) ---
            class FlyingSkeletonGroup { constructor(x, y, team, level = 1) { const s = allCards['flyingSkeletonGroup'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new FlyingSkeleton(x + Math.random()*30-15, y + Math.random()*30-15, team, level)); } } }

            // --- WARLOCK (NEW) ---
            class Warlock extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['warlock'].stats[level];
                    super(x, y, 12, team, s.health, 1.0, 110, s.damage, s.hitSpeed, 'üîÆ', false, true, level, allCards['warlock'].aggroRange);
                    this.splashRadius = s.splashRadius;
                }
                attack() {
                    if (this.target && this.cooldownTimer <= 0) {
                        // Create splash projectile
                        gameObjects.push(new FireballProjectile(this.x, this.y, this.target, this.team, this.attackDamage, this.splashRadius));
                        this.cooldownTimer = this.attackCooldown;
                    }
                }
            }

            // --- MAGE (ARENA 7) ---
            class Mage extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['mage'].stats[level];
                    super(x, y, 12, team, s.health, 1.0, 110, s.damage, s.hitSpeed, 'üßô‚Äç‚ôÄÔ∏è', false, true, level, allCards['mage'].aggroRange);
                    this.splashRadius = s.splashRadius;
                    this.skeletonSpawnTimer = 0; // Instantly spawn on place
                    this.hasSpawnedInitial = false;
                }
                attack() {
                    if (this.target && this.cooldownTimer <= 0) {
                        // Create splash projectile
                        gameObjects.push(new FireballProjectile(this.x, this.y, this.target, this.team, this.attackDamage, this.splashRadius));
                        this.cooldownTimer = this.attackCooldown;
                    }
                }
                update() {
                    super.update();
                    if (this.health <= 0) return;
                    if (!this.hasSpawnedInitial) {
                        // Instantly spawn 4 skeletons on placement
                        const offset = 18;
                        const positions = [
                            { dx: -offset, dy: -offset }, // top left
                            { dx: -offset, dy: offset },  // bottom left
                            { dx: offset, dy: -offset },  // top right
                            { dx: offset, dy: offset }    // bottom right
                        ];
                        for (const pos of positions) {
                            gameObjects.push(new Skeleton(this.x + pos.dx, this.y + pos.dy, this.team, this.level));
                        }
                        this.skeletonSpawnTimer = 5 * 60;
                        this.hasSpawnedInitial = true;
                    } else {
                        this.skeletonSpawnTimer--;
                        if (this.skeletonSpawnTimer <= 0) {
                            const offset = 18;
                            const positions = [
                                { dx: -offset, dy: -offset }, // top left
                                { dx: -offset, dy: offset },  // bottom left
                                { dx: offset, dy: -offset },  // top right
                                { dx: offset, dy: offset }    // bottom right
                            ];
                            for (const pos of positions) {
                                gameObjects.push(new Skeleton(this.x + pos.dx, this.y + pos.dy, this.team, this.level));
                            }
                            this.skeletonSpawnTimer = 5 * 60;
                        }
                    }
                }

            }

            // --- PHANTOM KNIGHT (ARENA 7) ---
            class PhantomKnight extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['phantomKnight'].stats[level];
                    super(x, y, 12, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'üëª‚öîÔ∏è', false, false, level, allCards['phantomKnight'].aggroRange);
                    this.isInvisible = true;
                    this.lastAttackTime = 0;
                    this.invisibilityDelay = 180;
                }
                attack() {
                    if (this.target && this.cooldownTimer <= 0) {
                        this.isInvisible = false;
                        this.lastAttackTime = 0;
                        if (this.attackRange <= this.radius + this.target.radius + 5) {
                            this.target.health -= this.attackDamage;
                        } else {
                            let projectileType = Projectile;
                            let damage = this.attackDamage;
                            let splash = 0;
                            if (this.emoji === 'üê≤') {
                                projectileType = FireballProjectile;
                                splash = allCards['fireDragon'].stats[this.level].splashRadius;
                            }
                            gameObjects.push(new projectileType(this.x, this.y, this.target, this.team, damage, splash));
                        }
                        this.cooldownTimer = this.attackCooldown;
                    }
                }
                update() {
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }
                    
                    if (this.frozen) return;
                    
                    if (!this.isInvisible) {
                        this.lastAttackTime++;
                        if (this.lastAttackTime >= this.invisibilityDelay) {
                            this.isInvisible = true;
                            this.lastAttackTime = 0;
                        }
                    }
                    
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack();
                        return;
                    }
                    
                    let distraction = this.findTarget(false);
                    
                    if (distraction) {
                        if (!this.target || this.target.health <= 0 || getDistance(this, distraction) < getDistance(this, this.target)) {
                            this.target = distraction;
                        }
                    } else {
                        if (!this.target || this.target.health <= 0) {
                            this.target = this.findTarget(true);
                        }
                    }

                    if (this.target && this.target.health > 0) {
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
                draw() {
                    if (this.isInvisible) {
                        ctx.save();
                        ctx.globalAlpha = 0.2;
                        const color = this.team === 'player' ? '#60a5fa' : '#f87171';
                        super.draw(color, this.emoji, this.level);
                        ctx.globalAlpha = 1;
                        ctx.restore();
                    } else {
                        const color = this.team === 'player' ? '#60a5fa' : '#f87171';
                        super.draw(color, this.emoji, this.level);
                    }
                }
            }

            // --- SPIRIT LANTERN (ARENA 7) ---
            class SpiritLantern extends Building {
                constructor(x, y, team, level = 1) {
                    super(x, y, team, level, 'spiritLantern');
                    this.spiritTypes = ['zapSpirit', 'coldSpirit', 'lifeSpirit'];
                    this.spawnTimer = this.spawnRate;
                }
                update() {
                    if (this.health <= 0) return;
                    this.lifetime--;
                    if (this.lifetime <= 0) { this.health = 0; return; }
                    // Health decay
                    const decayPerFrame = this.maxHealth / this.maxLifetime;
                    this.health -= decayPerFrame;
                    this.spawnTimer--;
                    if (this.spawnTimer <= 0) {
                        // Randomly pick a spirit type
                        const spiritType = this.spiritTypes[Math.floor(Math.random() * this.spiritTypes.length)];
                        gameObjects.push(new allCards[spiritType].unitClass(this.x + (Math.random()-0.5)*10, this.y + (Math.random()-0.5)*10, this.team, this.level));
                        this.spawnTimer = this.spawnRate;
                    }
                }
            }

// --- SPIRIT CLASSES (NEW, FROM SCRATCH) ---
class ColdSpirit extends Unit {
    constructor(x, y, team, level = 1) {
        const s = allCards['coldSpirit'].stats[level];
        super(x, y, 9, team, s.health, 1.5, 20, 10, 1, '‚ùÑÔ∏è', false, false, level, allCards['coldSpirit'].aggroRange);
        this.jumpRadius = s.jumpRadius;
        this.effectRadius = s.effectRadius;
        this.freezeDuration = s.freezeDuration;
        this.hasJumped = false;
    }
    update() {
        if (this.health <= 0 || this.hasJumped) return;
        // Use standard land troop AI to find target in aggro range
        let target = null;
        // Find closest enemy unit (including flying), building, or tower in aggro range
        let closestDist = this.jumpRadius;
        for (const obj of gameObjects) {
            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                // Skip invisible Phantom Knights
                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                const dist = getDistance(this, obj);
                if (dist < closestDist) {
                    closestDist = dist;
                    target = obj;
                }
            }
        }
        if (target) {
            // Jump onto target and trigger freeze
            this.x = target.x;
            this.y = target.y;
            gameObjects.push(new FreezeEffect(this.x, this.y, this.team, this.effectRadius, this.freezeDuration * 60));
            this.hasJumped = true;
            this.health = 0;
        } else {
            // Move like a normal troop
            if (!this.target || this.target.health <= 0) {
                this.target = this.findTarget(true);
            }
            if (this.target && this.target.health > 0) {
                this.move();
            }
        }
    }
}

        class BombSpirit extends Unit {
            constructor(x, y, team, level = 1) {
                const s = allCards['bombSpirit'].stats[level];
                super(x, y, 9, team, s.health, 1.5, 20, 10, 1, 'üí£', false, false, level, allCards['bombSpirit'].aggroRange);
                this.jumpRadius = s.jumpRadius;
                this.effectRadius = s.effectRadius;
                this.damage = s.damage;
                this.hasJumped = false;
            }
            update() {
                if (this.health <= 0 || this.hasJumped) return;
                let target = null;
                let closestDist = this.jumpRadius;
                for (const obj of gameObjects) {
                    if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                        // Skip invisible Phantom Knights
                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                        const dist = getDistance(this, obj);
                        if (dist < closestDist) {
                            closestDist = dist;
                            target = obj;
                        }
                    }
                }
                if (target) {
                    // Jump onto target and trigger explosion
                    this.x = target.x;
                    this.y = target.y;
                    // Damage all enemy things in effect radius
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                            // Don't skip invisible Phantom Knights here - spells/explosions can hit them
                            if (getDistance(this, obj) < this.effectRadius) {
                                obj.health -= this.damage;
                            }
                        }
                    }
                    gameObjects.push(new ExplosionEffect(this.x, this.y, this.effectRadius));
                    this.hasJumped = true;
                    this.health = 0;
                } else {
                    if (!this.target || this.target.health <= 0) {
                        this.target = this.findTarget(true);
                    }
                    if (this.target && this.target.health > 0) {
                        this.move();
                    }
                }
            }
        }

        class ZapSpirit extends Unit {
            constructor(x, y, team, level = 1) {
                const s = allCards['zapSpirit'].stats[level];
                super(x, y, 9, team, s.health, 1.5, 20, 10, 1, '‚ö°', false, false, level, allCards['zapSpirit'].aggroRange);
                this.jumpRadius = s.jumpRadius;
                this.effectRadius = s.effectRadius;
                this.damage = s.damage;
                this.hasJumped = false;
                this.zapChain = null; // For drawing
            }
            update() {
                if (this.health <= 0 || this.hasJumped) return;
                let target = null;
                let closestDist = this.jumpRadius;
                for (const obj of gameObjects) {
                    if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                        // Skip invisible Phantom Knights
                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                        const dist = getDistance(this, obj);
                        if (dist < closestDist) {
                            closestDist = dist;
                            target = obj;
                        }
                    }
                }
                if (target) {
                    // Jump onto target and trigger zap chain
                    this.x = target.x;
                    this.y = target.y;
                    // Chain to up to 10 enemy things in effect radius
                    let chain = [target];
                    let visited = new Set([target]);
                    let current = target;
                    for (let i = 1; i < 10; i++) {
                        // Find next closest enemy not already zapped
                        let next = null;
                        let minDist = Infinity;
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower) && !visited.has(obj) && getDistance(current, obj) < this.effectRadius) {
                                // Skip invisible Phantom Knights
                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                let d = getDistance(current, obj);
                                if (d < minDist) {
                                    minDist = d;
                                    next = obj;
                                }
                            }
                        }
                        if (next) {
                            chain.push(next);
                            visited.add(next);
                            current = next;
                        } else {
                            break;
                        }
                    }
                    // Deal damage to all in chain
                    for (const obj of chain) {
                        obj.health -= this.damage;
                        // Special: If obj is a king tower, activate it
                        if (obj instanceof Tower && obj.isKing && !obj.isActive) {
                            obj.isActive = true;
                            obj.activationAnimation = 30;
                        }
                    }
                    this.zapChain = chain;
                    this.hasJumped = true;
                    this.health = 0;
                } else {
                    if (!this.target || this.target.health <= 0) {
                        this.target = this.findTarget(true);
                    }
                    if (this.target && this.target.health > 0) {
                        this.move();
                    }
                }
            }
            draw() {
                super.draw();
                // Draw zap chain after death (handled in game loop for all ZapSpirits)
            }
        }

        class LifeSpirit extends Unit {
            constructor(x, y, team, level = 1) {
                const s = allCards['lifeSpirit'].stats[level];
                super(x, y, 9, team, s.health, 1.5, 20, 10, 1, 'üíö', false, false, level, allCards['lifeSpirit'].aggroRange);
                this.jumpRadius = s.jumpRadius;
                this.effectRadius = s.effectRadius;
                this.healDuration = s.healDuration;
                this.hasJumped = false;
            }
            update() {
                if (this.health <= 0 || this.hasJumped) return;
                let target = null;
                let closestDist = this.jumpRadius;
                for (const obj of gameObjects) {
                    if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                        // Skip invisible Phantom Knights
                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                        const dist = getDistance(this, obj);
                        if (dist < closestDist) {
                            closestDist = dist;
                            target = obj;
                        }
                    }
                }
                if (target) {
                    // Jump onto target and trigger heal (heal only allies)
                    this.x = target.x;
                    this.y = target.y;
                    gameObjects.push(new HealEffect(this.x, this.y, this.team, this.effectRadius, this.healDuration * 60));
                    this.hasJumped = true;
                    this.health = 0;
                } else {
                    if (!this.target || this.target.health <= 0) {
                        this.target = this.findTarget(true);
                    }
                    if (this.target && this.target.health > 0) {
                        this.move();
                    }
                }
            }
        }


            // --- SPEAR GOBLINS (NEW) ---
            class SpearGoblins { constructor(x, y, team, level = 1) { const s = allCards['spearGoblins'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new SpearGoblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } } }

            // --- ARENA 8 CARD CLASSES (NEW) ---
            class ChaosElemental extends Unit { 
                constructor(x, y, team, level = 1) { 
                    const s = allCards['chaosElemental'].stats[level]; 
                    super(x, y, 12, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'üëπ', false, false, level, allCards['chaosElemental'].aggroRange); 
                } 
            }
            class ShadowClone extends Unit { 
                constructor(x, y, team, level = 1) { 
                    const s = allCards['shadowClone'].stats[level]; 
                    super(x, y, 10, team, s.health, 1.2, 120, s.damage, s.hitSpeed, 'üë§', false, true, level, allCards['shadowClone'].aggroRange); 
                } 
            }
class StoneGiant extends Unit {
    constructor(x, y, team, level = 1) {
        const s = allCards['stoneGiant'].stats[level];
        super(
            x,
            y,
            18,
            team,
            s.health,
            s.speed * 0.5,
            30,
            s.damage,
            s.hitSpeed,
            'üóø',
            false,
            false,
            level,
            allCards['stoneGiant'].aggroRange
        );
        this.targetLocked = false;
        this.level = level;
        this.didSpawnMinis = false; // prevent double‚Äëspawn
    }

    spawnMinis() {
        if (this.didSpawnMinis) return;
        this.didSpawnMinis = true;

        try {
            const card = allCards['miniStoneGiant'];
            if (card && card.stats) {
                const stats =
                    card.stats[this.level] || card.stats[1];

                const leftMini = new MiniStoneGiant(
                    this.x - 15,
                    this.y,
                    this.team,
                    this.level
                );
                const rightMini = new MiniStoneGiant(
                    this.x + 15,
                    this.y,
                    this.team,
                    this.level
                );

                gameObjects.push(leftMini, rightMini);
                console.log(
                    'StoneGiant spawned minis:',
                    leftMini,
                    rightMini
                );
            }
        } catch (e) {
            console.error('Error spawning mini stone giants:', e);
        }
    }

    findTarget() {
        let closestTowerDist = Infinity;
        let towerTarget = null;
        for (const obj of gameObjects) {
            if (
                obj.team !== this.team &&
                obj instanceof Tower &&
                !obj.isKing
            ) {
                if (
                    (this.x < WIDTH / 2 && obj.x < WIDTH / 2) ||
                    (this.x > WIDTH / 2 && obj.x > WIDTH / 2)
                ) {
                    const dist = getDistance(this, obj);
                    if (dist < closestTowerDist) {
                        closestTowerDist = dist;
                        towerTarget = obj;
                    }
                }
            }
        }
        if (!towerTarget) {
            for (const obj of gameObjects) {
                if (
                    obj.team !== this.team &&
                    obj instanceof Tower &&
                    obj.isKing
                ) {
                    const dist = getDistance(this, obj);
                    if (dist < closestTowerDist) {
                        closestTowerDist = dist;
                        towerTarget = obj;
                    }
                }
            }
        }
        this.target = towerTarget;
        this.targetLocked = this.target != null;
    }

    update() {
        // IMPORTANT: no spawning here, only handled in cleanup
        if (this.health <= 0) return;

        if (this.cooldownTimer > 0) {
            this.cooldownTimer--;
        }
        if (
            this.target &&
            this.target.health > 0 &&
            getDistance(this, this.target) <= this.attackRange
        ) {
            this.attack();
            return;
        }
        if (
            !this.target ||
            this.target.health <= 0 ||
            this.target instanceof Tower
        ) {
            this.findTarget();
        }
        if (this.target && this.target.health > 0) {
            if (getDistance(this, this.target) <= this.attackRange) {
                this.attack();
            } else {
                this.move();
            }
        }
    }
}

 class MiniStoneGiant extends Unit {
    constructor(x, y, team, level = 1) {
        const card = allCards['miniStoneGiant'];
        const baseStats =
            card && card.stats
                ? card.stats[level] || card.stats[1]
                : null;
        const s =
            baseStats || {
                health: 200,
                damage: 20,
                hitSpeed: 1.3,
                speed: 0.7
            };
        const emoji = card && card.emoji ? card.emoji : 'ü™®';
        const aggro =
            card && card.aggroRange ? card.aggroRange : 100;

        super(
            x,
            y,
            15,
            team,
            s.health,
            s.speed,
            25,
            s.damage,
            s.hitSpeed,
            emoji,
            false,
            false,
            level,
            aggro
        );
        this.level = level;
    }

    findTarget() {
        let closestTowerDist = Infinity;
        let towerTarget = null;
        for (const obj of gameObjects) {
            if (
                obj.team !== this.team &&
                obj instanceof Tower &&
                !obj.isKing
            ) {
                if (
                    (this.x < WIDTH / 2 && obj.x < WIDTH / 2) ||
                    (this.x > WIDTH / 2 && obj.x > WIDTH / 2)
                ) {
                    const dist = getDistance(this, obj);
                    if (dist < closestTowerDist) {
                        closestTowerDist = dist;
                        towerTarget = obj;
                    }
                }
            }
        }
        if (!towerTarget) {
            for (const obj of gameObjects) {
                if (
                    obj.team !== this.team &&
                    obj instanceof Tower &&
                    obj.isKing
                ) {
                    const dist = getDistance(this, obj);
                    if (dist < closestTowerDist) {
                        closestTowerDist = dist;
                        towerTarget = obj;
                    }
                }
            }
        }
        this.target = towerTarget;
    }

    // let Unit.update / Unit.draw handle behavior
}

            // --- EFFECT CLASSES (NEW) ---
            class FreezeEffect extends GameObject {
                constructor(x, y, team, radius, duration) {
                    super(x, y, radius, team, 1);
                    this.duration = duration;
                    this.lifetime = duration;
                    this.frozenObjects = new Map(); // Store original values
                }
                update() {
                    this.lifetime--;
                    if (this.lifetime <= 0) {
                        // Restore frozen objects
                        this.frozenObjects.forEach((originalSpeed, obj) => {
                            if (obj && obj.frozen) {
                                obj.speed = originalSpeed;
                                obj.frozen = false;
                                if (obj.frozenCooldown !== undefined) {
                                    obj.cooldownTimer = obj.frozenCooldown;
                                }
                            }
                        });
                        this.health = 0;
                        return;
                    }
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                            if (getDistance(this, obj) < this.radius) {
                                if (!obj.frozen) {
                                    obj.frozen = true;
                                    this.frozenObjects.set(obj, obj.speed);
                                    obj.speed = 0;
                                    if (obj.cooldownTimer !== undefined) {
                                        obj.frozenCooldown = obj.cooldownTimer;
                                        obj.cooldownTimer = this.lifetime;
                                    }
                                }
                            } else if (obj.frozen && this.frozenObjects.has(obj)) {
                                // Left the area, restore
                                obj.speed = this.frozenObjects.get(obj);
                                obj.frozen = false;
                                if (obj.frozenCooldown !== undefined) {
                                    obj.cooldownTimer = obj.frozenCooldown;
                                }
                                this.frozenObjects.delete(obj);
                            }
                        }
                    }
                }
                draw() {
                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.3;
                    ctx.fillStyle = `rgba(147, 197, 253, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            class HealEffect extends GameObject {
                constructor(x, y, team, radius, duration) {
                    super(x, y, radius, team, 1);
                    this.duration = duration;
                    this.lifetime = duration;
                    this.healTick = 30; // Heal every 0.5 seconds
                    this.tickTimer = this.healTick;
                    this.healAmount = 20;
                }
                update() {
                    this.lifetime--;
                    if (this.lifetime <= 0) {
                        this.health = 0;
                        return;
                    }
                    this.tickTimer--;
                    if (this.tickTimer <= 0) {
                        this.tickTimer = this.healTick;
                        for (const obj of gameObjects) {
                            if (obj.team === this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                                if (getDistance(this, obj) < this.radius && obj.health < obj.maxHealth) {
                                    obj.health = Math.min(obj.maxHealth, obj.health + this.healAmount);
                                }
                            }
                        }
                    }
                }
                draw() {
                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.3;
                    ctx.fillStyle = `rgba(34, 197, 94, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            class ExplosionEffect extends GameObject {
                constructor(x, y, radius) {
                    super(x, y, radius, 'neutral', 1);
                    this.animationTimer = 20;
                }
                update() {
                    this.animationTimer--;
                    if (this.animationTimer <= 0) {
                        this.health = 0;
                    }
                }
                draw() {
                    const progress = this.animationTimer / 20;
                    ctx.fillStyle = `rgba(239, 68, 68, ${0.8 * (1 - progress)})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * (1 - progress), 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            class AngerSpell extends GameObject {
                constructor(x, y, team, radius, duration) {
                    super(x, y, radius, team, 1);
                    this.duration = duration * 60;
                    this.lifetime = this.duration;
                    this.angeredUnits = new Set();
                }
                update() {
                    this.lifetime--;
                    if (this.lifetime <= 0) {
                        // Spell expired: all buffed units/buildings/towers immediately lose Anger.
                        this.angeredUnits.forEach(unit => {
                            if (unit && unit.isAngered) {
                                if (unit.originalDamage !== undefined) {
                                    unit.attackDamage = unit.originalDamage;
                                }
                                if (unit.originalCooldown !== undefined) {
                                    unit.attackCooldown = unit.originalCooldown;
                                }
                                unit.isAngered = false;
                                unit.angeredTimer = null;
                            }
                        });
                        this.angeredUnits.clear();
                        this.health = 0;
                        return;
                    }
                    // Pass 1: apply Anger to units in the pool and start trailing timers when they leave.
                    for (const obj of gameObjects) {
                        if (obj.team === this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                            const inPool = getDistance(this, obj) < this.radius;
                            if (inPool) {
                                if (!obj.isAngered) {
                                    obj.isAngered = true;
                                    if (obj.attackDamage !== undefined) {
                                        obj.originalDamage = obj.attackDamage;
                                        obj.attackDamage *= 2;
                                    }
                                    if (obj.attackCooldown !== undefined) {
                                        obj.originalCooldown = obj.attackCooldown;
                                        obj.attackCooldown = Math.floor(obj.attackCooldown / 1.5);
                                    }
                                    this.angeredUnits.add(obj);
                                }
                                // While inside the pool, no trailing timer is counting down.
                                obj.angeredTimer = null;
                            } else if (obj.isAngered && this.angeredUnits.has(obj)) {
                                // Left the pool while the spell is still active: start 2s trailing buff.
                                if (obj.angeredTimer === null || obj.angeredTimer <= 0) {
                                    obj.angeredTimer = 2 * 60;
                                }
                            }
                        }
                    }

                    // Pass 2: tick down trailing timers for angered units that have left the pool.
                    this.angeredUnits.forEach(unit => {
                        if (!unit || !unit.isAngered) {
                            return;
                        }
                        if (unit.angeredTimer !== null && unit.angeredTimer > 0) {
                            unit.angeredTimer--;
                            if (unit.angeredTimer <= 0) {
                                if (unit.originalDamage !== undefined) {
                                    unit.attackDamage = unit.originalDamage;
                                }
                                if (unit.originalCooldown !== undefined) {
                                    unit.attackCooldown = unit.originalCooldown;
                                }
                                unit.isAngered = false;
                                unit.angeredTimer = null;
                            }
                        }
                    });
                }
                draw() {
                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.4;
                    ctx.fillStyle = `rgba(147, 51, 234, ${alpha})`; // purple-700
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            class VoidTrapEffect extends GameObject {
                constructor(x, y, team, radius, damage) {
                    super(x, y, radius, team, 1);
                    this.damage = damage;
                    this.animationTimer = 30;
                    this.maxAnimationTimer = 30;
                    this.hit = false;
                    this.hitObjects = new Set();
                }
                update() {
                    if (!this.hit) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && !this.hitObjects.has(obj) && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (getDistance(this, obj) < this.radius) {
                                    obj.health -= this.damage;
                                    this.hitObjects.add(obj);
                                }
                            }
                        }
                        this.hit = true;
                    }
                    this.animationTimer--;
                    if (this.animationTimer <= 0) {
                        this.health = 0;
                    }
                }
                draw() {
                    const progress = this.animationTimer / this.maxAnimationTimer;
                    const alpha = (0.5 - Math.abs(progress - 0.5)) * 2;
                    ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * (1 - progress * 0.3), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = `rgba(147, 51, 234, ${alpha})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.font = `${this.radius * 0.8}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.globalAlpha = alpha;
                    ctx.fillText('‚ö´', this.x, this.y);
                    ctx.globalAlpha = 1;
                }
            }

            class ChaosOrbEffect extends GameObject {
                constructor(x, y, team, radius, damage) {
                    super(x, y, radius, team, 1);
                    this.damage = damage;
                    this.animationTimer = 30;
                    this.maxAnimationTimer = 30;
                    this.hit = false;
                    this.hitObjects = new Set();
                }
                update() {
                    if (!this.hit) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && !this.hitObjects.has(obj) && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (getDistance(this, obj) < this.radius) {
                                    obj.health -= this.damage;
                                    this.hitObjects.add(obj);
                                }
                            }
                        }
                        this.hit = true;
                    }
                    this.animationTimer--;
                    if (this.animationTimer <= 0) {
                        this.health = 0;
                    }
                }
                draw() {
                    const progress = this.animationTimer / this.maxAnimationTimer;
                    const alpha = (0.5 - Math.abs(progress - 0.5)) * 2;
                    ctx.fillStyle = `rgba(200, 100, 255, ${alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * (1 + progress * 0.2), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.font = `${this.radius}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.globalAlpha = alpha;
                    ctx.fillText('üåÄ', this.x, this.y);
                    ctx.globalAlpha = 1;
                }
            }

            class Projectile extends GameObject {
                constructor(x, y, target, team, damage, splashRadius = 0) { 
                    super(x, y, 4, team, 1); 
                    this.target = target; 
                    this.damage = damage; 
                    this.speed = 5; 
                    this.splashRadius = splashRadius;
                }
                update() { 
                    if (!this.target || this.target.health <= 0) { this.health = 0; return; }
                    if (this.target instanceof PhantomKnight && this.target.isInvisible) { this.health = 0; return; }
                    const dist = getDistance(this, this.target); 
                    if (dist < this.speed) { 
                        // Hit target
                        this.target.health -= this.damage; 
                        
                        // Handle splash
                        if (this.splashRadius > 0) {
                            for (const obj of gameObjects) {
                                if (obj.team !== this.team && obj !== this.target && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                    if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                    if (getDistance(this.target, obj) < this.splashRadius) {
                                        obj.health -= this.damage; // Splash does full damage
                                    }
                                }
                            }
                        }
                        
                        this.health = 0; 
                        return; 
                    } 
                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); 
                    this.x += Math.cos(angle) * this.speed; 
                    this.y += Math.sin(angle) * this.speed; 
                }
                draw() { 
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); 
                    ctx.fillStyle = this.team === 'player' ? '#a5f3fc' : '#fecaca'; 
                    ctx.fill(); 
                }
            }
            
            class FireballProjectile extends Projectile {
                draw() { 
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2); 
                    ctx.fillStyle = this.team === 'player' ? '#ffc107' : '#ff6f00'; 
                    ctx.fill(); 
                }
            }

            class Spell extends GameObject {
                constructor(x, y, team, damage, radius, emoji) {
                    super(x, y, radius, team, 1);
                    this.damage = damage;
                    this.animationTimer = 30;
                    this.maxAnimationTimer = 30;
                    this.hit = false;
                    this.emoji = emoji;
                }
                update() {
                    if (!this.hit) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (getDistance(this, obj) < this.radius) {
                                    obj.health -= this.damage;
                                }
                            }
                        }
                        this.hit = true;
                    }
                    this.animationTimer--;
                    if (this.animationTimer <= 0) {
                        this.health = 0;
                    }
                }
                draw() {
                    const progress = this.animationTimer / this.maxAnimationTimer;
                    const alpha = (0.5 - Math.abs(progress - 0.5)) * 2;
                    if (this.emoji === 'üéØ') {
                        ctx.fillStyle = `rgba(139, 69, 19, ${alpha * 0.2})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = `20px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = `rgba(101, 67, 33, ${alpha})`;
                        let yOffset = -this.radius + (this.radius * 2 * (1 - progress));
                        ctx.globalAlpha = alpha;
                        ctx.fillText('‚¨áÔ∏è', this.x - 20, this.y - 20 + yOffset);
                        ctx.fillText('‚¨áÔ∏è', this.x + 20, this.y - 10 + yOffset);
                        ctx.fillText('‚¨áÔ∏è', this.x, this.y + 20 + yOffset);
                        ctx.globalAlpha = 1;
                    } else if (this.emoji === 'üî•') {
                        ctx.fillStyle = `rgba(253, 224, 71, ${alpha * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius * (1 - progress), 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = `${this.radius * 2}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.globalAlpha = alpha;
                        ctx.fillText(this.emoji, this.x, this.y);
                        ctx.globalAlpha = 1;
                    }
                }
            }
            
            // NEW: Poison Spell Class
            class PoisonSpell extends GameObject {
                constructor(x, y, team, damagePerSecond, radius, duration) {
                    super(x, y, radius, team, 1);
                    this.damagePerSecond = damagePerSecond;
                    this.duration = duration * 60; // 5 seconds
                    this.lifetime = this.duration;
                    this.damageTick = 60; // Damage every 1 second
                    this.tickTimer = this.damageTick;
                }
                update() {
                    this.lifetime--;
                    if (this.lifetime <= 0) {
                        this.health = 0;
                        return;
                    }
                    this.tickTimer--;
                    if (this.tickTimer <= 0) {
                        this.tickTimer = this.damageTick;
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (getDistance(this, obj) < this.radius) {
                                    obj.health -= this.damagePerSecond;
                                }
                            }
                        }
                    }
                }
                draw() {
                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.3; // Fades in and out
                    ctx.fillStyle = `rgba(234, 179, 8, ${alpha})`; // yellow-500
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }


            // ==============================================
            // GAME LOGIC (FUNCTIONS)
            // MOVED UP TO FIX DEMO MODE
            // ==============================================

            // --- FIX: Moved initCardSystem to be the FIRST function defined ---
            function initCardSystem() {
                allCards = {
                    // Arena 1
                    'knight': { name: 'Knight', cost: 3, emoji: '‚öîÔ∏è', type: 'Melee', unitClass: Knight, placementRadius: 12, isFlying: false, arena: 1, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 500, damage: 65, hitSpeed: 1.2, speed: 1.0 } } }, // Speed 1.2 -> 1.0
                    'archer': { name: 'Archer', cost: 4, emoji: 'üèπ', type: 'Ranged', unitClass: Archer, placementRadius: 10, isFlying: false, arena: 1, targets: 'Air & Ground', aggroRange: 120,
                                stats: { 1: { health: 250, damage: 40, hitSpeed: 1, speed: 1.0 } } }, // Speed 1.2 -> 1.0
                    'giant': { name: 'Giant', cost: 5, emoji: 'üí™', type: 'Tank', unitClass: Giant, placementRadius: 18, isFlying: false, arena: 1, targets: 'Buildings', aggroRange: 100,
                                stats: { 1: { health: 1000, damage: 60, hitSpeed: 1.5, speed: 0.6 } } }, // Speed Unchanged
                    'goblins': { name: 'Goblins', cost: 2, emoji: 'üë∫', type: 'Swarm', unitClass: Goblins, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { count: 3, health: 100, damage: 20, hitSpeed: 1, speed: 1.2 } } }, // Speed 1.5 -> 1.2
                    'skeletons': { name: 'Skeletons', cost: 1, emoji: 'üíÄ', type: 'Swarm', unitClass: Skeletons, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { count: 3, health: 10, damage: 5, hitSpeed: 1.2, speed: 1.4 } } }, // Speed 1.6 -> 1.4, damage buffed to 5
                    'tinyBot': { name: 'Tiny Bot', cost: 4, emoji: 'ü§ñ', type: 'Melee', unitClass: TinyBot, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 700, damage: 250, hitSpeed: 1.8, speed: 1.0 } } }, // Speed 1.2 -> 1.0
                    'fireball': { name: 'Fireball', cost: 4, emoji: 'üî•', type: 'Spell', radius: 50, placementRadius: 50, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { damage: 250 } } },
                    'arrows': { name: 'Arrows', cost: 3, emoji: 'üéØ', type: 'Spell', radius: 80, placementRadius: 80, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { damage: 140 } } },
                    // Arena 2
                    'hut': { name: 'Goblin House', cost: 5, emoji: 'üè†', type: 'Building', unitClass: GoblinHut, placementRadius: 20, isFlying: false, arena: 2, targets: '-',
                                stats: { 1: { health: 800, spawn_speed: '5s', lifetime: '30s' } } },
                    'skeletonArmy': { name: 'Skeleton Group', cost: 3, emoji: '‚ò†Ô∏è', type: 'Swarm', unitClass: SkeletonArmy, placementRadius: 10, isFlying: false, arena: 2, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { count: 15, health: 10, damage: 5, hitSpeed: 1.2, speed: 1.4 } } }, // Speed 1.6 -> 1.4, damage buffed to 5
                    'goblinGang': { name: 'Goblin Group', cost: 3, emoji: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶', type: 'Swarm', unitClass: GoblinGang, placementRadius: 10, isFlying: false, arena: 2, targets: 'Air & Ground', aggroRange: 100,
                                stats: { 1: { count: 3, health: 100, damage: 20, hitSpeed: 1, speed: 1.2, spear_count: 3, spear_health: 60, spear_damage: 25, spear_hitSpeed: 1.2, spear_speed: 1.2 } } }, // Speed 1.5 -> 1.2
                    'spearGoblins': { name: 'Spear Goblins', cost: 2, emoji: 'üéØ', type: 'Swarm', unitClass: SpearGoblins, placementRadius: 10, isFlying: false, arena: 2, targets: 'Air & Ground', aggroRange: 100,
                                stats: { 1: { count: 3, health: 60, damage: 25, hitSpeed: 1.2, speed: 1.2 } } },
                    // Arena 3
                    'fireDragon': { name: 'Fire Dragon', cost: 4, emoji: 'üê≤', type: 'Air', unitClass: FireDragon, placementRadius: 12, isFlying: true, arena: 3, targets: 'Air & Ground', aggroRange: 110,
                                stats: { 1: { health: 800, damage: 120, hitSpeed: 1.5, splashRadius: 25, speed: 1.0 } } }, // Speed 1.2 -> 1.0
                    'barbarians': { name: 'Barbarians', cost: 5, emoji: 'üßî', type: 'Swarm', unitClass: Barbarians, placementRadius: 10, isFlying: false, arena: 3, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { count: 5, health: 300, damage: 60, hitSpeed: 1.4, speed: 0.9 } } }, // Speed 1.1 -> 0.9
                    'battleRam': { name: 'Battle Ram', cost: 4, emoji: 'üå≤', type: 'WinCon', unitClass: BattleRam, placementRadius: 10, isFlying: false, arena: 3, targets: 'Buildings', aggroRange: 100,
                                stats: { 1: { health: 700, damage: 200, chargeSpeed: 2.0, barbLevel: 1, speed: 1.0 } } }, // Speed 1.2 -> 1.0, Charge 2.5 -> 2.0
                    'barbarianHut': { name: 'Barbarian House', cost: 7, emoji: 'üèòÔ∏è', type: 'Building', unitClass: BarbarianHut, placementRadius: 20, isFlying: false, arena: 3, targets: '-',
                                stats: { 1: { health: 1000, spawn_speed: '10s', lifetime: '40s', barbLevel: 1 } } },
                    'axeSwinger': { name: 'Axe Swinger', cost: 4, emoji: 'ü™ì', type: 'Melee', unitClass: AxeSwinger, placementRadius: 12, isFlying: false, arena: 3, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 700, damage: 100, hitSpeed: 1.5, splashRadius: 24, speed: 1.0 } } }, // Speed 1.2 -> 1.0, splashRadius reduced
                    // Arena 4 (NEW CARDS)
                    'pigs': { name: 'Pigs', cost: 4, emoji: 'üê∑', type: 'WinCon', unitClass: Pigs, placementRadius: 10, isFlying: false, arena: 4, targets: 'Buildings', aggroRange: 100,
                                stats: { 1: { count: 4, health: 300, damage: 50, hitSpeed: 1.1, speed: 1.4 } } }, // Speed 1.8 -> 1.4
                    'farmer': { name: 'Farmer', cost: 3, emoji: 'üë®‚Äçüåæ', type: 'Melee', unitClass: Farmer, placementRadius: 12, isFlying: false, arena: 4, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 600, damage: 70, hitSpeed: 1.4, attackWidth: 30, attackHeight: 40, speed: 1.0 } } }, // Speed 1.2 -> 1.0
                    'poison': { name: 'Poison', cost: 4, emoji: 'ü§¢', type: 'Spell', radius: 60, placementRadius: 60, arena: 4, targets: 'Air & Ground',
                                stats: { 1: { damagePerSecond: 40, duration: 5 } } },
                    // Arena 5 (NEW CARDS)
                    'flyingSkeletons': { name: 'Flying Skeletons', cost: 3, emoji: 'üíÄü¶á', type: 'Swarm', unitClass: FlyingSkeletons, placementRadius: 10, isFlying: true, arena: 5, targets: 'Air & Ground', aggroRange: 100,
                                stats: { 1: { count: 3, health: 40, damage: 40, hitSpeed: 1, speed: 1.4 } } }, // Emoji üíÄüïäÔ∏è -> üíÄü¶á
                    'megaFlyingSkeleton': { name: 'Mega Flying Skeleton', cost: 4, emoji: 'üíÄü¶á', type: 'Air', unitClass: MegaFlyingSkeleton, placementRadius: 12, isFlying: true, arena: 5, targets: 'Air & Ground', aggroRange: 100,
                                stats: { 1: { health: 600, damage: 100, hitSpeed: 1.3, speed: 1.2 } } }, // Emoji üíÄüïäÔ∏è -> üíÄü¶á
                    'flyingSkeletonGroup': { name: 'Flying Skeleton Group', cost: 5, emoji: 'üíÄü¶á', type: 'Swarm', unitClass: FlyingSkeletonGroup, placementRadius: 10, isFlying: true, arena: 5, targets: 'Air & Ground', aggroRange: 100,
                                stats: { 1: { count: 6, health: 40, damage: 40, hitSpeed: 1, speed: 1.4 } } }, // Emoji üíÄüïäÔ∏è -> üíÄü¶á
                    // Arena 6 (NEW CARDS)
                    'warlock': { name: 'Warlock', cost: 5, emoji: 'üîÆ', type: 'Ranged', unitClass: Warlock, placementRadius: 12, isFlying: false, arena: 6, targets: 'Air & Ground', aggroRange: 110,
                                stats: { 1: { health: 600, damage: 140, hitSpeed: 1.5, splashRadius: 30, speed: 1.0 } } },
                    // Arena 7 (NEW)
                    'mage': { name: 'Mage', cost: 5, emoji: 'üßô‚Äç‚ôÄÔ∏è', type: 'Ranged', unitClass: Mage, placementRadius: 12, isFlying: false, arena: 7, targets: 'Air & Ground', aggroRange: 110,
                        stats: { 1: { health: 350, damage: 120, hitSpeed: 1.5, splashRadius: 30, speed: 1.0 } } },
                    // Arena 7 (NEW CARDS)
                    'phantomKnight': { name: 'Phantom Knight', cost: 4, emoji: 'üëª‚öîÔ∏è', type: 'Melee', unitClass: PhantomKnight, placementRadius: 12, isFlying: false, arena: 7, targets: 'Troops', aggroRange: 110,
                        stats: { 1: { health: 500, damage: 70, hitSpeed: 1.1, speed: 1.6 } } },
                    'spiritLantern': { name: 'Spirit Lantern', cost: 5, emoji: 'üèÆ', type: 'Building', unitClass: SpiritLantern, placementRadius: 18, isFlying: false, arena: 7, targets: '-',
                        stats: { 1: { health: 900, spawn_speed: '6s', lifetime: '24s' } } },
                    'zapSpirit': { name: 'Zap Spirit', cost: 1, emoji: '‚ö°', type: 'Spirit', unitClass: ZapSpirit, placementRadius: 8, isFlying: false, arena: 6, targets: 'Air & Ground', aggroRange: 200,
                                stats: { 1: { health: 150, jumpRadius: 100, effectRadius: 80, damage: 100 } } },
                    'coldSpirit': { name: 'Cold Spirit', cost: 1, emoji: '‚ùÑÔ∏è', type: 'Spirit', unitClass: ColdSpirit, placementRadius: 8, isFlying: false, arena: 6, targets: 'Air & Ground', aggroRange: 200,
                                stats: { 1: { health: 150, jumpRadius: 100, effectRadius: 60, freezeDuration: 3 } } },
                    'lifeSpirit': { name: 'Life Spirit', cost: 1, emoji: 'üíö', type: 'Spirit', unitClass: LifeSpirit, placementRadius: 8, isFlying: false, arena: 6, targets: '-', aggroRange: 200,
                                stats: { 1: { health: 150, jumpRadius: 100, effectRadius: 60, healDuration: 3 } } },
                    'bombSpirit': { name: 'Bomb Spirit', cost: 2, emoji: 'üí£', type: 'Spirit', unitClass: BombSpirit, placementRadius: 8, isFlying: false, arena: 6, targets: 'Air & Ground', aggroRange: 200,
                                stats: { 1: { health: 150, jumpRadius: 100, effectRadius: 50, damage: 200 } } },
                    'anger': { name: 'Anger', cost: 3, emoji: 'üò°', type: 'Spell', radius: 60, placementRadius: 60, arena: 6, targets: '-',
                                stats: { 1: { duration: 5 } } },
                    // Arena 8 (NEW CARDS)
                    'chaosElemental': { name: 'Chaos Elemental', cost: 5, emoji: 'üëπ', type: 'Melee', unitClass: ChaosElemental, placementRadius: 12, isFlying: false, arena: 8, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 750, damage: 110, hitSpeed: 1.1, speed: 1.0 }, 2: { health: 825, damage: 121, hitSpeed: 1.1, speed: 1.0 }, 3: { health: 908, damage: 133, hitSpeed: 1.1, speed: 1.0 }, 4: { health: 998, damage: 146, hitSpeed: 1.1, speed: 1.0 }, 5: { health: 1098, damage: 161, hitSpeed: 1.1, speed: 1.0 }, 6: { health: 1208, damage: 177, hitSpeed: 1.1, speed: 1.0 } } },
                    'shadowClone': { name: 'Shadow Clone', cost: 4, emoji: 'üë§', type: 'Ranged', unitClass: ShadowClone, placementRadius: 10, isFlying: false, arena: 8, targets: 'Air & Ground', aggroRange: 120,
                                stats: { 1: { health: 320, damage: 55, hitSpeed: 1.2, speed: 1.0 }, 2: { health: 352, damage: 61, hitSpeed: 1.2, speed: 1.0 }, 3: { health: 387, damage: 67, hitSpeed: 1.2, speed: 1.0 }, 4: { health: 426, damage: 73, hitSpeed: 1.2, speed: 1.0 }, 5: { health: 469, damage: 81, hitSpeed: 1.2, speed: 1.0 }, 6: { health: 516, damage: 89, hitSpeed: 1.2, speed: 1.0 } } },
                    'voidTrap': { name: 'Void Trap', cost: 4, emoji: '‚ö´', type: 'Spell', radius: 70, placementRadius: 70, arena: 8, targets: 'Air & Ground',
                                stats: { 1: { damage: 180 } } },
                    'stoneGiant': { name: 'Stone Giant', cost: 8, emoji: 'üóø', type: 'Tank', unitClass: StoneGiant, placementRadius: 18, isFlying: false, arena: 8, targets: 'Towers', aggroRange: 100,
                                stats: { 1: { health: 1750, damage: 104, hitSpeed: 1.3, speed: 0.6 }, 2: { health: 1925, damage: 114, hitSpeed: 1.3, speed: 0.6 }, 3: { health: 2118, damage: 125, hitSpeed: 1.3, speed: 0.6 }, 4: { health: 2329, damage: 138, hitSpeed: 1.3, speed: 0.6 }, 5: { health: 2563, damage: 152, hitSpeed: 1.3, speed: 0.6 }, 6: { health: 2819, damage: 167, hitSpeed: 1.3, speed: 0.6 } },
                                miniStats: { 1: { health: 700, damage: 41, hitSpeed: 1.3, speed: 0.7 }, 2: { health: 770, damage: 46, hitSpeed: 1.3, speed: 0.7 }, 3: { health: 848, damage: 51, hitSpeed: 1.3, speed: 0.7 }, 4: { health: 931, damage: 55, hitSpeed: 1.3, speed: 0.7 }, 5: { health: 1025, damage: 61, hitSpeed: 1.3, speed: 0.7 }, 6: { health: 1128, damage: 67, hitSpeed: 1.3, speed: 0.7 } } },
                    'miniStoneGiant': { name: 'Mini Stone Giant', cost: 0, emoji: 'ü™®', type: 'Troop', unitClass: MiniStoneGiant, placementRadius: 12, isFlying: false, hidden: true, targets: 'Towers', aggroRange: 80,
                            stats: { 1: { health: 700, damage: 41, hitSpeed: 1.3, speed: 0.7 }, 2: { health: 770, damage: 46, hitSpeed: 1.3, speed: 0.7 }, 3: { health: 848, damage: 51, hitSpeed: 1.3, speed: 0.7 }, 4: { health: 931, damage: 55, hitSpeed: 1.3, speed: 0.7 }, 5: { health: 1025, damage: 61, hitSpeed: 1.3, speed: 0.7 }, 6: { health: 1128, damage: 67, hitSpeed: 1.3, speed: 0.7 } } },
                    'chaosOrb': { name: 'Chaos Orb', cost: 3, emoji: 'üåÄ', type: 'Spell', radius: 50, placementRadius: 50, arena: 8, targets: 'Air & Ground',
                                stats: { 1: { damage: 200 } } },
                    'tower': { name: 'Tower Upgrade', emoji: 'üëë' }
                };
                
                // --- NEW: Auto-calculate stats for levels 2-15 ---
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue; // Allow miniStoneGiant to auto-scale like other cards
                    const card = allCards[cardId];
                    for (let level = 2; level <= 15; level++) { // Cap at 15
                        if (!card.stats[level]) {
                            const prevStats = card.stats[level - 1];
                            const newStats = { ...prevStats };
                            // Increase health and damage by ~10% per level
                            if (newStats.health) newStats.health = Math.round(newStats.health * 1.1);
                            if (newStats.damage) newStats.damage = Math.round(newStats.damage * 1.1);
                            if (newStats.damagePerSecond) newStats.damagePerSecond = Math.round(newStats.damagePerSecond * 1.1); // For Poison
                            // Handle sub-unit stats
                            if (newStats.spear_health) newStats.spear_health = Math.round(newStats.spear_health * 1.1);
                            if (newStats.spear_damage) newStats.spear_damage = Math.round(newStats.spear_damage * 1.1);
                            // Handle spirit stats
                            if (newStats.jumpRadius) newStats.jumpRadius = Math.round(newStats.jumpRadius * 1.05);
                            if (newStats.effectRadius) newStats.effectRadius = Math.round(newStats.effectRadius * 1.05);
                            // Prevent splashRadius upgrade for AxeSwinger
                            if (cardId !== 'axeSwinger' && newStats.splashRadius) newStats.splashRadius = Math.round(newStats.splashRadius * 1.1);
                            // Update levels for spawner cards
                            if (cardId === 'battleRam' || cardId === 'barbarianHut') newStats.barbLevel = level;
                            card.stats[level] = newStats;
                        }
                    }
                }
            }
            
            function getDistance(obj1, obj2) {
                const dx = obj1.x - obj2.x; const dy = obj1.y - obj2.y; return Math.sqrt(dx * dx + dy * dy);
            }

            // Helper for Farmer attack
            function isInside(point, cx, cy, width, height, angle) {
                const dx = point.x - cx;
                const dy = point.y - cy;
                const rotatedX = dx * Math.cos(-angle) - dy * Math.sin(-angle);
                const rotatedY = dx * Math.sin(-angle) + dy * Math.cos(-angle);
                // Check if point is inside the rectangle defined in front of the farmer
                return rotatedX > 0 && rotatedX < height && Math.abs(rotatedY) < width / 2;
            }

            function drawArena() {
                // River
                if (currentArenaTheme === 'arena-3') {
                    ctx.fillStyle = '#f45d22'; // Lava
                } else if (currentArenaTheme === 'arena-2') {
                    ctx.fillStyle = '#4a90e2'; // Lighter blue
                } else if (currentArenaTheme === 'arena-4') {
                    ctx.fillStyle = '#65a30d'; // Farm river
                } else if (currentArenaTheme === 'arena-5') {
                    ctx.fillStyle = '#4338ca'; // Indigo-700
                } else if (currentArenaTheme === 'arena-6') {
                    ctx.fillStyle = '#92400e'; // Brown-700
                } else if (currentArenaTheme === 'arena-8') {
                    ctx.fillStyle = '#9333ea'; // Purple-600 for chaos
                } else {
                    ctx.fillStyle = '#3b82f6'; // Default blue
                }
                ctx.fillRect(0, RIVER_Y - 10, WIDTH, 20);
                
                // Bridges
                ctx.fillStyle = '#a16207'; // Brown
                ctx.fillRect(LANE_LEFT_X - 25, RIVER_Y - 15, 50, 30);
                ctx.fillRect(LANE_RIGHT_X - 25, RIVER_Y - 15, 50, 30);
            }

            function getAILevel() {
                if (trophies >= 1750) return 8; // NEW Arena 8
                if (trophies >= 1500) return 7; // NEW Arena 7
                if (trophies >= 1250) return 6;
                if (trophies >= 1000) return 5;
                if (trophies >= 750) return 4;
                if (trophies >= 500) return 3;
                if (trophies >= 250) return 2;
                return 1;
            }

            // --- FIX: All functions moved above the code that calls them ---
            function getUnlockedCards(includeTower = false, aiLevel = 0) {
                const unlocked = [];
                // Use AI level if provided, otherwise use player's trophies
                let arenaNum = 1;
                if (aiLevel > 0) {
                    arenaNum = aiLevel;
                } else {
                    if (currentArenaFloor >= 1750) arenaNum = 8;
                    else if (currentArenaFloor >= 1500) arenaNum = 7;
                    else if (currentArenaFloor >= 1250) arenaNum = 6;
                    else if (currentArenaFloor >= 1000) arenaNum = 5;
                    else if (currentArenaFloor >= 750) arenaNum = 4;
                    else if (currentArenaFloor >= 500) arenaNum = 3;
                    else if (currentArenaFloor >= 250) arenaNum = 2;
                    else arenaNum = 1;
                }
                for (const cardId in allCards) {
                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Never include tower or internal mini in this list
                    if (allCards[cardId].arena <= arenaNum) {
                        unlocked.push(cardId);
                    }
                }
                if (includeTower) {
                    unlocked.push('tower');
                }
                return unlocked;
            }

            function createCardDOM(cardId, isSmall = false, inHand = false) {
                const card = allCards[cardId];
                if (!card) return null;
                
                const cardData = cardCollection[cardId];
                // In 2v2 mode, treat all cards as unlocked and level 15
                const isLocked = (gameMode === '2v2') ? false : (!inHand && (!cardData || !cardData.unlocked));
                
                const cardEl = document.createElement('div');
                cardEl.className = `card-ui ${isSmall ? 'card-ui-small' : ''}`;
                cardEl.dataset.unit = cardId;
                
                if (isLocked) { // Removed !inHand check, it's now at the top
                    cardEl.classList.add('card-ui-locked');
                    cardEl.innerHTML = `
                        <div class="card-ui-cost">${card.cost}</div>
                        <span class="card-ui-name">${card.name}</span>
                        <span class="card-ui-emoji">${card.emoji}</span>
                        <span class="card-ui-type">${card.type}</span>
                        <div class="card-ui-locked-arena">Unlocks in Arena ${card.arena}</div>
                    `;
                    return cardEl;
                }

                const displayLevel = (gameMode === '2v2') ? 15 : ((cardData && cardData.level) ? cardData.level : 1);
                const displayCount = (cardData && cardData.count) ? cardData.count : 0;
                
                cardEl.dataset.cost = card.cost;
                cardEl.dataset.type = card.type;
                cardEl.dataset.emoji = card.emoji;
                cardEl.dataset.radius = card.placementRadius;
                if (card.radius) cardEl.dataset.spellRadius = card.radius;
                let progressBarHTML = '';
                let levelTextHTML = `<div class="card-ui-level">Lvl ${displayLevel}</div>`;
                if (!inHand) {
                    const costs = upgradeCosts[displayLevel];
                    let progress = 0;
                    let canUpgrade = false;
                    if (costs) {
                        progress = (displayCount / costs.cards) * 100;
                        if (displayCount >= costs.cards && gold >= costs.gold) { canUpgrade = true; }
                    } else { progress = 100; } // Max level
                    progressBarHTML = `<div class="card-ui-progress-bar"><div class="card-ui-progress ${canUpgrade ? 'can-upgrade' : ''}" style="width: ${Math.min(100, progress)}%;"></div></div>`;
                } else { levelTextHTML = ''; }
                cardEl.innerHTML = `<div class="card-ui-cost">${card.cost}</div><span class="card-ui-name">${card.name}</span><span class="card-ui-emoji">${card.emoji}</span><span class="card-ui-type">${card.type}</span>${levelTextHTML}${progressBarHTML}`;
                return cardEl;
            }

            function updateCardUI() {
                const elixirInt = Math.floor(playerElixir);
                elixirBar.style.width = `${(playerElixir / MAX_ELIXIR) * 100}%`;
                elixirText.textContent = elixirInt;
                document.querySelectorAll('#cardHand .card-ui').forEach(cardEl => {
                    const cost = parseInt(cardEl.dataset.cost);
                    if (cost > elixirInt) { cardEl.classList.add('disabled'); }
                    else { cardEl.classList.remove('disabled'); }
                });
            }

            function shuffleDeck(deck) {
                let shuffled = [...deck]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } return shuffled;
            }

            function renderHand() {
                cardHandEl.innerHTML = '';
                hand.forEach((cardId, index) => {
                    const cardEl = createCardDOM(cardId, false, true);
                    cardEl.dataset.handIndex = index;
                    // Handle touch/mouse down for card selection
                    cardEl.addEventListener('mousedown', (e) => selectCard(e, cardEl, cardId));
                    cardEl.addEventListener('touchstart', (e) => selectCard(e, cardEl, cardId), { passive: false });
                    cardHandEl.appendChild(cardEl);
                });
                nextCardSlotEl.innerHTML = '';
                if (nextCard) {
                    nextCardSlotEl.appendChild(createCardDOM(nextCard, true, true));
                }
                updateCardUI();
            }
            
            function startGameDecks() {
                // Player
                gameDeck = shuffleDeck(playerDeck);
                hand = [];
                discardPile = [];
                for (let i = 0; i < 4; i++) { hand.push(gameDeck.pop()); }
                nextCard = gameDeck.pop();
                renderHand();
                
                // AI
                const aiArenaLevel = getAILevel(); // This is 1, 2, 3, 4 or 5
                
                // AI gets cards from its arena level, NO tower card
                const aiArenaCards = getUnlockedCards(false, aiArenaLevel);
                
                // Build a random 8-card deck
                aiDeck = [];
                let availableCards = [...aiArenaCards];
                for (let i = 0; i < 8; i++) {
                    if (availableCards.length === 0) availableCards = [...aiArenaCards]; // Refill if needed
                    let cardIndex = Math.floor(Math.random() * availableCards.length);
                    aiDeck.push(availableCards.splice(cardIndex, 1)[0]);
                }
                
                aiDeck = shuffleDeck(aiDeck);
                aiHand = [];
                aiDiscardPile = [];
                for (let i = 0; i < 4; i++) { if(aiDeck.length > 0) aiHand.push(aiDeck.pop()); }
                if(aiDeck.length > 0) aiNextCard = aiDeck.pop();

                // Initialize second AI for 2v2 - uses all available cards
                if (gameMode === '2v2') {
                    ai2Deck = [];
                    // Get all cards except internal ones
                    const all2v2Cards = Object.keys(allCards).filter(cardId => 
                        cardId !== 'tower' && cardId !== 'miniStoneGiant'
                    );
                    let availableCards2 = [...all2v2Cards];
                    for (let i = 0; i < 8; i++) {
                        if (availableCards2.length === 0) availableCards2 = [...all2v2Cards];
                        let cardIndex = Math.floor(Math.random() * availableCards2.length);
                        ai2Deck.push(availableCards2.splice(cardIndex, 1)[0]);
                    }
                    ai2Deck = shuffleDeck(ai2Deck);
                    ai2Hand = [];
                    ai2DiscardPile = [];
                    for (let i = 0; i < 4; i++) { if(ai2Deck.length > 0) ai2Hand.push(ai2Deck.pop()); }
                    if(ai2Deck.length > 0) ai2NextCard = ai2Deck.pop();
                }
            }

            function playCard(cardId, handIndex) {
                playerElixir -= allCards[cardId].cost;
                discardPile.push(cardId);
                hand.splice(handIndex, 1);
                hand.push(nextCard);
                if (gameDeck.length === 0) { gameDeck = shuffleDeck(discardPile); discardPile = []; }
                nextCard = gameDeck.pop();
                renderHand();
            }

            function aiPlayCard(cardId) {
                if (!allCards[cardId]) return; // Safety check
                aiElixir -= allCards[cardId].cost;
                aiDiscardPile.push(cardId);
                const handIndex = aiHand.indexOf(cardId);
                if (handIndex > -1) { aiHand.splice(handIndex, 1); }
                aiHand.push(aiNextCard);
                if (aiDeck.length === 0) { aiDeck = shuffleDeck(aiDiscardPile); aiDiscardPile = []; }
                aiNextCard = aiDeck.pop() || null;
            }

            function initGame() {
                gameObjects = [];
                playerElixir = 3;
                aiElixir = 3;
                aiTeammateElixir = 3; // Reset AI teammate elixir to 3
                selectedSpawningUnit = null;
                isSpawningSpell = false;
                gameRunning = true;
                aiThinkTimer = 0;
                gameTimer = REGULATION_TIME;
                isOvertime = false;
                isTieBreaker = false;
                tieBreakerTick = 0;
                overtimeInitialPlayerTowers = 0; // NEW
                overtimeInitialAiTowers = 0; // NEW
                
                // Reset spawn zones
                playerLeftTowerDestroyed = false;
                playerRightTowerDestroyed = false;
                aiLeftTowerDestroyed = false;
                aiRightTowerDestroyed = false;
                updatePlacementOverlay();
                
                messageOverlay.style.display = 'none';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';

                const aiArenaLevel = getAILevel();
                // UPDATED AI STAT LEVEL LOGIC
                if (aiArenaLevel === 1) { // Arena 1: 1
                    currentAiStatLevel = 1;
                } else if (aiArenaLevel === 2) { // Arena 2: 1-2
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 1; // 1 or 2
                } else if (aiArenaLevel === 3) { // Arena 3: 2-3
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 2; // 2 or 3
                } else if (aiArenaLevel === 4) { // Arena 4: 2-3
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 2; // 2 or 3
                } else if (aiArenaLevel === 5) { // Arena 5: 4-5
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 4; // 4 or 5
                } else if (aiArenaLevel === 6) { // Arena 6: 4-5
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 4; // 4 or 5
                } else if (aiArenaLevel === 7) { // Arena 7: 5-6
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 5; // 5 or 6
                } else { // Arena 8: 5-6
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 5; // 5 or 6
                }
                
                const playerTowerLevel = (gameMode === '2v2') ? 15 : towerLevel;
                const aiTowerLevel = (gameMode === '2v2') ? 15 : currentAiStatLevel;
                
                if (gameMode === '2v2') {
                    // 2v2: Two princess towers per side, one combined double king tower per side (rectangular, same height as normal king)
                    gameObjects.push(new Tower(LANE_LEFT_X, HEIGHT - 100, 'player', false, playerTowerLevel));
                    gameObjects.push(new Tower(LANE_RIGHT_X, HEIGHT - 100, 'player', false, playerTowerLevel));
                    gameObjects.push(new Tower(WIDTH / 2, HEIGHT - 50, 'player', true, playerTowerLevel, true)); // combined double king
                    gameObjects.push(new Tower(LANE_LEFT_X, 100, 'ai', false, aiTowerLevel));
                    gameObjects.push(new Tower(LANE_RIGHT_X, 100, 'ai', false, aiTowerLevel));
                    gameObjects.push(new Tower(WIDTH / 2, 50, 'ai', true, aiTowerLevel, true)); // combined double king
                } else {
                    // Normal: two princess towers, one king tower per side
                    gameObjects.push(new Tower(LANE_LEFT_X, HEIGHT - 100, 'player', false, playerTowerLevel));
                    gameObjects.push(new Tower(LANE_RIGHT_X, HEIGHT - 100, 'player', false, playerTowerLevel));
                    gameObjects.push(new Tower(WIDTH / 2, HEIGHT - 50, 'player', true, playerTowerLevel));
                    gameObjects.push(new Tower(LANE_LEFT_X, 100, 'ai', false, aiTowerLevel));
                    gameObjects.push(new Tower(LANE_RIGHT_X, 100, 'ai', false, aiTowerLevel));
                    gameObjects.push(new Tower(WIDTH / 2, 50, 'ai', true, aiTowerLevel));
                }

                startGameDecks();
                updateCardUI();

                // Initialize AI teammate if in 2v2 AI mode
                if (gameMode === '2v2' && is2v2AITeammate) {
                    initAITeammate();
                    updateAITeammateUI();
                }
            }

            function runAI() {
                const playerUnits = gameObjects.filter(o => o.team === 'player' && o instanceof Unit && o.y < RIVER_Y + 50);
                if (playerUnits.length > 0) {
                    let bestCardId = null;
                    // --- NEW AI LOGIC ---
                    if (playerUnits.some(u => u instanceof FlyingSkeleton || u instanceof FlyingSkeletonGroup) && aiHand.includes('fireDragon') && aiElixir >= allCards['fireDragon'].cost) {
                         bestCardId = 'fireDragon';
                    } else if (playerUnits.some(u => u instanceof FlyingSkeleton || u instanceof FlyingSkeletonGroup || u instanceof MegaFlyingSkeleton) && aiHand.includes('archer') && aiElixir >= allCards['archer'].cost) {
                         bestCardId = 'archer';
                    } else if (playerUnits.some(u => u instanceof Skeleton || u instanceof SkeletonArmy || u instanceof Barbarians || u instanceof GoblinGang) && aiHand.includes('poison') && aiElixir >= allCards['poison'].cost) {
                        bestCardId = 'poison';
                    } else if (playerUnits.some(u => u instanceof Skeleton || u instanceof SkeletonArmy || u instanceof Barbarians) && aiHand.includes('axeSwinger') && aiElixir >= allCards['axeSwinger'].cost) {
                        bestCardId = 'axeSwinger';
                    } else if (playerUnits.some(u => u instanceof Skeleton || u instanceof SkeletonArmy || u instanceof FlyingSkeleton || u instanceof FlyingSkeletonGroup) && aiHand.includes('arrows') && aiElixir >= allCards['arrows'].cost) {
                        bestCardId = 'arrows';
                    } else if (playerUnits.some(u => u instanceof Giant || u instanceof Pigs) && aiHand.includes('farmer') && aiElixir >= allCards['farmer'].cost) {
                        bestCardId = 'farmer';
                    } else if (playerUnits.some(u => u instanceof Giant) && aiHand.includes('tinyBot') && aiElixir >= allCards['tinyBot'].cost) {
                        bestCardId = 'tinyBot';
                    } else if (playerUnits.some(u => u instanceof Giant) && aiHand.includes('barbarians') && aiElixir >= allCards['barbarians'].cost) {
                        bestCardId = 'barbarians';
                    } else if (playerUnits.some(u => u instanceof FireDragon) && aiHand.includes('archer') && aiElixir >= allCards['archer'].cost) {
                        bestCardId = 'archer';
                    } else if (aiHand.includes('goblins') && aiElixir >= allCards['goblins'].cost) {
                        bestCardId = 'goblins';
                    }
                    if (bestCardId) { spawnAIUnit(bestCardId, currentAiStatLevel, true); return; } // Use global
                }
                
                // Fallback: If elixir is high, play a card
                if (aiElixir > 7) {
                    let bestCardId = null;
                    if(aiHand.includes('pigs') && aiElixir >= allCards['pigs'].cost) { bestCardId = 'pigs'; } // NEW
                    else if(aiHand.includes('giant') && aiElixir >= allCards['giant'].cost) { bestCardId = 'giant'; }
                    else if(aiHand.includes('barbarianHut') && aiElixir >= allCards['barbarianHut'].cost) { bestCardId = 'barbarianHut'; }
                    else if (aiHand.includes('tinyBot') && aiElixir >= allCards['tinyBot'].cost) { bestCardId = 'tinyBot'; }
                    else if (aiHand.includes('megaFlyingSkeleton') && aiElixir >= allCards['megaFlyingSkeleton'].cost) { bestCardId = 'megaFlyingSkeleton'; }
                    else {
                        // Play any random affordable unit
                        let affordableCards = aiHand.filter(id => allCards[id] && allCards[id].cost <= aiElixir && allCards[id].type !== 'Spell');
                        if (affordableCards.length > 0) {
                            bestCardId = affordableCards[Math.floor(Math.random() * affordableCards.length)];
                        }
                    }
                    if (bestCardId) { spawnAIUnit(bestCardId, currentAiStatLevel, false); return; } // Use global
                }

                // Use spell on tower
                if (aiElixir === MAX_ELIXIR && Math.random() < 0.2) {
                    let spellToUse = null;
                    if (aiHand.includes('poison')) spellToUse = 'poison';
                    else if (aiHand.includes('fireball')) spellToUse = 'fireball';
                    if (spellToUse) {
                        spawnAIUnit(spellToUse, currentAiStatLevel, false); // Use global
                        return;
                    }
                }
            }

            function spawnAIUnit(cardId, level, isDefensive = false) {
                const card = allCards[cardId];
                if (!card || card.cost > aiElixir) return;
                
                // Get AI's level for this card (force 15 in 2v2)
                const cardLevel = (gameMode === '2v2') ? 15 : level;
                
                if (card.type === 'Spell') {
                    let target = null;
                    if (cardId === 'fireball') {
                        target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0 && o.health < 600);
                        if (!target) target = gameObjects.find(o => o.team === 'player' && (o instanceof Barbarian || o instanceof Farmer));
                    } else if (cardId === 'arrows') {
                        target = gameObjects.find(o => o.team === 'player' && (o instanceof Skeleton || o instanceof SkeletonArmy || o instanceof GoblinGang || o instanceof FlyingSkeleton || o instanceof FlyingSkeletonGroup));
                    } else if (cardId === 'poison') { // NEW
                        target = gameObjects.find(o => o.team === 'player' && (o instanceof Tower) && o.health > 0);
                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Unit && o.y > RIVER_Y - 50);
                    } else if (cardId === 'anger') { // NEW
                        target = gameObjects.find(o => o.team === 'ai' && (o instanceof Unit || o instanceof Tower || o instanceof Building) && o.health > 0);
                    } else if (cardId === 'voidTrap') { // NEW
                        target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0);
                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Unit && o.health > 0);
                    } else if (cardId === 'chaosOrb') { // NEW
                        target = gameObjects.find(o => o.team === 'player' && (o instanceof Unit || o instanceof Building) && o.health > 0);
                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0);
                    }
                    if (target) {
                        if (cardId === 'poison') { // NEW
                            const s = card.stats[cardLevel];
                            gameObjects.push(new PoisonSpell(target.x, target.y, 'ai', s.damagePerSecond, card.radius, s.duration));
                        } else if (cardId === 'anger') { // NEW
                            const s = card.stats[cardLevel];
                            gameObjects.push(new AngerSpell(target.x, target.y, 'ai', card.radius, s.duration));
                        } else if (cardId === 'voidTrap') { // NEW
                            const damage = card.stats[cardLevel].damage;
                            gameObjects.push(new VoidTrapEffect(target.x, target.y, 'ai', card.radius, damage));
                        } else if (cardId === 'chaosOrb') { // NEW
                            const damage = card.stats[cardLevel].damage;
                            gameObjects.push(new ChaosOrbEffect(target.x, target.y, 'ai', card.radius, damage));
                        } else {
                            const damage = card.stats[cardLevel].damage;
                            gameObjects.push(new Spell(target.x, target.y, 'ai', damage, card.radius, card.emoji));
                        }
                        aiPlayCard(cardId);
                    }
                    return;
                }
                
                // NEW: Handle spirits
                if (card.type === 'Spirit') {
                    // Safety check: ensure unitClass exists
                    if (!card.unitClass || typeof card.unitClass !== 'function') {
                        console.error('Invalid unitClass for spirit card:', cardId, card);
                        return;
                    }
                    const spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;
                    const spawnY = isDefensive ? 150 + Math.random() * 50 : 50 + Math.random() * 50;
                    const newUnit = new card.unitClass(spawnX, spawnY, 'ai', cardLevel);
                    if (newUnit instanceof GameObject) {
                        gameObjects.push(newUnit);
                    }
                    aiPlayCard(cardId);
                    return;
                }
                
                // Determine spawn Y
                let spawnY;
                if (isDefensive) {
                    // Spawn behind princess towers
                    spawnY = 150 + Math.random() * 50;
                } else {
                    // Spawn at the back
                    spawnY = 50 + Math.random() * 50;
                }
                
                // Determine spawn X (which lane)
                const spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;
                
                // Check if spawn is valid (not on top of another building)
                let canSpawn = true;
                if (card.type === 'Building') {
                    for (const obj of gameObjects) {
                        if (obj instanceof Tower || obj instanceof Building) {
                            const dist = getDistance({x: spawnX, y: spawnY}, obj);
                            if (dist < card.placementRadius + obj.radius) { 
                                canSpawn = false; 
                                break; 
                            }
                        }
                    }
                }
                
                if (canSpawn && card.unitClass && typeof card.unitClass === 'function') {
                    const newUnit = new card.unitClass(spawnX, spawnY, 'ai', cardLevel);
                    // --- TYPEERROR FIX ---
                    // This is the bug. 'newUnit' is just the spawner (e.g. Pigs), not an actual Unit (e.g. Pig)
                    // We must check if the *class* is a single unit/building
                    if (newUnit instanceof GameObject) {
                         gameObjects.push(newUnit);
                    }
                    aiPlayCard(cardId);
                }
            }

            // --- AI Teammate (for 2v2) ---
            let aiTeammateTimer = 0;
            let aiTeammateElixir = 0;
            let aiTeammateHandCards = [];
            let aiTeammateDeck = [];
            let aiTeammateDiscardPile = []; // Add discard pile for recycling
            let aiTeammateNextCard = null; // Add NEXT card for proper cycling

            function initAITeammate() {
                // Note: elixir is reset to 3 in initGame(), not here
                aiTeammateHandCards = [];
                aiTeammateDiscardPile = []; // Reset discard pile
                aiTeammateNextCard = null; // Reset NEXT card
                
                // Build an 8-card deck for AI teammate (any card in the game)
                aiTeammateDeck = [];
                // Use all cards in the game for maximum variety
                const allGameCards = Object.keys(allCards).filter(cardId => 
                    cardId !== 'tower' && cardId !== 'miniStoneGiant' // Exclude internal cards
                );
                let availableCards = [...allGameCards];
                
                for (let i = 0; i < 8; i++) {
                    if (availableCards.length === 0) availableCards = [...allGameCards]; // Refill if needed
                    let cardIndex = Math.floor(Math.random() * availableCards.length);
                    aiTeammateDeck.push(availableCards.splice(cardIndex, 1)[0]);
                }
                
                aiTeammateDeck = shuffleDeck(aiTeammateDeck);
                
                // Draw initial hand (4 cards from the 8-card deck)
                for (let i = 0; i < 4; i++) {
                    aiTeammateHandCards.push(aiTeammateDeck.pop());
                }
                
                // Set initial NEXT card from the remaining 4 cards in deck
                if (aiTeammateDeck.length > 0) {
                    aiTeammateNextCard = aiTeammateDeck.pop();
                }
                
                updateAITeammateUI();
            }

            function drawAITeammateCard() {
                // Draw new NEXT card from remaining deck
                if (aiTeammateDeck.length > 0) {
                    aiTeammateNextCard = aiTeammateDeck.pop();
                }
                
                updateAITeammateUI();
            }

            function updateAITeammateUI() {
                if (gameMode !== '2v2' || !is2v2AITeammate) {
                    aiTeammateUI.style.display = 'none';
                    return;
                }
                aiTeammateUI.style.display = 'flex';
                // Render hand (exact same style as player hand)
                aiTeammateHand.innerHTML = '';
                aiTeammateHandCards.forEach(cardId => {
                    const cardEl = createCardDOM(cardId, false, true); // Same as player hand
                    cardEl.style.opacity = '0.8'; // Slightly transparent to distinguish from player
                    aiTeammateHand.appendChild(cardEl);
                });
                // Render next card (same style as player next)
                aiTeammateNext.innerHTML = '';
                if (aiTeammateNextCard) {
                    const cardEl = createCardDOM(aiTeammateNextCard, true, true); // Same as player next
                    cardEl.style.opacity = '0.6'; // Slightly transparent to distinguish from player
                    aiTeammateNext.appendChild(cardEl);
                }
                // Update elixir bar and count
                const elixirPercent = (aiTeammateElixir / MAX_ELIXIR) * 100;
                aiTeammateElixirBar.style.width = `${elixirPercent}%`;
                aiTeammateElixirCount.textContent = `${Math.floor(aiTeammateElixir)}/${MAX_ELIXIR}`;
            }

            function runAI2() {
                if (ai2ThinkTimer > 0) { ai2ThinkTimer--; return; }
                ai2ThinkTimer = 120; // Think every 2 seconds

                const playerUnits = gameObjects.filter(o => o.team === 'player' && o instanceof Unit && o.y < RIVER_Y + 50);
                if (playerUnits.length > 0) {
                    let bestCardId = null;
                    // --- NEW AI LOGIC ---
                    if (playerUnits.some(u => u instanceof FlyingSkeleton || u instanceof FlyingSkeletonGroup) && ai2Hand.includes('fireDragon') && ai2Elixir >= allCards['fireDragon'].cost) {
                         bestCardId = 'fireDragon';
                    } else if (playerUnits.some(u => u.isFlying) && ai2Hand.includes('arrows') && ai2Elixir >= allCards['arrows'].cost) {
                         bestCardId = 'arrows';
                    } else if (playerUnits.some(u => !u.isFlying) && ai2Hand.includes('axeSwinger') && ai2Elixir >= allCards['axeSwinger'].cost) {
                         bestCardId = 'axeSwinger';
                    } else if (ai2Hand.includes('giant') && ai2Elixir >= allCards['giant'].cost) {
                         bestCardId = 'giant';
                    } else if (ai2Hand.includes('stoneGiant') && ai2Elixir >= allCards['stoneGiant'].cost) {
                         bestCardId = 'stoneGiant';
                    } else if (ai2Hand.includes('fireDragon') && ai2Elixir >= allCards['fireDragon'].cost) {
                         bestCardId = 'fireDragon';
                    } else if (ai2Hand.includes('archer') && ai2Elixir >= allCards['archer'].cost) {
                         bestCardId = 'archer';
                    } else if (ai2Hand.includes('mage') && ai2Elixir >= allCards['mage'].cost) {
                         bestCardId = 'mage';
                    } else if (ai2Hand.includes('skeletons') && ai2Elixir >= allCards['skeletons'].cost) {
                         bestCardId = 'skeletons';
                    } else if (ai2Hand.includes('goblinGang') && ai2Elixir >= allCards['goblinGang'].cost) {
                         bestCardId = 'goblinGang';
                    } else if (ai2Hand.includes('barbarians') && ai2Elixir >= allCards['barbarians'].cost) {
                         bestCardId = 'barbarians';
                    } else if (ai2Hand.includes('cannon') && ai2Elixir >= allCards['cannon'].cost) {
                         bestCardId = 'cannon';
                    } else if (ai2Hand.includes('poison') && ai2Elixir >= allCards['poison'].cost) {
                         bestCardId = 'poison';
                    } else if (ai2Hand.includes('rage') && ai2Elixir >= allCards['rage'].cost) {
                         bestCardId = 'rage';
                    } else if (ai2Hand.includes('heal') && ai2Elixir >= allCards['heal'].cost) {
                         bestCardId = 'heal';
                    } else if (ai2Hand.includes('fireball') && ai2Elixir >= allCards['fireball'].cost) {
                         bestCardId = 'fireball';
                    } else if (ai2Hand.includes('lightning') && ai2Elixir >= allCards['lightning'].cost) {
                         bestCardId = 'lightning';
                    }
                    // --- END NEW AI LOGIC ---
                    if (bestCardId && ai2Elixir >= allCards[bestCardId].cost) {
                        const card = allCards[bestCardId];
                        // Safety check: ensure card exists and unitClass exists for non-spells
                        if (!card) {
                            console.error('Card not found:', bestCardId);
                            return;
                        }
                        if (card.type !== 'Spell' && (!card.unitClass || typeof card.unitClass !== 'function')) {
                            console.error('Invalid unitClass for non-spell card:', bestCardId, card);
                            return;
                        }
                        let spawnX = LANE_LEFT_X + Math.random() * (LANE_RIGHT_X - LANE_LEFT_X);
                        let spawnY = 100 + Math.random() * 100;
                        if (checkPlacement(spawnX, spawnY, card.placementRadius, card.type)) {
                            const level = (gameMode === '2v2') ? 15 : currentAi2StatLevel;
                            
                            // Handle spells properly
                            if (card.type === 'Spell') {
                                if (bestCardId === 'poison') {
                                    const s = card.stats[level];
                                    gameObjects.push(new PoisonSpell(spawnX, spawnY, 'ai', s.damagePerSecond, card.radius, s.duration));
                                } else if (bestCardId === 'rage') {
                                    const s = card.stats[level];
                                    gameObjects.push(new AngerSpell(spawnX, spawnY, 'ai', card.radius, s.duration));
                                } else if (bestCardId === 'arrows' || bestCardId === 'fireball') {
                                    const s = card.stats[level];
                                    gameObjects.push(new Projectile(spawnX, spawnY, null, 'ai', s.damage, card.radius));
                                } else if (bestCardId === 'heal') {
                                    const s = card.stats[level];
                                    gameObjects.push(new HealSpell(spawnX, spawnY, 'ai', s.healAmount, card.radius));
                                } else if (bestCardId === 'lightning') {
                                    const s = card.stats[level];
                                    gameObjects.push(new LightningSpell(spawnX, spawnY, 'ai', s.damage, card.radius));
                                }
                            } else if (card.type === 'Building') {
                                const newBuilding = new card.unitClass(spawnX, spawnY, 'ai', level);
                                if (newBuilding instanceof GameObject) gameObjects.push(newBuilding);
                            } else {
                                const newUnit = new card.unitClass(spawnX, spawnY, 'ai', level);
                                if (newUnit instanceof GameObject) {
                                    gameObjects.push(newUnit);
                                }
                            }
                            
                            // Proper card cycling like the first AI
                            const handIndex = ai2Hand.indexOf(bestCardId);
                            if (handIndex > -1) { 
                                ai2Hand.splice(handIndex, 1); 
                                ai2DiscardPile.push(bestCardId); // Add to discard pile
                            }
                            // Add NEXT card to hand (like player system)
                            if (ai2NextCard) {
                                ai2Hand.push(ai2NextCard);
                                ai2NextCard = null;
                            }
                            ai2Elixir -= card.cost;
                            // Draw new NEXT card and handle deck recycling
                            if (ai2Deck.length === 0 && ai2DiscardPile.length > 0) {
                                ai2Deck = shuffleDeck(ai2DiscardPile);
                                ai2DiscardPile = [];
                            }
                            if (ai2Deck.length > 0) {
                                ai2NextCard = ai2Deck.pop();
                            }
                        }
                    }
                }
            }

            function ai2PlayCard(cardId) {
                const index = ai2Hand.indexOf(cardId);
                if (index !== -1) {
                    ai2Hand.splice(index, 1);
                    ai2Elixir -= allCards[cardId].cost;
                    if (ai2Deck.length > 0) {
                        const newCard = ai2Deck.splice(Math.floor(Math.random() * ai2Deck.length), 1)[0];
                        ai2Hand.push(newCard);
                    }
                }
            }

            function runAITeammate() {
                if (gameMode !== '2v2' || !is2v2AITeammate) return;
                if (aiTeammateTimer > 0) { aiTeammateTimer--; return; }
                aiTeammateTimer = 90; // Think every ~1.5s

                // Find an affordable card
                const affordableCards = aiTeammateHandCards.filter(cardId => {
                    const card = allCards[cardId];
                    return card && card.cost <= aiTeammateElixir;
                });
                if (affordableCards.length === 0) return;

                // Smart decision: choose best card based on board state
                let bestCardId = null;
                let bestScore = -Infinity;

                const aiUnits = gameObjects.filter(o => o.team === 'ai' && o instanceof Unit);
                const playerUnits = gameObjects.filter(o => o.team === 'player' && o instanceof Unit);
                const aiTowers = gameObjects.filter(o => o.team === 'ai' && o instanceof Tower && o.health > 0);
                const playerTowers = gameObjects.filter(o => o.team === 'player' && o instanceof Tower && o.health > 0);

                for (const cardId of affordableCards) {
                    const card = allCards[cardId];
                    let score = 0;

                    // Defensive: if our towers are under attack
                    if (aiTowers.length > 0 && playerUnits.some(u => getDistance(u, aiTowers[0]) < 200)) {
                        if (card.type === 'Spell' && (cardId === 'arrows' || cardId === 'fireball' || cardId === 'poison')) {
                            score += 50;
                        } else if (card.type === 'Unit' && (cardId === 'skeletons' || cardId === 'goblinGang' || cardId === 'barbarians')) {
                            score += 30;
                        }
                    }

                    // Offensive: if enemy has units
                    if (playerUnits.length > 0) {
                        if (card.type === 'Unit') {
                            if (cardId === 'giant' || cardId === 'stoneGiant') score += 40;
                            else if (cardId === 'fireDragon' && playerUnits.some(u => u.isFlying)) score += 45;
                            else if (cardId === 'archer' && playerUnits.some(u => u.isFlying)) score += 35;
                            else if (cardId === 'axeSwinger' && playerUnits.some(u => !u.isFlying)) score += 35;
                            else score += 20;
                        } else if (card.type === 'Spell') {
                            if (playerUnits.length >= 3 && (cardId === 'poison' || cardId === 'fireball')) score += 40;
                            else if (playerUnits.some(u => u.isFlying) && cardId === 'arrows') score += 35;
                        } else if (card.type === 'Building') {
                            if (cardId === 'cannon') score += 25;
                        }
                    }

                    // Support: if we have units pushing
                    if (aiUnits.length > 2) {
                        if (cardId === 'rage') score += 30;
                        if (cardId === 'heal') score += 20;
                    }

                    // Randomness
                    score += Math.random() * 10;

                    if (score > bestScore) {
                        bestScore = score;
                        bestCardId = cardId;
                    }
                }

                if (!bestCardId) return;

                const card = allCards[bestCardId];
                const handIndex = aiTeammateHandCards.indexOf(bestCardId);

                // Choose placement
                let targetX, targetY;
                if (card.type === 'Spell') {
                    // Target enemy units or towers
                    const target = playerUnits.length > 0 ? playerUnits[0] : playerTowers[0];
                    if (target) {
                        targetX = target.x;
                        targetY = target.y;
                    } else {
                        return;
                    }
                } else if (card.type === 'Building') {
                    // Place near our king tower
                    targetX = WIDTH / 2 + (Math.random() - 0.5) * 100;
                    targetY = 50 + Math.random() * 50;
                } else {
                    // Units: spawn near river, prefer lanes with enemy units
                    const lane = playerUnits.length > 0 ? (playerUnits[0].x < WIDTH / 2 ? LANE_LEFT_X : LANE_RIGHT_X) : (Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X);
                    targetX = lane + (Math.random() - 0.5) * 40;
                    targetY = RIVER_Y + 20 + Math.random() * 80;
                }

                if (card.type === 'Spell' || checkPlacement(targetX, targetY, card.placementRadius || 20, card.type)) {
                    const level = 15;
                    if (card.type === 'Spell') {
                        // Handle spells
                        if (bestCardId === 'poison') {
                            const s = card.stats[level];
                            gameObjects.push(new PoisonSpell(targetX, targetY, 'player', s.damagePerSecond, card.radius, s.duration));
                        } else if (bestCardId === 'rage') {
                            const s = card.stats[level];
                            gameObjects.push(new AngerSpell(targetX, targetY, 'player', card.radius, s.duration));
                        } else if (bestCardId === 'arrows' || bestCardId === 'fireball') {
                            const s = card.stats[level];
                            gameObjects.push(new Projectile(targetX, targetY, null, 'player', s.damage, card.radius));
                        }
                    } else if (card.type === 'Building') {
                        const newBuilding = new card.unitClass(targetX, targetY, 'player', level);
                        if (newBuilding instanceof GameObject) gameObjects.push(newBuilding);
                    } else {
                        const newUnit = new card.unitClass(targetX, targetY, 'player', level);
                        if (newUnit instanceof GameObject) gameObjects.push(newUnit);
                    }

                    showTeammatePlacement(targetX, targetY, card.emoji);
                    aiTeammateHandCards.splice(handIndex, 1);
                    aiTeammateDiscardPile.push(bestCardId); // Add played card to discard pile
                    // Add NEXT card to hand (like player system)
                    if (aiTeammateNextCard) {
                        aiTeammateHandCards.push(aiTeammateNextCard);
                        aiTeammateNextCard = null;
                    }
                    // Draw new NEXT card from remaining deck
                    if (aiTeammateDeck.length > 0) {
                        aiTeammateNextCard = aiTeammateDeck.pop();
                    } else if (aiTeammateDiscardPile.length > 0) {
                        // Recycle discard pile when deck is empty
                        aiTeammateDeck = shuffleDeck(aiTeammateDiscardPile);
                        aiTeammateDiscardPile = [];
                        if (aiTeammateDeck.length > 0) {
                            aiTeammateNextCard = aiTeammateDeck.pop();
                        }
                    }
                    aiTeammateElixir -= card.cost; // Subtract elixir FIRST
                    updateAITeammateUI(); // Then update UI to show correct elixir
                }
            }

            function showTeammatePlacement(x, y, emoji) {
                const indicator = document.createElement('div');
                indicator.className = 'absolute text-2xl pointer-events-none';
                indicator.style.left = `${x - 12}px`;
                indicator.style.top = `${y - 12}px`;
                indicator.textContent = emoji;
                indicator.style.transition = 'opacity 0.5s';
                gameContainer.appendChild(indicator);
                setTimeout(() => {
                    indicator.style.opacity = '0';
                    setTimeout(() => indicator.remove(), 500);
                }, 100);
            }

            function updateTimerAndElixir() {
                const totalSeconds = Math.max(0, Math.floor(gameTimer / 60));
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                if (isOvertime) {
                    timerDisplay.classList.add('text-red-500');
                    currentElixirRate = (gameTimer < 60 * 60) ? BASE_ELIXIR_REGEN_RATE * 3 : BASE_ELIXIR_REGEN_RATE * 2;
                } else {
                    timerDisplay.classList.remove('text-red-500');
                    currentElixirRate = (gameTimer < 60 * 60) ? BASE_ELIXIR_REGEN_RATE * 2 : BASE_ELIXIR_REGEN_RATE;
                }
                if (playerElixir < MAX_ELIXIR) {
                    playerElixir += currentElixirRate;
                    playerElixir = Math.min(playerElixir, MAX_ELIXIR);
                }
                if (aiElixir < MAX_ELIXIR) {
                    aiElixir += currentElixirRate;
                    aiElixir = Math.min(aiElixir, MAX_ELIXIR);
                }
                // Second AI elixir (2v2 only)
                if (gameMode === '2v2' && ai2Elixir < MAX_ELIXIR) {
                    ai2Elixir += currentElixirRate;
                    ai2Elixir = Math.min(ai2Elixir, MAX_ELIXIR);
                }
                // AI teammate elixir (2v2 only)
                if (gameMode === '2v2' && is2v2AITeammate && aiTeammateElixir < MAX_ELIXIR) {
                    aiTeammateElixir += currentElixirRate;
                    aiTeammateElixir = Math.min(aiTeammateElixir, MAX_ELIXIR);
                    updateAITeammateUI(); // Update UI continuously when elixir is gained
                }
            }
            
            // NEW: Update function to check tower status
            function checkTowerStatus() {
                const aiLeft = gameObjects.find(t => t.team === 'ai' && !t.isKing && t.x < WIDTH / 2);
                const aiRight = gameObjects.find(t => t.team === 'ai' && !t.isKing && t.x > WIDTH / 2);
                
                if (aiLeft && aiLeft.health <= 0 && !aiLeftTowerDestroyed) {
                    aiLeftTowerDestroyed = true;
                    if (selectedSpawningUnit) updatePlacementOverlay();
                }
                if (aiRight && aiRight.health <= 0 && !aiRightTowerDestroyed) {
                    aiRightTowerDestroyed = true;
                    if (selectedSpawningUnit) updatePlacementOverlay();
                }
                
                // Can check player towers here too if AI gets spawn zones
            }
            
            // NEW: Update the clip-path of the red overlay
            function updatePlacementOverlay() {
                // Use M (move) and L (line) path commands
                // `M x y L x y L x y Z` creates a closed shape
                let pathData = "";
                const H = HEIGHT; // 500
                const W = WIDTH; // 400
                const R = RIVER_Y; // 250
                const F = AI_SPAWN_ZONE_LIMIT; // 150 (500 * 0.3)
                const M = W / 2; // 200 (mid-line)

                if (!aiLeftTowerDestroyed && !aiRightTowerDestroyed) {
                    // Block full top half
                    pathData = `M0 0 L${W} 0 L${W} ${R} L0 ${R} Z`;
                } else if (aiLeftTowerDestroyed && !aiRightTowerDestroyed) {
                    // Block top-right quarter AND far-left
                    pathData = `M${M} 0 L${W} 0 L${W} ${R} L${M} ${R} Z M0 0 L${M} 0 L${M} ${F} L0 ${F} Z`;
                } else if (!aiLeftTowerDestroyed && aiRightTowerDestroyed) {
                    // Block top-left quarter AND far-right
                    pathData = `M0 0 L${M} 0 L${M} ${R} L0 ${R} Z M${M} 0 L${W} 0 L${W} ${F} L${M} ${F} Z`;
                } else {
                    // Block only far-left AND far-right
                    pathData = `M0 0 L${M} 0 L${M} ${F} L0 ${F} Z M${M} 0 L${W} 0 L${W} ${F} L${M} ${F} Z`;
                }
                
                placementOverlay.style.clipPath = `path("${pathData}")`;
            }


            function checkGameOver() {
                const playerKing = gameObjects.find(t => t.team === 'player' && t.isKing);
                const aiKing = gameObjects.find(t => t.team === 'ai' && t.isKing);
                if (gameRunning && aiKing && aiKing.health <= 0) { showWinScreen(); }
                else if (gameRunning && playerKing && playerKing.health <= 0) { showLoseScreen(); }
            }
            
            function checkOvertime() { // RENAMED
                if (!gameRunning) return;
                const getTowerCount = (team) => { return gameObjects.filter(obj => obj.team === team && (obj instanceof Tower) && obj.health > 0).length; };
                const playerTowers = getTowerCount('player');
                const aiTowers = getTowerCount('ai');
                if (playerTowers === aiTowers) {
                    isOvertime = true;
                    overtimeInitialPlayerTowers = playerTowers; // NEW: Store initial counts
                    overtimeInitialAiTowers = aiTowers; // NEW: Store initial counts
                    gameTimer = OVERTIME_TIME;
                    currentElixirRate = BASE_ELIXIR_REGEN_RATE * 2;
                } else if (playerTowers > aiTowers) {
                    showWinScreen();
                } else {
                    showLoseScreen();
                }
            }

            function startTieBreaker() {
                if (!gameRunning) return;
                gameRunning = true; isTieBreaker = true; gameObjects = gameObjects.filter(obj => (obj instanceof Tower));
                messageText.textContent = 'TIEBREAKER!';
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'none'; // FIX: Hide menu button
                setTimeout(() => { if (isTieBreaker) messageOverlay.style.display = 'none'; }, 2000);
            }

            function tieBreakerLoop() {
                tieBreakerTick--;
                if (tieBreakerTick <= 0) {
                    tieBreakerTick = 10;
                    let playerKing = null;
                    let aiKing = null;
                    for (const obj of gameObjects) {
                        if (obj instanceof Tower) { obj.health -= 20; }
                        if (obj.isKing && obj.team === 'player') playerKing = obj;
                        if (obj.isKing && obj.team === 'ai') aiKing = obj;
                    }
                    if (aiKing && aiKing.health <= 0 && playerKing && playerKing.health > 0) {
                        isTieBreaker = false;
                        showWinScreen();
                    } else if (playerKing && playerKing.health <= 0) {
                        isTieBreaker = false;
                        showLoseScreen();
                    }
                }
                ctx.clearRect(0, 0, WIDTH, HEIGHT); drawArena(); gameObjects.forEach(obj => obj.draw());
                if (isTieBreaker) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }

            async function showWinScreen() {
                if (!gameRunning) return;
                gameRunning = false;
                isOvertime = false; // NEW: Stop overtime check
                isTieBreaker = false;
                cancelAnimationFrame(gameLoopId);
                trophies += 30;
                updateArena();
                trophyDisplay.textContent = `üèÜ ${trophies}`;
                gold += 50;
                goldDisplay.textContent = `üí∞ ${gold}`;
                if (trophyChests.length < 4) {
                    trophyChests.push({ id: 'wood', openTime: 0 });
                    renderChests();
                }
                messageText.textContent = gameMode === '2v2' ? 'You Win!' : 'You Win! (+30 üèÜ, +50 üí∞, üì¶)';
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                if (gameMode !== '2v2') {
                    trophies += 30;
                    gold += 50;
                    trophyChests.push({ id: 'wood', openTime: 0 });
                    renderChests();
                }
                await saveUserData();
            }

            async function showLoseScreen(message = 'You Lose!') {
                if (!gameRunning) return;
                gameRunning = false;
                isOvertime = false; // NEW: Stop overtime check
                isTieBreaker = false;
                cancelAnimationFrame(gameLoopId);
                // Calculate minimum trophy floor for current arena
                let minTrophyFloor = 0;
                let lossAmount = 0;
                if (gameMode !== '2v2') {
                    for (const floor in arenaFloors) {
                        if (trophies >= parseInt(floor)) {
                            minTrophyFloor = parseInt(floor);
                        }
                    }
                    lossAmount = 30;
                    if (trophies - lossAmount < minTrophyFloor) {
                        lossAmount = trophies - minTrophyFloor;
                    }
                    if (lossAmount < 0) lossAmount = 0;
                    trophies = Math.max(minTrophyFloor, trophies - lossAmount);
                    updateArena();
                    trophyDisplay.textContent = `üèÜ ${trophies}`;
                }
                messageText.textContent = gameMode === '2v2' ? 'You Lose!' : `${message} (-${lossAmount} üèÜ)`;
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                await saveUserData();
            }

            function gameLoop(timestamp) {
                if (isTieBreaker) {
                    tieBreakerLoop();
                    return;
                }
                if (!gameRunning) {
                    cancelAnimationFrame(gameLoopId);
                    return;
                }
                const deltaTime = (timestamp - lastTime) / 1000;
                lastTime = timestamp;
                gameTimer--;
                updateTimerAndElixir();
                aiThinkTimer--;
                if (aiThinkTimer <= 0) {
                    runAI();
                    aiThinkTimer = 30 + Math.random() * 30; // Think every 0.5-1s
                }
                // Second AI (2v2 only)
                if (gameMode === '2v2') {
                    ai2ThinkTimer--;
                    if (ai2ThinkTimer <= 0) {
                        runAI2();
                        ai2ThinkTimer = 30 + Math.random() * 30;
                    }
                }
                // AI teammate (2v2 only)
                if (gameMode === '2v2' && is2v2AITeammate) {
                    runAITeammate();
                }
                
                // Update objects
                gameObjects.forEach(obj => obj.update());
                
                // NEW: Sudden Death Overtime Check
                if (gameRunning && isOvertime) {
                    const playerTowers = gameObjects.filter(obj => obj.team === 'player' && (obj instanceof Tower) && obj.health > 0).length;
                    const aiTowers = gameObjects.filter(obj => obj.team === 'ai' && (obj instanceof Tower) && obj.health > 0).length;

                    if (playerTowers < overtimeInitialPlayerTowers) {
                        // Player lost a tower
                        showLoseScreen("Sudden Death!");
                    } else if (aiTowers < overtimeInitialAiTowers) {
                        // AI lost a tower
                        showWinScreen(); // showWinScreen already handles stopping the game
                    }
                }
                
                // Check tower status for spawn zones
                checkTowerStatus();
                
                // Filter dead objects (and handle special death behavior)
                const newGameObjects = [];
                for (const obj of gameObjects) {
                    if (obj.health > 0) {
                        newGameObjects.push(obj);
                        continue;
                    }

                    // Handle units/projectiles/spells
                    if (obj instanceof Unit || obj instanceof Projectile || obj instanceof Spell || obj instanceof PoisonSpell || obj instanceof AngerSpell || obj instanceof FreezeEffect || obj instanceof HealEffect || obj instanceof ExplosionEffect || obj instanceof VoidTrapEffect || obj instanceof ChaosOrbEffect) {
                        // Special case: Battle Ram needs to spawn barbs
                        if (obj instanceof BattleRam && !obj.didHit) {
                            obj.spawnBarbs();
                        }
                        // Special case: Stone Giant splits into minis on death
                        if (obj instanceof StoneGiant && !obj.didSpawnMinis) {
                            console.log('Cleanup: StoneGiant died at', obj.x, obj.y, 'spawning minis');
                            obj.spawnMinis();
                        }
                        continue; // Dead units/effects are not kept
                    }

                    // Handle towers/buildings
                    if (obj instanceof Tower || obj instanceof Building) {
                        if (obj.isKing) {
                            checkGameOver();
                            newGameObjects.push(obj);
                            continue;
                        }
                        if (obj.dyingAnimationTimer === 0) { obj.dyingAnimationTimer = 30; }
                        obj.dyingAnimationTimer--;
                        if (obj.dyingAnimationTimer > 0) {
                            newGameObjects.push(obj);
                        }
                        continue;
                    }
                    // Everything else dead is dropped
                }
                gameObjects = newGameObjects;
                
                updateCardUI();
                if (gameTimer <= 0) {
                    if (isOvertime) { startTieBreaker(); }
                    else { checkOvertime(); }
                }
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                drawArena();
                gameObjects.forEach(obj => obj.draw());
                if (gameRunning) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }

            function demoGameLoop(timestamp) {
                if (!isDemoMode) {
                    cancelAnimationFrame(gameLoopId);
                    return;
                }
                
                const demoFadeOverlay = document.getElementById('demoFadeOverlay');

                // Handle Fading
                if (demoFadingOut) {
                    demoFadeTimer--;
                    let fadeProgress = 1 - (demoFadeTimer / DEMO_FADE_TIME);
                    if (demoFadeOverlay) demoFadeOverlay.style.opacity = fadeProgress;

                    if (demoFadeTimer <= 0) {
                        // Reset
                        initGame(); // Reset the board and decks
                        demoLoopTimer = DEMO_LOOP_TIME;
                        demoFadingOut = false;
                        demoFadeTimer = DEMO_FADE_TIME; // Start fade-in
                    }
                } else if (demoFadeTimer > 0) {
                    // Fading IN
                    demoFadeTimer--;
                    let fadeProgress = demoFadeTimer / DEMO_FADE_TIME;
                    if (demoFadeOverlay) demoFadeOverlay.style.opacity = fadeProgress;
                } else {
                    // Not fading, run game
                    demoLoopTimer--;
                    if (demoLoopTimer <= 0) {
                        demoFadingOut = true;
                        demoFadeTimer = DEMO_FADE_TIME;
                    }

                    // Use existing gameTimer to run elixir etc.
                    gameTimer--; 
                    updateTimerAndElixir();
                    aiThinkTimer--;
                    
                    if (aiThinkTimer <= 0) {
                        runAI(); // Existing AI
                        demoRunPlayerAI(); // New Player AI
                        aiThinkTimer = 30 + Math.random() * 30; // Think fast
                    }
                    
                    // Update objects
                    gameObjects.forEach(obj => obj.update());
                    
                    // Filter dead objects (simplified, no win/lose)
                    gameObjects = gameObjects.filter(obj => {
                        if (obj.health > 0) return true;
                        if (obj instanceof Unit || obj instanceof Projectile || obj instanceof Spell || obj instanceof PoisonSpell || obj instanceof VoidTrapEffect || obj instanceof ChaosOrbEffect) { 
                            if (obj instanceof BattleRam && !obj.didHit) obj.spawnBarbs();
                            return false; 
                        }
                        if (obj instanceof Tower || obj instanceof Building) {
                            if (obj.isKing) { obj.health = obj.maxHealth; return true; } // Make kings invincible
                            if (obj.dyingAnimationTimer === 0) obj.dyingAnimationTimer = 30;
                            obj.dyingAnimationTimer--;
                            return obj.dyingAnimationTimer > 0;
                        }
                        return false;
                    });
                }
                
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                drawArena();
                gameObjects.forEach(obj => obj.draw());
                // NEW: Draw zap chains after all objects
                gameObjects.forEach(obj => {
                    if (obj instanceof ZapSpirit && obj.zapChain && obj.zapChain.length > 1) {
                        ctx.strokeStyle = '#fbbf24';
                        ctx.lineWidth = 3;
                        for (let i = 1; i < obj.zapChain.length; i++) {
                            const prev = obj.zapChain[i - 1];
                            const curr = obj.zapChain[i];
                            if (prev && curr && prev.health > 0 && curr.health > 0) {
                                ctx.beginPath();
                                ctx.moveTo(prev.x, prev.y);
                                ctx.lineTo(curr.x, curr.y);
                                ctx.stroke();
                            }
                        }
                    }
                });
                
                gameLoopId = requestAnimationFrame(demoGameLoop);
            }
            // --- END MOVED FUNCTIONS ---


            // ==============================================
            // INITIALIZATION
            // ==============================================
            
            // This MUST be called after all classes are defined
            initCardSystem();

            // --- BUG FIX: Start demo mode *after* classes and cards are defined ---
            if (isDemoMode) {
                initGame();
                lastTime = performance.now(); // ADDED: Need this for gameLoop
                gameLoopId = requestAnimationFrame(demoGameLoop);
                return; // Stop the rest of onload
            }
            // --- END BUG FIX ---


            // ==============================================
            // EVENT LISTENERS
            // ==============================================
            
            // --- REFERENCEERROR FIX: All function definitions removed from here ---
            
            // --- Event Listeners ---
            
            function getCanvasClickPos(e) {
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) { 
                    clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; 
                } else if (e.changedTouches && e.changedTouches.length > 0) { 
                    clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; 
                } else { 
                    clientX = e.clientX; clientY = e.clientY; 
                }
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                return { x, y };
            }

            function checkPlacement(x, y, radius, cardType) {
                // Check if in allowed zone
                let inAllowedZone = false;
                if (y > RIVER_Y) {
                    inAllowedZone = true; // Always allowed in player's base
                } else if (y > AI_SPAWN_ZONE_LIMIT) { // Can't place in "far end"
                    // Check enemy territory
                    if (aiLeftTowerDestroyed && x < WIDTH / 2) inAllowedZone = true;
                    if (aiRightTowerDestroyed && x > WIDTH / 2) inAllowedZone = true;
                }
                if (!inAllowedZone) return false;

                // Check for collision
                for (const obj of gameObjects) {
                    // NEW: Allow placing on troops, not buildings
                    if (obj instanceof Tower || obj instanceof Building) {
                        const dist = getDistance({x: x, y: y}, obj);
                        if (dist < radius + obj.radius) { return false; }
                    }
                }
                
                return true;
            }

            function handleDragMove(e) {
                if (!selectedSpawningUnit) return;
                e.preventDefault();
                let pos = (e.touches && e.touches[0]) ? e.touches[0] : e;
                
                // NEW: Drag sensitivity logic
                if (!isDragging) {
                    const dx = Math.abs(pos.clientX - dragStartX);
                    const dy = Math.abs(pos.clientY - dragStartY);
                    if (dx > DRAG_SENSITIVITY || dy > DRAG_SENSITIVITY) {
                        isDragging = true;
                    }
                }
                
                // NEW: Only move indicator if mouse is over canvas
                const rect = canvas.getBoundingClientRect();
                const isOverCanvas = (pos.clientX >= rect.left && pos.clientX <= rect.right &&
                                         pos.clientY >= rect.top && pos.clientY <= rect.bottom);
                
                if (isOverCanvas) {
                    placementIndicator.style.display = 'block';
                    movePlacementIndicator(pos);
                } else {
                    placementIndicator.style.display = 'none'; // Hide if off-canvas
                }
            }

            function movePlacementIndicator(e) {
                if (!selectedSpawningUnit) return;
                
                const { x, y } = getCanvasClickPos(e);
                const clampedX = Math.max(0, Math.min(WIDTH, x));
                const clampedY = Math.max(0, Math.min(HEIGHT, y));
                let radius = isSpawningSpell ? spellRadius : placementRadius;
                
                placementIndicator.style.left = `${clampedX}px`;
                placementIndicator.style.top = `${clampedY}px`;
                
                if (isSpawningSpell) {
                    canPlace = true; // Spells can be placed anywhere
                } else {
                    canPlace = checkPlacement(clampedX, clampedY, placementRadius, selectedSpawningUnit.type);
                }
                placementIndicator.classList.toggle('cant-place', !canPlace);
            }
            
            // Re-bind mouse/touch move to window to allow dragging off canvas
            window.addEventListener('mousemove', handleDragMove);
            window.addEventListener('touchmove', handleDragMove, { passive: false });


            function handleDragEnd(e) {
                if (!selectedSpawningUnit || !gameRunning) {
                    cancelPlacement();
                    return;
                }

                // Check if mouse is over canvas
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX; clientY = e.clientY;
                }
                const isOverCanvas = (clientX >= rect.left && clientX <= rect.right &&
                                         clientY >= rect.top && clientY <= rect.bottom);
                
                // --- CLICK-TO-PLACE FIX ---
                if (!isDragging) {
                    // This was a "click"
                    if (isOverCanvas) {
                        // This is a "click-to-place"
                        // canPlace is already set by the last handleDragMove
                    } else {
                        // This was a click off-canvas, or just releasing the mouse from the card
                        // Check if the click-up was on a card
                        if (e.target && e.target.closest('.card-ui')) {
                            // This was the initial click-up on the card. Do nothing.
                            return; 
                        }
                        // Otherwise, it was a click off-canvas to cancel.
                        cancelPlacement();
                        return;
                    }
                } else {
                    // This was a "drag-and-drop"
                    if (!isOverCanvas) {
                        // Dragged off-canvas to cancel
                        cancelPlacement();
                        return;
                    }
                    // canPlace is already set
                }
                // --- END FIX ---
                
                if (!canPlace) {
                    console.log("Cannot spawn there!");
                    cancelPlacement();
                    return;
                }
                
                const { x, y } = getCanvasClickPos(e);
                const clampedX = Math.max(0, Math.min(WIDTH, x));
                const clampedY = Math.max(0, Math.min(HEIGHT, y));
                
                const card = allCards[selectedSpawningUnit.id];
                const level = (gameMode === '2v2') ? 15 : (cardCollection[selectedSpawningUnit.id] ? cardCollection[selectedSpawningUnit.id].level : 1);
                
                if (card.type === 'Spell') {
                    if (selectedSpawningUnit.id === 'poison') { // NEW
                        const s = card.stats[level];
                        gameObjects.push(new PoisonSpell(clampedX, clampedY, 'player', s.damagePerSecond, card.radius, s.duration));
                    } else if (selectedSpawningUnit.id === 'anger') { // NEW
                        const s = card.stats[level];
                        gameObjects.push(new AngerSpell(clampedX, clampedY, 'player', card.radius, s.duration));
                    } else if (selectedSpawningUnit.id === 'voidTrap') { // NEW
                        const damage = card.stats[level].damage;
                        gameObjects.push(new VoidTrapEffect(clampedX, clampedY, 'player', card.radius, damage));
                    } else if (selectedSpawningUnit.id === 'chaosOrb') { // NEW
                        const damage = card.stats[level].damage;
                        gameObjects.push(new ChaosOrbEffect(clampedX, clampedY, 'player', card.radius, damage));
                    } else {
                        const damage = card.stats[level].damage;
                        gameObjects.push(new Spell(clampedX, clampedY, 'player', damage, card.radius, card.emoji));
                    }
                } else if (card.type === 'Spirit') { // NEW: Handle spirits
                    const newUnit = new card.unitClass(clampedX, clampedY, 'player', level);
                    if (newUnit instanceof GameObject) {
                        gameObjects.push(newUnit);
                    }
                } else {
                    const newUnit = new card.unitClass(clampedX, clampedY, 'player', level);
                    // --- TYPEERROR FIX ---
                    // Check if the returned object is an actual game object (for single units/buildings)
                    // If it's a spawner, it's not a GameObject and shouldn't be pushed.
                    if (newUnit instanceof GameObject) {
                        gameObjects.push(newUnit);
                    }
                }
                
                playCard(selectedSpawningUnit.id, selectedSpawningUnit.handIndex);
                cancelPlacement();
            }

            // Use mouseup/touchend on the *window* to catch drags released off-canvas
            window.addEventListener('mouseup', handleDragEnd);
            window.addEventListener('touchend', handleDragEnd, { passive: false });

            // --- CLICK-TO-PLACE FIX: This listener is now removed ---
            // canvas.addEventListener('click', (e) => {
            //     if (selectedSpawningUnit && !isDragging) {
            //         handleDragEnd(e);
            //     }
            // });

            cardInfoCloseBtn.addEventListener('click', closeModal);
            
            // --- Init App ---
            // initCardSystem(); // <-- MOVED
            onAuthStateChanged(auth, handleAuth); // Wait for user login

            // --- NEW: Intro Animation Timer ---
            setTimeout(() => {
                // Only switch if we are still on the intro screen
                // (e.g., user didn't get logged in by Firebase auto-login first)
                if (currentScreen === 'intro') { 
                    showScreen('login');
                }
            }, 2500); // 2.5 second intro
            // --- END: Intro Animation ---
        } // Close window.onload function
    </script>

    <!-- 2v2 Teammate Choice Modal -->
    <div id="teammateChoiceModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg p-6 w-80">
            <h2 class="text-2xl font-bold text-center mb-4">Choose Teammate</h2>
            <button id="aiTeammateBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-bold mb-3 transition">
                Play with AI Teammate
            </button>
            <button id="friendTeammateBtn" class="w-full bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-bold mb-3 transition">
                Play with Friend
            </button>
            <button id="cancelTeammateBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-lg font-bold transition">
                Cancel
            </button>
        </div>
    </div>

    <!-- 2v2 Friend Code Modal -->
    <div id="friendCodeModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg p-6 w-80">
            <h2 class="text-2xl font-bold text-center mb-4">Play with Friend</h2>
            <button id="createCodeBtn" class="w-full bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-bold mb-3 transition">
                Create Code
            </button>
            <button id="joinCodeBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-bold mb-3 transition">
                Join with Code
            </button>
            <button id="cancelFriendBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-lg font-bold transition">
                Cancel
            </button>
        </div>
    </div>

    <!-- 2v2 Create Code Modal -->
    <div id="createCodeModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg p-6 w-80">
            <h2 class="text-2xl font-bold text-center mb-4">Lobby Code</h2>
            <div class="bg-gray-700 p-4 rounded-lg mb-4">
                <p class="text-3xl font-mono text-center text-green-400" id="generatedCode">-----</p>
            </div>
            <p class="text-sm text-gray-300 mb-4">Share this code with your friend to join.</p>
            <p class="text-sm text-yellow-300 mb-4">Waiting for teammate...</p>
            <button id="cancelCreateBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-lg font-bold transition">
                Cancel
            </button>
        </div>
    </div>

    <!-- 2v2 Join Code Modal -->
    <div id="joinCodeModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg p-6 w-80">
            <h2 class="text-2xl font-bold text-center mb-4">Enter Lobby Code</h2>
            <input type="text" id="codeInput" maxlength="5" placeholder="5-digit code" class="w-full bg-gray-700 text-white px-4 py-3 rounded-lg text-center text-2xl font-mono mb-4">
            <button id="confirmJoinBtn" class="w-full bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-bold mb-3 transition">
                Join
            </button>
            <button id="cancelJoinBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-lg font-bold transition">
                Cancel
            </button>
        </div>
    </div>
</div>
</body>
</html>
