
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Royale</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Google Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script>
        window.isLocalFile = window.location.protocol === 'file:';
        // Debug menu enabled for this session as requested
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            touch-action: none;
            background-color: #111827;
            color: white;
        }
        #bgCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }
        h1, h2, h3 {
            text-shadow: 2px 2px 0px #000, 0 0 10px rgba(0,0,0,0.5);
            letter-spacing: 1px;
        }
        /* Button Shine Effect */
        .btn-shine {
            position: relative;
            overflow: hidden;
        }
        .btn-shine::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(to right, transparent, rgba(255,255,255,0.4), transparent);
            transform: skewX(-20deg);
            transition: none;
        }
        .btn-shine:hover::after {
            left: 150%;
            transition: 0.6s ease-in-out;
        }
        /* Button Ripple Effect */
        .ripple-btn {
            position: absolute;
            border-radius: 50%;
            transform: scale(0);
            animation: rippleBtn 0.6s linear;
            background-color: rgba(255, 255, 255, 0.4);
            pointer-events: none;
        }
        @keyframes rippleBtn {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }
        @keyframes particleMove {
            from { background-position: 0 0, 12px 12px, 0 0, 0 0; }
            to { background-position: 20px 20px, 30px 30px, 0 0, 0 0; }
        }
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .screen {
            padding-bottom: 6rem; /* Space for fixed nav */
            position: absolute; /* Fix for stacking */
            top: 0; left: 0; right: 0; bottom: 0;
            background: transparent; /* Allow body bg to show */
        }
        .screen.active {
            z-index: 10;
            /* Animation handled by JS class toggle */
        }
        .screen.swipe-right {
            animation: slideInRight 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        }
        .screen.swipe-left {
            animation: slideInLeft 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        }
        .screen.fade-in {
            animation: fadeIn 0.4s ease-out;
        }
        /* Nav Active State (Replaces Highlight Box) */
        .nav-btn.active-nav {
            border: 2px solid #facc15;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            box-shadow: 0 0 15px rgba(250, 204, 21, 0.2);
        }
        /* Improved Chest Click Area */
        #chestClickArea {
            outline: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        /* Reward Pop Animation */
        @keyframes rewardPop {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .reward-item {
            animation: rewardPop 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            box-shadow: inset 0 3px 6px rgba(0,0,0,0.5);
            border: 2px solid #374151;
            background-color: #374151;
            border-radius: 8px;
        }
        @keyframes shakeBox {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }
        .shake-anim {
            animation: shakeBox 0.2s ease-in-out;
        }
        .nav-btn {
            position: relative;
            z-index: 1;
        }
        /* Ripple Effect */
        .ripple {
            position: absolute;
            border-radius: 50%;
            transform: scale(0);
            animation: ripple 0.6s linear;
            background-color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
            z-index: 9999;
        }
        @keyframes ripple {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }
        /* Floating Emoji */
        @keyframes floatRotate {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }
        /* Click Pulse Effect */
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7); }
            100% { box-shadow: 0 0 0 15px rgba(255, 255, 255, 0); }
        }
        .btn-pulse-anim {
            animation: pulse-ring 0.4s ease-out;
        }
        #arenaEmoji {
            display: inline-block;
            animation: floatRotate 6s ease-in-out infinite;
        }
        .ui-text-effect {
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            font-weight: 900;
            letter-spacing: 0.5px;
        }
        /* Enhanced Button Hovers */
        .login-btn, .arena-btn, .modal-btn, #battleButton, .debug-btn, #navBtnMenu, #navBtnDeck, #navBtnTower, #navBtnDebug, 
        #saveDataOverlay button, #loadDataOverlay button, #updateLogOverlay button, #chestOpenOverlay button {
            overflow: hidden;
            position: relative;
        }
        .login-btn:hover, .arena-btn:hover, .modal-btn:hover, #battleButton:hover, #saveDataOverlay button:hover, 
        #loadDataOverlay button:hover, #updateLogOverlay button:hover, #chestOpenOverlay button:hover {
            transform: scale(1.05);
            filter: brightness(1.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
        }
        canvas {
            background-color: #f1f5f9; /* Snow White */
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            display: block;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            /* cursor: pointer; */ /* REMOVED - We use custom cursor logic */
            transition: background-color 0.5s ease; /* For arena theme change */
        }
        /* Arena Themes */
        canvas.arena-1 { background-color: #15803d; }
        canvas.arena-2 { background-color: #6abf82; }
        canvas.arena-3 { 
            background-color: #4a4a4a;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
        }
        /* NEW ARENA 4 STYLE */
        canvas.arena-4 { 
            background-color: #ca8a04; /* yellow-600 */
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
        }
        /* NEW ARENA 5 STYLE */
        canvas.arena-5 { 
            background-color: #3730a3; /* indigo-800 */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
        }
        /* NEW ARENA 6 STYLE */
        canvas.arena-6 { 
            background-color: #7c2d12; /* brown-900 */
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
        }

        /* NEW ARENA 7 STYLE */
        canvas.arena-7 {
            background-color: #3b0764; /* deep purple */
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.04) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.04) 1px, transparent 1px);
        }
        /* NEW ARENA 8 STYLE */
        canvas.arena-8 {
            background-color: #1f1f3d; /* dark navy/chaos */
            background-image:
                linear-gradient(rgba(147, 51, 234, 0.08) 1px, transparent 1px),
                linear-gradient(90deg, rgba(147, 51, 234, 0.08) 1px, transparent 1px);
        }
        /* NEW ARENA 9 STYLE */
        canvas.arena-9 {
            background-color: #0f172a; /* slate-900 */
            background-image:
                radial-gradient(#334155 1px, transparent 1px);
            background-size: 30px 30px;
        }
        /* NEW ARENA 10 STYLE */
        canvas.arena-10 {
            background-color: #3f0606; /* dark red/chaos realm */
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
        }
        /* CHRISTMAS THEME */
        canvas.christmas {
            background-color: #ffffff; /* Pure White Snow */
            background-image:
                radial-gradient(#cbd5e1 2px, transparent 2px); /* Subtle snowflakes */
            background-size: 24px 24px;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }
        #messageOverlay, #chestOpenOverlay, #debugPasswordOverlay, #saveDataOverlay, #loadDataOverlay, #updateLogOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: none;
            /* Update Log Modal Card Frame */
            #updateLogOverlay > div {
                background: #374151;
                border-radius: 16px;
                border: 4px solid #fde047;
                box-shadow: 0 4px 24px 0 rgba(0,0,0,0.4);
                padding: 2rem 1.5rem;
                max-width: 400px;
                width: 100%;
                margin: 0 auto;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            color: white;
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000, 0 0 10px rgba(0,0,0,0.5);
            text-align: center;
            border-radius: 8px;
            z-index: 60;
            padding: 1rem;
        }
        /* ENHANCED BUTTONS (3D Effect) */
        #messageOverlay button, #chestOpenOverlay button, .login-btn, .debug-btn, #debugPasswordOverlay button,
        #saveDataOverlay button, #loadDataOverlay button, #updateLogOverlay button, .arena-btn, .modal-btn, .mode-tab {
            font-size: 1rem;
            font-weight: 800;
            padding: 0.8rem 1.5rem;
            margin-top: 15px;
            background: linear-gradient(to bottom, #4f46e5, #4338ca);
            color: white;
            border: none;
            border-bottom: 4px solid #312e81;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            width: 80%;
            max-width: 300px;
            position: relative;
        }
        #messageOverlay button:active, #chestOpenOverlay button:active, .login-btn:active, .debug-btn:active, 
        #saveDataOverlay button:active, .arena-btn:active, .modal-btn:active, .mode-tab:active {
            transform: translateY(4px);
            border-bottom-width: 0px;
            margin-bottom: 4px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        #messageOverlay button:hover, .login-btn:hover, .arena-btn:hover {
            filter: brightness(1.1);
        }

        /* Color Variants */
        .login-btn.google { background: linear-gradient(to bottom, #dc2626, #b91c1c); border-bottom-color: #7f1d1d; }
        .login-btn.guest { background: linear-gradient(to bottom, #6b7280, #4b5563); border-bottom-color: #374151; }
        .cancel-btn { background: linear-gradient(to bottom, #ef4444, #dc2626) !important; border-bottom-color: #991b1b !important; }
        .debug-btn { background: linear-gradient(to bottom, #2563eb, #1d4ed8); border-bottom-color: #1e3a8a; }
        
        /* Battle Button Special Style */
        #battleButton {
            background: linear-gradient(to bottom, #ef4444, #b91c1c);
            border-bottom: 6px solid #7f1d1d;
            font-size: 2rem;
            border-radius: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.4);
        }
        #battleButton:disabled {
            background: #4b5563;
            border-bottom-color: #374151;
            box-shadow: none;
            transform: none !important;
        }
        /* Debug Password Input */
        #debugPasswordInput, #loadKeyInput {
            font-size: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            border: 2px solid #6b7280;
            background-color: #1f2937;
            color: white;
            margin-top: 20px;
            width: 80%;
            max-width: 300px;
            text-align: center;
        }
        #debugPasswordOverlay .cancel-btn, #saveDataOverlay .cancel-btn, #loadDataOverlay .cancel-btn {
            background-color: #dc2626; /* red-600 */
        }
        #debugPasswordOverlay .cancel-btn:hover, #saveDataOverlay .cancel-btn:hover, #loadDataOverlay .cancel-btn:hover {
            background-color: #b91c1c; /* red-700 */
        }
        /* Save Key Text Area */
        #saveKeyOutput {
            font-size: 0.9rem;
            padding: 0.75rem;
            border-radius: 8px;
            border: 2px solid #6b7280;
            background-color: #1f2937;
            color: #d1d5db; /* gray-300 */
            margin-top: 20px;
            width: 90%;
            max-width: 350px;
            height: 120px;
            word-wrap: break-word;
            word-break: break-all;
            -webkit-user-select: text; /* Safari */
            -ms-user-select: text; /* IE 10+ */
            user-select: text; /* Standard */
            text-align: left;
            overflow-y: auto;
        }
        #saveDataOverlay button:disabled {
            background-color: #4b5563;
            cursor: not-allowed;
            opacity: 0.7;
        }

        html[data-no-debug] [data-screen="debug"],
        html[data-no-debug] #debugScreen {
            display: none !important;
            visibility: hidden !important;
            pointer-events: none !important;
        }

        /* Hide screens by default */
        .screen {
            display: none;
            width: 100%;
            height: 100vh;
            overflow-y: auto;
        }
        /* Show the active screen */
        .screen.active {
            display: flex;
        }
        /* Loading Screen Animation */
        @keyframes pulse-king {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .animate-pulse-king {
            animation: pulse-king 2s infinite;
        }
        /* Bottom Nav */
        #bottomNav {
            position: fixed;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 400px;
            z-index: 50;
            display: none;
            transition: transform 0.3s ease-out;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
        }
        /* Nav Highlight Slider */
        #navHighlight {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 20%; /* 5 buttons = 20% width */
            background-color: rgba(250, 204, 21, 0.15);
            border-left: 1px solid rgba(250, 204, 21, 0.4);
            border-right: 1px solid rgba(250, 204, 21, 0.4);
            /* border-radius: 8px; */
            pointer-events: none;
            transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 0;
            box-shadow: 0 0 10px rgba(250, 204, 21, 0.1);
        }
        /* Enhanced Chest Slots */
        .chest-slot {
            box-shadow: inset 0 3px 6px rgba(0,0,0,0.5);
            border: 2px solid #374151;
            position: relative;
            transition: all 0.2s;
        }
        .chest-slot.bg-yellow-700 {
            box-shadow: 0 4px 6px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2);
            border-color: #ca8a04;
        }
        .chest-slot.bg-yellow-700:hover {
            animation: chestPulse 2s infinite;
            filter: brightness(1.1);
        }
        @keyframes chestPulse {
            0% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(250, 204, 21, 0); }
            100% { box-shadow: 0 0 0 0 rgba(250, 204, 21, 0); }
        }
        button {
             outline: none !important;
             -webkit-tap-highlight-color: transparent;
        }
        /* Card Style */
        .card-ui {
            width: 80px;
            height: 112px;
            background-color: #4b5563; /* gray-600 */
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            padding: 4px;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: white;
            cursor: pointer;
            user-select: none;
            border: 4px solid #374151; /* gray-700 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            overflow: hidden;
        }
        .card-ui.selected {
            border-color: #ec4899; /* pink-500 */
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 0 20px #ec4899;
        }
        .card-ui.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(80%);
        }
        .card-ui-small {
            width: 60px;
            height: 84px;
            border-radius: 6px;
        }
        .card-ui-name {
            font-size: 0.7rem;
            background-color: rgba(0,0,0,0.6);
            padding: 0 4px;
            border-radius: 4px;
            z-index: 2;
        }
        .card-ui-emoji {
            font-size: 2.5rem;
            line-height: 1;
            z-index: 2;
        }
         .card-ui-small .card-ui-emoji {
            font-size: 2rem;
        }
        .card-ui-type {
            font-size: 0.6rem;
            color: #d1d5db; /* gray-300 */
            z-index: 2;
        }
        .card-ui-cost {
            position: absolute;
            top: 2px;
            left: 2px;
            background-color: #7e22ce;
            border: 2px solid #a855f7;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            z-index: 3;
        }
        .card-ui-level {
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 0.7rem;
            font-weight: 800;
            background-color: rgba(0,0,0,0.7);
            color: #fde047; /* yellow-300 */
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 3;
        }
        .card-ui-progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background-color: #1f2937; /* gray-800 */
            z-index: 1;
        }
        .card-ui-progress {
            height: 100%;
            background-color: #3b82f6; /* blue-500 */
            transition: width 0.3s;
        }
        .card-ui .can-upgrade {
            background-color: #fde047; /* yellow-300 */
        }
        /* NEW: Locked Card Styles */
        .card-ui-locked {
            filter: grayscale(100%);
            opacity: 0.6;
        }
        .card-ui-locked-arena {
            position: absolute;
            bottom: 4px;
            left: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            background-color: rgba(0,0,0,0.8);
            color: #fde047;
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 3;
        }


        /* Card Info Modal */
        #cardInfoModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #cardInfoModalContent {
            background-color: #374151; /* gray-700 */
            border-radius: 12px;
            padding: 1.5rem;
            width: 90%;
            max-width: 350px;
            border: 4px solid #4b5563; /* gray-600 */
            position: relative;
            max-height: 85vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        #cardInfoCloseBtn {
            position: sticky;
            top: 0;
            right: 0;
            margin-left: auto;
            font-size: 2rem;
            line-height: 1;
            cursor: pointer;
            color: #9ca3af; /* gray-400 */
            background: rgba(55, 65, 81, 0.95);
            padding: 0 8px;
            border-radius: 4px;
            z-index: 50;
        }
        #cardInfoStats, #towerInfoStats {
            font-size: 0.9rem;
            color: #d1d5db; /* gray-300 */
        }
        #cardInfoStats span, #towerInfoStats span {
            color: white;
            font-weight: 600;
        }
        .modal-btn {
            width: 100%;
            font-size: 1.1rem;
            font-weight: 600;
            padding: 0.75rem;
            margin-top: 1rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .modal-btn.add { background: #16a34a !important; color: white; border-bottom: 4px solid #14532d !important; }
        .modal-btn.remove { background: #dc2626 !important; color: white; border-bottom: 4px solid #7f1d1d !important; }
        .modal-btn.upgrade { background: #9333ea !important; color: white; border-bottom: 4px solid #581c87 !important; }
        .modal-btn:disabled {
            background-color: #6b7280; /* gray-500 */
            color: #d1d5db; /* gray-300 */
            cursor: not-allowed;
        }
        #cardInfoProgressContainer, #towerInfoProgressContainer {
            width: 100%;
            background-color: #1f2937;
            border-radius: 5px;
            height: 20px;
            margin-top: 8px;
            position: relative;
            overflow: hidden;
        }
        #cardInfoProgressBar, #towerInfoProgressBar {
            height: 100%;
            background-color: #3b82f6;
        }
        #cardInfoProgressText, #towerInfoProgressText {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            font-weight: 600;
            color: white;
        }
        /* Troop Ghost & Spell Radius */
        #placementIndicator {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            display: none;
            z-index: 20;
            font-size: 2rem;
            opacity: 0.7;
            text-align: center;
            line-height: 1;
            transform: translate(-50%, -50%); /* Keep this for centering */
        }
        #placementIndicator.spell {
            border: 4px dashed white;
            background: rgba(255, 255, 255, 0.2);
        }
        #placementIndicator.cant-place {
            background: rgba(220, 38, 38, 0.4);
            border-color: #dc2626;
        }
        /* Chest Reward Styles */
        #chestRewardList {
            font-size: 1.2rem;
            margin-top: 1rem;
            max-height: 40vh; /* Limit height for scrolling */
            overflow-y: auto; /* Enable scroll bar */
            width: 100%;
        }
        #chestRewardList div {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        /* Red 'Can't Place' Overlay */
        #placementOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                rgba(220, 38, 38, 0.2),
                rgba(220, 38, 38, 0.2) 10px,
                rgba(220, 38, 38, 0.3) 10px,
                rgba(220, 38, 38, 0.3) 20px
            );
            z-index: 10;
            pointer-events: none;
            display: none;
            /* clip-path: polygon(0% 0%, 100% 0%, 100% 50%, 0% 50%); */
            /* NEW: Switched to path() for multi-area clipping */
            clip-path: path("M0 0 L400 0 L400 250 L0 250 Z");
        }
        
        /* NEW: Unauthorized Screen Overlay */
        #unauthorizedScreen {
            display: none; /* Hidden by default */
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7); /* Greys out the background */
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 1rem;
        }
        #imagineText {
            font-size: 2.5rem;
            font-weight: 800;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        #errorReasonText {
            font-size: 1rem;
            color: #fca5a5; /* red-300 */
            margin-top: 1rem;
        }
        
        /* NEW: Fade overlay for demo loop */
        #demoFadeOverlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
            z-index: 101; /* Above the "imagine" text */
        }
    </style>
</head>
<body class="text-gray-100 min-h-screen flex flex-col items-center p-2">
    <canvas id="bgCanvas"></canvas>

    <!-- 
    ========================================================
    SCREEN: INTRO (NEW)
    ========================================================
    -->
    <div id="introScreen" class="screen active flex-col justify-center items-center">
        <div class="text-8xl animate-pulse-king">üëë</div>
    </div>

    <!-- 
    ========================================================
    SCREEN: LOGIN (FIXED)
    ========================================================
    -->
    <div id="loginScreen" class="screen flex-col justify-center items-center">
        <div class="text-6xl">üëë</div>
        <h1 class="text-4xl font-bold mt-4">Emoji Royale</h1>
        <p class="text-lg mt-2 text-gray-500">Choose your way to play!</p>
        <p id="loginError" class="text-lg mt-2 text-red-500 font-bold h-6"></p> 
        
        <!-- NEW: Load Save Key Button -->
        <button id="loadKeyBtn" class="login-btn bg-blue-600 hover:bg-blue-700">
            Enter Save Key
        </button>
        
        <!-- "Play as Guest (No Save)" button -->
        <button id="trueGuestLoginBtn" class="login-btn guest">
            Play without Save
        </button>
        
        <!-- Google Sign-in (hidden for now, but logic exists) -->
        <button id="googleLoginBtn" class="login-btn google hidden">
            <svg class="w-6 h-6 mr-3" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><path fill="#FFC107" d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z"></path><path fill="#FF3D00" d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z"></path><path fill="#4CAF50" d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.202,0-9.619-3.317-11.283-7.946l-6.522,5.025C9.505,39.556,16.227,44,24,44z"></path><path fill="#1976D2" d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.574l6.19,5.238C42.018,36.341,44,30.606,44,24C44,22.659,43.862,21.35,43.611,20.083z"></path></svg>
            Sign in with Google
        </button>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: LOADING
    ========================================================
    -->
    <div id="loadingScreen" class="screen flex-col justify-center items-center">
        <div class="text-8xl animate-pulse-king">üëë</div>
        <h1 class="text-3xl font-bold mt-4">Emoji Royale</h1>
        <p class="text-lg mt-2 text-gray-500">Loading...</p>
    </div>
    
    <!-- 
    ========================================================
    SCREEN: MENU (HOME)
    ========================================================
    -->
    <div id="menuScreen" class="screen flex-col items-center p-4">
        <!-- Main Content Area -->
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <!-- Header -->
            <div class="flex justify-between items-center w-full">
                <div class="bg-gray-800 px-4 py-2 rounded-lg">
                    <span id="goldDisplay" class="text-xl font-bold text-yellow-400 ui-text-effect">üí∞ 500</span>
                </div>
                <div class="bg-gray-800 px-4 py-2 rounded-lg">
                    <span id="trophyDisplay" class="text-xl font-bold text-blue-400 ui-text-effect">üèÜ 0</span>
                </div>
            </div>
            
            <!-- Arena Display -->
            <div id="modeDisplay" class="text-yellow-600 font-bold text-xl mb-2 ui-text-effect">Trophy Road</div>
            <!-- Mode Selector Buttons -->
            <div class="flex w-11/12 mb-4 bg-gray-800 rounded-lg p-1 gap-1">
                <button id="modeTrophy" class="mode-tab flex-1 py-2 text-sm rounded-md font-bold transition bg-red-600 text-white shadow-md btn-shine ui-text-effect">Trophy Road</button>
                <button id="modeParty1v1" class="mode-tab flex-1 py-2 text-sm rounded-md font-bold transition bg-gray-700 text-gray-400 shadow-md btn-shine ui-text-effect">1v1</button>
                <button id="mode2v2" class="mode-tab flex-1 py-2 text-sm rounded-md font-bold transition bg-gray-700 text-gray-400 shadow-md btn-shine ui-text-effect">2v2</button>
            </div>
            <div class="flex flex-col items-center my-8">
                <span id="arenaEmoji" class="text-8xl">üèûÔ∏è</span>
                <h2 id="arenaName" class="text-2xl font-bold mt-2 ui-text-effect">Arena 1: Emoji Valley</h2>
            </div>

            <!-- Battle Button -->
            <button id="battleButton" class="bg-red-600 hover:bg-red-700 text-white w-3/4 py-4 rounded-lg shadow-lg text-3xl font-extrabold transition transform hover:scale-105 btn-shine ui-text-effect">
                BATTLE!
            </button>
            
            <!-- NEW: Arena Button -->
            <button id="arenaButton" class="arena-btn bg-blue-600 hover:bg-blue-700 mt-4 w-3/4 py-3 text-xl font-bold btn-shine ui-text-effect">
                Arenas
            </button>
            
            <!-- Chest Slots -->
            <div class="mt-8 w-full">
                <h3 class="text-xl font-bold text-center mb-2">Your Boxes</h3>
                <div id="chestSlots" class="grid grid-cols-4 gap-2">
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                    <div class="chest-slot bg-gray-700 h-24 rounded-lg flex items-center justify-center text-4xl text-gray-500"></div>
                </div>
            </div>

            <!-- NEW: Save Data Button -->
            <button id="saveDataBtn" class="login-btn guest mt-8 w-3/4 btn-shine">
                Save Data
            </button>

        </div>
        <!-- Bottom Nav Removed: Using Persistent Nav at bottom of body -->
    </div>
    
    <!-- 
    ========================================================
    SCREEN: DECK
    ========================================================
    -->
    <div id="deckScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-6 pb-24">
            <!-- Battle Deck Section -->
            <div class="w-full bg-gray-800 rounded-xl p-4 shadow-lg border-2 border-gray-700 mb-6 relative overflow-hidden">
                <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500"></div>
                <div class="flex justify-between items-end mb-4">
                     <div>
                        <h1 class="text-2xl font-black italic tracking-wider text-white" style="text-shadow: 2px 2px 0 #000;">BATTLE DECK</h1>
                        <p id="deckCount" class="text-xs text-gray-400 font-bold uppercase tracking-widest">0/8 Cards</p>
                     </div>
                     <div class="text-right">
                         <div class="text-xs text-purple-400 font-bold uppercase tracking-widest mb-1">Avg Elixir</div>
                         <div id="avgElixir" class="text-2xl font-black text-purple-300 leading-none drop-shadow-md">0.0</div>
                     </div>
                </div>
                
                <div id="deckCardGrid" class="grid grid-cols-4 gap-2 justify-items-center">
                    <!-- Deck cards injected by JS (Big cards) -->
                </div>
            </div>

            <!-- Collection Header -->
            <div class="w-full flex items-center mb-4 px-2">
                <h2 class="text-xl font-bold text-gray-300 flex-grow">Collection</h2>
                <div class="h-px bg-gray-700 flex-grow ml-4"></div>
            </div>

            <div id="collectionCardGrid" class="grid grid-cols-4 gap-2 mb-8 justify-items-center w-full">
                <!-- Collection cards injected by JS (Small cards) -->
            </div>

            <!-- Locked Header -->
            <div class="w-full flex items-center mb-4 px-2">
                <h2 class="text-xl font-bold text-gray-500 flex-grow">Locked</h2>
                <div class="h-px bg-gray-800 flex-grow ml-4"></div>
            </div>

            <div id="lockedCardGrid" class="grid grid-cols-4 gap-2 mb-4 justify-items-center w-full">
                <!-- Locked cards injected by JS -->
            </div>

        </div>
    </div>

    <!-- 
    ========================================================
    SCREEN: TOWER
    ========================================================
    -->
    <div id="towerScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold">Tower Power</h1>
            <p id="towerLevelDisplay" class="text-lg text-yellow-300 font-bold">Tower Level 1</p>
            <div class="text-8xl my-4">üëë</div>
            
            <!-- Stats -->
            <div class="bg-gray-800 p-4 rounded-lg mt-4 w-full space-y-2">
                <h3 class="text-xl font-bold text-center">Tower Stats</h3>
                <div id="towerInfoStats" class="grid grid-cols-2 gap-2">
                    <!-- Stats injected by JS -->
                </div>
            </div>
            
            <!-- Upgrade -->
            <div class="bg-gray-800 p-4 rounded-lg mt-8 w-full flex flex-col items-center">
                <h3 class="text-xl font-bold text-center">Upgrade Tower</h3>
                <div id="towerInfoProgressContainer" class="w-full">
                    <div id="towerInfoProgressBar" style="width: 0%;"></div>
                    <div id="towerInfoProgressText">0 / 0</div>
                </div>
                <div class="w-full flex justify-center">
                    <button id="towerUpgradeButton" class="modal-btn upgrade mx-auto btn-shine" style="width: 80%;" disabled>
                        Upgrade
                    </button>
                </div>
            </div>
        </div>
        
        </div>

    <!-- 
    ========================================================
    SCREEN: ARENAS (NEW)
    ========================================================
    -->
    <div id="arenaScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold mb-8 ui-text-effect">Arenas</h1>
            
            <div class="space-y-4 w-full">
                <!-- Arena 1 -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üèûÔ∏è</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 1: Emoji Valley</h2>
                        <p class="text-yellow-400">0+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 2 -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üèòÔ∏è</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 2: Laughing Village</h2>
                        <p class="text-yellow-400">250+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 3 -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üåã</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 3: Lava Town</h2>
                        <p class="text-yellow-400">500+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 4 -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üöú</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 4: The Farm</h2>
                        <p class="text-yellow-400">750+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 4 -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üöú</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 4: The Farm</h2>
                        <p class="text-yellow-400">750+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 5 (NEW) -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üíÄ</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 5: Skull Kingdom</h2>
                        <p class="text-yellow-400">1000+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 6 (NEW) -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üîÆ</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 6: Warlock's Workshop</h2>
                        <p class="text-yellow-400">1250+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 7 (NEW) -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">ü™¶</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 7: Mages Graveyard</h2>
                        <p class="text-yellow-400">1500+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 8 (NEW) -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">‚ö°</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 8: Chaos Canyon</h2>
                        <p class="text-yellow-400">1750+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 9 (NEW) -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">ü™®</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 9: Titan's Peak</h2>
                        <p class="text-yellow-400">2000+ Trophies üèÜ</p>
                    </div>
                </div>
                <!-- Arena 10 (NEW) -->
                <div class="bg-gray-800 p-4 rounded-lg flex items-center space-x-4">
                    <span class="text-6xl">üî•</span>
                    <div>
                        <h2 class="text-xl font-bold">Arena 10: Chaos Realm</h2>
                        <p class="text-yellow-400">2250+ Trophies üèÜ</p>
                    </div>
                </div>
            </div>
            
            <button id="arenaBackButton" class="arena-btn bg-gray-600 hover:bg-gray-700 mt-8 w-3/4">
                Back to Menu
            </button>
        </div>
        
        </div>

    <!-- 
    ========================================================
    SCREEN: EVENTS
    ========================================================
    -->
    <div id="eventsScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold text-red-500 mb-2" style="text-shadow: 0 0 15px white, 0 0 30px #ef4444;">üéÑ Christmas Event üéÑ</h1>
            <p class="text-green-400 font-bold mb-8" style="text-shadow: 0 0 15px #4ade80, 0 0 30px #22c55e;">Winter Wonderland</p>
            
            <div class="bg-gray-800 p-6 rounded-lg w-full mb-6 border-2 border-red-600 relative overflow-hidden">
                <!-- Snow decoration -->
                <div class="absolute top-0 left-0 w-full h-full pointer-events-none opacity-20" style="background-image: radial-gradient(white 1px, transparent 1px); background-size: 20px 20px;"></div>
                
                <h2 class="text-xl font-bold mb-2" style="text-shadow: 0 0 8px white;">üéÅ Daily Holiday Gift</h2>
                <p class="text-sm text-gray-300 mb-4" style="text-shadow: 0 0 2px black;">Log in every day to claim a free gift from Santa!</p>
                
                <div id="christmasGiftStatus" class="text-center mb-4 text-yellow-300 font-bold text-lg" style="text-shadow: 0 0 8px #fde047;"></div>
                
                <button id="claimChristmasBtn" class="w-full py-3 bg-red-600 hover:bg-red-700 rounded-lg font-bold text-white shadow-lg btn-shine border-b-4 border-red-800 active:border-b-0 active:translate-y-1">
                    Open Gift
                </button>
            </div>

            <div class="bg-gray-800 p-6 rounded-lg w-full border-2 border-green-600 relative overflow-hidden">
                <div class="absolute top-0 left-0 w-full h-full pointer-events-none opacity-20" style="background-image: radial-gradient(white 1px, transparent 1px); background-size: 15px 15px;"></div>
                <h2 class="text-xl font-bold mb-2" style="text-shadow: 0 0 8px white;">‚òÉÔ∏è Snowman Challenge</h2>
                <p class="text-sm text-gray-300 mb-4" style="text-shadow: 0 0 2px black;">Defeat the Snowman King's icy army!</p>
                <div id="snowmanChallengeStatus" class="text-center mb-4 text-blue-300 font-bold text-lg" style="text-shadow: 0 0 15px #93c5fd, 0 0 25px #3b82f6;">Win 100 Gold & a Box! üí∞üì¶</div>
                <button id="btnSnowmanChallenge" class="w-full py-3 bg-blue-600 hover:bg-blue-700 rounded-lg font-bold text-white shadow-lg btn-shine border-b-4 border-blue-800 active:border-b-0 active:translate-y-1">
                    Play Challenge
                </button>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    SCREEN: DEBUG (NEW)
    ========================================================
    -->
    <div id="debugScreen" class="screen flex-col items-center p-4">
        <div class="flex-grow flex flex-col items-center w-full max-w-md pt-8 pb-24">
            <h1 class="text-3xl font-bold">Debug Menu</h1>
            <p class="text-gray-400 text-center my-4">For testing only!</p>
            
            <button id="debugArena2" class="debug-btn bg-green-600 hover:bg-green-700">Jump to Arena 2 (250 üèÜ)</button>
            <button id="debugArena3" class="debug-btn bg-red-600 hover:bg-red-700">Jump to Arena 3 (500 üèÜ)</button>
            <button id="debugArena4" class="debug-btn bg-yellow-600 hover:bg-yellow-700">Jump to Arena 4 (750 üèÜ)</button>
            <button id="debugArena5" class="debug-btn bg-indigo-600 hover:bg-indigo-700">Jump to Arena 5 (1000 üèÜ)</button> <!-- NEW -->
                    <button id="debugArena6" class="debug-btn bg-orange-900 hover:bg-orange-800">Jump to Arena 6 (1250 üèÜ)</button>
                    <button id="debugArena7" class="debug-btn bg-gray-900 hover:bg-gray-800">Jump to Arena 7 (1500 üèÜ)</button>
                    <button id="debugArena8" class="debug-btn bg-purple-900 hover:bg-purple-800">Jump to Arena 8 (1750 üèÜ)</button>
                    <button id="debugArena9" class="debug-btn bg-slate-900 hover:bg-slate-800">Jump to Arena 9 (2000 üèÜ)</button>
                    <button id="debugArena10" class="debug-btn bg-red-900 hover:bg-red-800">Jump to Arena 10 (2250 üèÜ)</button>
            <button id="debugUnlockAll" class="debug-btn bg-blue-600 hover:bg-blue-700">Unlock All Cards</button>
            <button id="debugUpgradeAll" class="debug-btn bg-purple-600 hover:bg-purple-700">Upgrade All Cards +1 Lvl</button>
            <button id="debugGetChest" class="debug-btn bg-yellow-600 hover:bg-yellow-700">Get a Free Chest üì¶</button>
            <button id="debugAddGold" class="debug-btn bg-yellow-400 text-gray-900 hover:bg-yellow-300">Get 1000 Gold üí∞</button>
            <button id="debugReset" class="debug-btn bg-gray-600 hover:bg-gray-700">Reset Account (New User)</button>

        </div>
        
        </div>


    <!-- 
    ========================================================
    SCREEN: GAME
    ========================================================
    -->
    <div id="gameScreen" class="screen flex-col items-center p-2">
        <div id="gameContainer">
            <div id="timerDisplay" class="absolute top-2 right-2 text-2xl font-bold bg-black bg-opacity-50 px-4 py-1 rounded-lg z-10">2:00</div>
            <!-- AI Teammate UI (2v2) -->
            <div id="aiTeammateUI" class="absolute bottom-[-340px] left-1/2 transform -translate-x-1/2 flex flex-col items-center gap-2 pointer-events-none z-50 transition-all" style="display:none;">
                <div class="bg-gray-900 bg-opacity-95 p-3 rounded-xl border-2 border-gray-600 shadow-xl flex flex-col items-center gap-2">
                    <div class="flex justify-center items-end space-x-3">
                        <div class="flex flex-col items-center opacity-90">
                            <span class="text-[10px] text-gray-300 font-bold mb-1 tracking-widest ui-text-effect">NEXT</span>
                            <div id="aiTeammateNext" class="card-ui-small transform scale-75 origin-bottom"></div>
                        </div>
                        <div id="aiTeammateHand" class="flex justify-center space-x-[-5px] transform scale-90"></div>
                    </div>
                    <div class="flex items-center gap-2 w-full px-2">
                        <span class="text-[10px] font-bold text-purple-300 uppercase tracking-wider ui-text-effect">Ally</span>
                        <div class="flex-grow h-3 bg-gray-800 rounded-full border border-gray-600 overflow-hidden relative">
                            <div class="absolute inset-0" style="background-image: repeating-linear-gradient(90deg, transparent, transparent 19%, rgba(255,255,255,0.1) 20%); background-size: 10% 100%;"></div>
                            <div id="aiTeammateElixirBar" class="h-full bg-gradient-to-r from-purple-600 to-purple-400" style="width: 0%"></div>
                        </div>
                        <span id="aiTeammateElixirCount" class="text-xs font-black text-white ui-text-effect">0</span>
                    </div>
                </div>
            </div>
            <!-- NEW: Placement Overlay -->
            <div id="placementOverlay"></div>
            <canvas id="gameCanvas" width="400" height="500"></canvas>
            <div id="messageOverlay">
                <span id="messageText"></span>
                <button id="startButton">Start Game</button>
                <button id="menuButton" class="bg-red-600 hover:bg-red-700">Back to Menu</button>
            </div>
            <!-- Placement "Ghost" Indicator -->
            <div id="placementIndicator"></div>
            
            <!-- NEW: Unauthorized Screen Overlay -->
            <div id="unauthorizedScreen">
                <h1 id="imagineText">Imagine... what could have been.</h1>
                <p id="errorReasonText">Error: This game is not authorized to run on this domain.</p>
                <!-- NEW: Fade overlay for demo loop -->
                <div id="demoFadeOverlay"></div>
            </div>
        </div>

        <!-- Card UI Bar -->
        <div class="bg-gradient-to-b from-gray-800 to-gray-900 p-4 border-t-4 border-gray-700 shadow-2xl w-full max-w-md mt-2 rounded-xl relative z-20" style="padding-bottom: env(safe-area-inset-bottom, 1rem);">
            <div class="max-w-md mx-auto">
                <!-- Elixir Bar -->
                <div class="mb-4 relative">
                     <div class="flex justify-between text-xs font-bold text-purple-300 mb-1 px-1 uppercase tracking-wider ui-text-effect" style="text-shadow: 1px 1px 0 #000;">
                        <span>Elixir</span>
                    </div>
                    <div class="w-full bg-gray-900 rounded-full h-8 border-2 border-gray-600 shadow-inner relative overflow-hidden">
                        <!-- Background Grid for Elixir -->
                        <div class="absolute inset-0" style="background-image: repeating-linear-gradient(90deg, transparent, transparent 19%, rgba(255,255,255,0.1) 20%); background-size: 10% 100%;"></div>
                        <div id="elixirBar" class="bg-gradient-to-r from-purple-600 to-purple-400 h-full rounded-full transition-all duration-100 ease-linear flex items-center justify-end pr-3 shadow-[0_0_10px_rgba(168,85,247,0.5)]" style="width: 30%;">
                            <span id="elixirText" class="text-white font-black text-lg ui-text-effect">3</span>
                        </div>
                    </div>
                </div>
                
                <!-- 4-Card Hand + Next Card -->
                <div class="flex justify-center items-end space-x-3">
                    <div class="flex flex-col items-center bg-gray-900 p-2 rounded-lg border border-gray-700">
                        <span class="text-[10px] text-gray-400 font-bold mb-1 tracking-widest ui-text-effect">NEXT</span>
                        <div id="nextCardSlot" class="card-ui-small transform scale-90 origin-bottom"></div>
                    </div>
                    <div id="cardHand" class="flex justify-center space-x-1 pb-1"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    CARD INFO MODAL
    ========================================================
    -->
    <div id="cardInfoModal">
        <div id="cardInfoModalContent">
            <span id="cardInfoCloseBtn">&times;</span>
            <div class="flex items-center space-x-4 mb-4">
                <div id="cardInfoDisplay" class="flex-shrink-0"></div>
                <div>
                    <h2 id="cardInfoName" class="text-2xl font-bold">Card Name</h2>
                    <p id="cardInfoType" class="text-lg text-gray-400">Card Type</p>
                    <p id="cardInfoLevel" class="text-lg font-bold text-yellow-300">Level 1</p>
                </div>
            </div>
            
            <!-- Tabs -->
            <div class="flex w-full bg-gray-700 rounded-lg p-1 mb-4">
                <button id="cardTabStats" class="flex-1 py-2 rounded text-sm font-bold transition bg-gray-600 text-white shadow-md flex justify-center items-center">Stats</button>
                <button id="cardTabPreview" class="flex-1 py-2 rounded text-sm font-bold transition text-gray-400 hover:bg-gray-600 hover:text-white flex justify-center items-center">Preview</button>
            </div>

            <!-- Stats Panel -->
            <div id="cardInfoStatsPanel">
                <hr class="border-gray-500 my-4">
                <div id="cardInfoStats" class="space-y-1"></div>
                <div id="cardInfoButtons"></div>
                <div id="cardInfoProgressContainer">
                    <div id="cardInfoProgressBar" style="width: 0%;"></div>
                    <div id="cardInfoProgressText">0 / 0</div>
                </div>
                <button id="cardInfoButton" class="modal-btn"></button>
            </div>

            <!-- Preview Panel -->
            <div id="cardInfoPreviewPanel" class="hidden flex-col items-center w-full">
                <canvas id="cardPreviewCanvas" width="300" height="200" class="bg-gray-800 rounded-lg mb-4 border-2 border-gray-600 shadow-inner"></canvas>
                <div class="w-full text-center space-y-3">
                    <div>
                        <h4 id="previewStrongHeader" class="text-green-400 font-bold text-sm uppercase tracking-wider mb-2 border-b border-gray-700 pb-1">Good Against</h4>
                        <div id="previewStrong" class="flex flex-wrap gap-2 min-h-[40px] bg-gray-900 bg-opacity-50 p-2 rounded-lg"></div>
                    </div>
                    <div id="previewWeakContainer">
                        <h4 id="previewWeakHeader" class="text-red-400 font-bold text-sm uppercase tracking-wider mb-2 border-b border-gray-700 pb-1">Weak Against</h4>
                        <div id="previewWeak" class="flex flex-wrap gap-2 min-h-[40px] bg-gray-900 bg-opacity-50 p-2 rounded-lg"></div>
                    </div>
                    <!-- Test Against All Section -->
                    <div class="pt-2 border-t border-gray-600 mt-2">
                        <h4 class="text-blue-400 font-bold text-sm uppercase tracking-wider mb-2">Test Against Any Card</h4>
                        <input type="text" id="previewSearchInput" placeholder="Search cards..." class="w-full bg-gray-900 text-white p-2 rounded mb-2 border border-gray-600 text-sm focus:outline-none focus:border-blue-500 transition-colors">
                        <div id="previewAllCardsList" class="flex flex-wrap gap-2 max-h-40 overflow-y-auto bg-gray-900 bg-opacity-50 p-2 rounded-lg justify-center"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 
    ========================================================
    BOX OPENING MODAL
    ========================================================
    -->
    <div id="chestOpenOverlay">
        <h2 id="chestTitle" class="text-4xl font-bold">Box Unlocked!</h2>
        <div id="chestStars" class="flex justify-center my-4 space-x-2 h-8">
            <!-- Stars injected here -->
        </div>
        
        <div id="chestClickArea" class="cursor-pointer transition p-8 rounded-full" style="outline: none; -webkit-tap-highlight-color: transparent;">
            <div id="chestEmoji" class="text-9xl select-none">üì¶</div>
        </div>
        
        <div id="chestStatusText" class="text-xl text-yellow-300 font-bold mb-4 h-8" style="text-shadow: 2px 2px 0px #000;">Click the Box!</div>
        <div id="chestClickCounter" class="text-sm text-gray-400 mb-4 h-4"></div>

        <div id="chestRewardList" class="w-full max-w-xs space-y-2 mb-4">
            <!-- Rewards injected by JS -->
        </div>
        
        <!-- Buttons hidden initially, controlled by JS logic -->
        <button id="chestCloseButton" class="modal-btn bg-green-600 hidden btn-shine">Awesome!</button>
    </div>

    <!-- 
    ========================================================
    DEBUG PASSWORD MODAL (NEW)
    ========================================================
    -->
    <div id="debugPasswordOverlay">
        <h2 class="text-2xl font-bold">Enter Debug Password</h2>
        <input type="password" id="debugPasswordInput" placeholder="Password">
        <button id="debugPasswordSubmit">Enter</button>
        <button id="debugPasswordCancel" class="cancel-btn">Cancel</button>
    </div>

    <!-- 
    ========================================================
    SAVE DATA MODAL (NEW)
    ========================================================
    -->
    <div id="saveDataOverlay">
        <h2 class="text-2xl font-bold">Your Save Key</h2>
        <p class="text-sm font-normal text-gray-300 mt-2">Copy this key and save it somewhere safe!</p>
        <textarea id="saveKeyOutput" readonly>Generating key...</textarea>
        <button id="generateKeyBtn">Generate New Key</button>
        <button id="saveDataCancel" class="cancel-btn">Close</button>
    </div>

    <!-- 
    ========================================================
    LOAD DATA MODAL (NEW)
    ========================================================
    -->
    <div id="loadDataOverlay">
        <h2 class="text-2xl font-bold">Load Save Key</h2>
        <p class="text-sm font-normal text-gray-300 mt-2">Paste your save key below to load progress.</p>
        <input type="text" id="loadKeyInput" placeholder="Paste your key here">
        <button id="loadKeySubmit">Load Progress</button>
        <button id="loadDataCancel" class="cancel-btn">Cancel</button>
    </div>

    <!-- 
    ========================================================
    UPDATE LOG MODAL (NEW)
    ========================================================
    -->
    <div id="updateLogOverlay">
        <h2 class="text-3xl font-bold mb-4">üìã Update Log</h2>
        <div id="updateLogContent" class="text-left text-sm max-h-96 overflow-y-auto w-full max-w-md px-4 space-y-3">
            <!-- Update log content will be injected by JS -->
        </div>
        <button id="updateLogClose" class="mt-4">Continue</button>
    </div>


    <!-- Persistent Bottom Nav -->
    <div id="bottomNav" class="bg-gray-800 w-full max-w-[400px] rounded-t-lg shadow-inner p-1 btn-shine">
        <div class="relative w-full h-full">
            <div id="navHighlight"></div>
            <div class="grid grid-cols-5 relative z-10" style="grid-template-columns: repeat(5, minmax(0, 1fr));">
                <button id="navBtnMenu" class="nav-btn flex flex-col items-center text-yellow-400 py-1" data-screen="menu">
                    <span class="text-3xl">‚öîÔ∏è</span>
                    <span class="text-xs font-bold">Battle</span>
                </button>
                <button id="navBtnDeck" class="nav-btn flex flex-col items-center text-gray-400 py-1" data-screen="deck">
                    <span class="text-3xl">üÉè</span>
                    <span class="text-xs font-bold">Deck</span>
                </button>
                <button id="navBtnTower" class="nav-btn flex flex-col items-center text-gray-400 py-1" data-screen="tower">
                    <span class="text-3xl">üëë</span>
                    <span class="text-xs font-bold">Tower</span>
                </button>
                <button id="navBtnEvents" class="nav-btn flex flex-col items-center text-gray-400 py-1" data-screen="events">
                    <span class="text-3xl">üéÑ</span>
                    <span class="text-xs font-bold">Events</span>
                </button>
                <button id="navBtnDebug" class="nav-btn flex flex-col items-center text-gray-400 py-1" data-screen="debug">
                    <span class="text-3xl">üß™</span>
                    <span class="text-xs font-bold">Debug</span>
                </button>
            </div>
        </div>
    </div>

    <!-- 
    ========================================================
    MAIN SCRIPT
    ========================================================
    -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getDatabase, ref, set, onValue, off, update, remove, push, onChildAdded, onChildRemoved } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";
        
        // WebRTC configuration
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };
        
        // Global multiplayer state
        let peerConnection = null;
        let dataChannel = null;
        let currentRoomId = null;
        let isHost = false;
        let remotePlayerId = null;

        // Your web app's Firebase configuration
        // Your web app's Firebase configuration
const firebaseConfig = {
    apiKey: "AIzaSyCnaXKjDvPDXP2tF5ZmtB7naYjCuLGUsd4",
    authDomain: "emoji-royale-8fb68.firebaseapp.com",
    databaseURL: "https://emoji-royale-8fb68-default-rtdb.firebaseio.com",
    projectId: "emoji-royale-8fb68",
    storageBucket: "emoji-royale-8fb68.firebasestorage.app",
    messagingSenderId: "1021589049311",
    appId: "1:1021589049311:web:61ce6353950831e298be6a",
    measurementId: "G-FDQ9L0MQGM"
};

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const rtdb = getDatabase(app); // Initialize Realtime Database
        const provider = new GoogleAuthProvider();
        // setLogLevel('debug'); // Uncomment for debugging Firestore
        
        // Multiplayer functions
        async function createRoom() {
            isHost = true;
            currentRoomId = 'room-' + Math.random().toString(36).substr(2, 9);
            
            // Create peer connection
            peerConnection = new RTCPeerConnection(rtcConfig);
            setupDataChannel();
            
            // Create offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            // Save room to Firebase
            const roomRef = ref(rtdb, 'rooms/' + currentRoomId);
            await set(roomRef, {
                hostId: userId,
                offer: offer,
                timestamp: Date.now()
            });
            
            // Listen for answers
            onValue(ref(rtdb, `rooms/${currentRoomId}/answer`), async (snapshot) => {
                if (snapshot.exists() && peerConnection.signalingState !== 'stable') {
                    const answer = snapshot.val();
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                    console.log('Answer received and remote description set');
                }
            });
            
            return currentRoomId;
        }
        
        async function joinRoom(roomId) {
            isHost = false;
            currentRoomId = roomId;
            
            // Get room data
            const roomRef = ref(rtdb, 'rooms/' + roomId);
            const snapshot = await get(roomRef);
            
            if (!snapshot.exists()) {
                throw new Error('Room not found');
            }
            
            const roomData = snapshot.val();
            remotePlayerId = roomData.hostId;
            
            // Create peer connection
            peerConnection = new RTCPeerConnection(rtcConfig);
            setupDataChannel();
            
            // Set remote description
            await peerConnection.setRemoteDescription(new RTCSessionDescription(roomData.offer));
            
            // Create answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            // Send answer back to host
            await update(ref(rtdb, 'rooms/' + roomId), {
                answer: answer,
                joinerId: userId
            });
            
            return true;
        }
        
        function setupDataChannel() {
            if (isHost) {
                dataChannel = peerConnection.createDataChannel('gameData');
                setupDataChannelHandlers();
            } else {
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannelHandlers();
                };
            }
            
            // ICE Candidate handling
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidateRef = ref(rtdb, `rooms/${currentRoomId}/candidates/${isHost ? 'host' : 'joiner'}/${Date.now()}`);
                    set(candidateRef, event.candidate);
                }
            };
            
            // Listen for ICE candidates
            const candidateType = isHost ? 'joiner' : 'host';
            onChildAdded(ref(rtdb, `rooms/${currentRoomId}/candidates/${candidateType}`), async (snapshot) => {
                const candidate = snapshot.val();
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                } catch (e) {
                    console.error('Error adding ICE candidate:', e);
                }
            });
        }
        
        function setupDataChannelHandlers() {
            dataChannel.onopen = () => {
                console.log('Data channel opened');
                // Notify UI that connection is ready
                if (window.onMultiplayerConnected) {
                    window.onMultiplayerConnected();
                }
            };
            
            dataChannel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log('Received data:', data);
                
                // Handle different message types
                if (data.type === 'gameAction') {
                    // Handle game action from other player
                    handleGameAction(data.action, data.payload);
                }
            };
        }
        
        function sendGameAction(action, payload) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify({
                    type: 'gameAction',
                    action: action,
                    payload: payload,
                    timestamp: Date.now()
                }));
                return true;
            }
            return false;
        }
        
        function cleanupMultiplayer() {
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            if (currentRoomId && isHost) {
                // Remove room when host disconnects
                remove(ref(rtdb, 'rooms/' + currentRoomId));
            }
            
            currentRoomId = null;
            isHost = false;
            remotePlayerId = null;
        }
        
        // Make multiplayer functions available globally
        window.createRoom = createRoom;
        window.joinRoom = joinRoom;
        window.sendGameAction = sendGameAction;
        window.cleanupMultiplayer = cleanupMultiplayer;
        // setLogLevel('debug'); // Uncomment for debugging Firestore
        
        // Multiplayer Service
        const multiplayer = {
            gameId: null,
            isHost: false,
            playerId: Math.random().toString(36).substr(2, 9),
            playerName: 'Player ' + Math.floor(Math.random() * 1000),
            
            // Initialize a new game
            async createGame() {
                this.isHost = true;
                this.gameId = 'game_' + Math.random().toString(36).substr(2, 6).toUpperCase();
                
                // Create game in database
                await set(ref(database, `games/${this.gameId}`), {
                    host: this.playerId,
                    players: {
                        [this.playerId]: {
                            name: this.playerName,
                            ready: false
                        }
                    },
                    status: 'waiting',
                    createdAt: Date.now()
                });
                
                return this.gameId;
            },
            
            // Join an existing game
            async joinGame(gameId) {
                this.isHost = false;
                this.gameId = gameId.toUpperCase();
                
                // Check if game exists
                const gameRef = ref(database, `games/${this.gameId}`);
                const snapshot = await get(gameRef);
                
                if (!snapshot.exists()) {
                    throw new Error('Game not found');
                }
                
                // Add player to game
                await update(ref(database, `games/${this.gameId}/players`), {
                    [this.playerId]: {
                        name: this.playerName,
                        ready: false
                    }
                });
                
                return true;
            },
            
            // Listen for game state changes
            onGameUpdate(callback) {
                const gameRef = ref(database, `games/${this.gameId}`);
                return onValue(gameRef, (snapshot) => {
                    const game = snapshot.val();
                    callback(game);
                });
            },
            
            // Update player ready status
            async setReady(ready) {
                await update(ref(database, `games/${this.gameId}/players/${this.playerId}`), {
                    ready: ready
                });
            },
            
            // Start the game (host only)
            async startGame() {
                if (!this.isHost) return;
                
                await update(ref(database, `games/${this.gameId}`), {
                    status: 'playing',
                    startedAt: Date.now()
                });
            },
            
            // Clean up
            cleanup() {
                if (this.gameId) {
                    // If host, delete the game, otherwise just remove the player
                    if (this.isHost) {
                        remove(ref(database, `games/${this.gameId}`));
                    } else {
                        remove(ref(database, `games/${this.gameId}/players/${this.playerId}`));
                    }
                }
            }
        };
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Use __app_id
        let userDocRef; // Reference to the user's document in Firestore
        let userId; // The user's unique ID
        
        // --- Global State ---
        let lastTime = 0;
        let deltaTime = 0;
        let gameLoopId = 0;
        let currentScreen = 'intro'; // Start on intro screen
        let trophies = 0;
        let gold = 500;
        let trophyChests = [];
        let allCards = {};
        let cardCollection = {};
        let playerDeck = [];
        let playerDeck2v2 = [];
        let playerDeckParty = [];
        let gameDeck = [];
        let hand = [];
        let nextCard = null;
        let discardPile = [];
        let aiDeck = [];
        let aiHand = [];
        let aiNextCard = null;
        let aiDiscardPile = [];
        let towerLevel = 1;
        let towerCardCount = 0;
        let selectedTower = 'princess';
        let towerCollection = {};
        let lastClaimDate = "";
        // --- NEW: Level Cap at 15 ---
        const towerUpgradeCosts = {
            1: { cards: 2, gold: 50 }, 2: { cards: 4, gold: 150 }, 3: { cards: 10, gold: 400 },
            4: { cards: 20, gold: 1000 }, 5: { cards: 50, gold: 2000 }, 6: { cards: 100, gold: 4000 },
            7: { cards: 200, gold: 8000 }, 8: { cards: 400, gold: 16000 }, 9: { cards: 800, gold: 32000 },
            10: { cards: 1000, gold: 50000 }, 11: { cards: 1500, gold: 75000 }, 12: { cards: 2000, gold: 100000 },
            13: { cards: 3000, gold: 150000 }, 14: { cards: 5000, gold: 200000 },
        };
        const towerDefs = {
            'princess': { name: 'Princess', emoji: 'üë∏', desc: 'Standard tower.', healthMod: 1, dmgMod: 1, speedMod: 1, special: null },
            'waffle': { name: 'Waffle Maker', emoji: 'üßá', desc: 'King throws waffles that level up troops! Weaker stats.', healthMod: 0.8, dmgMod: 0.8, speedMod: 1.2, special: 'waffle' },
            'machineGun': { name: 'Machine Gun', emoji: 'üî´', desc: 'Bursts rapid fire for 3s then slows down.', healthMod: 0.7, dmgMod: 0.6, speedMod: 0.25, special: 'burst' },
            'rocketeer': { name: 'Rocketeer', emoji: 'üöÄ', desc: 'Slow but heavy damage. Low health.', healthMod: 0.5, dmgMod: 5.0, speedMod: 3.0, special: 'rocket' }
        };
        const towerStats = {
            1: { kingHealth: 2000, princessHealth: 1000, damage: 50, hitSpeed: 1 },
            2: { kingHealth: 2200, princessHealth: 1100, damage: 55, hitSpeed: 1 },
            3: { kingHealth: 2420, princessHealth: 1210, damage: 60, hitSpeed: 1 },
            4: { kingHealth: 2662, princessHealth: 1331, damage: 66, hitSpeed: 1 },
            5: { kingHealth: 2928, princessHealth: 1464, damage: 72, hitSpeed: 1 },
            6: { kingHealth: 3220, princessHealth: 1610, damage: 79, hitSpeed: 1 },
            7: { kingHealth: 3542, princessHealth: 1771, damage: 87, hitSpeed: 1 },
            8: { kingHealth: 3896, princessHealth: 1948, damage: 96, hitSpeed: 1 },
            9: { kingHealth: 4285, princessHealth: 2142, damage: 105, hitSpeed: 1 },
            10: { kingHealth: 4713, princessHealth: 2356, damage: 116, hitSpeed: 1 },
            11: { kingHealth: 5184, princessHealth: 2591, damage: 128, hitSpeed: 1 },
            12: { kingHealth: 5702, princessHealth: 2850, damage: 141, hitSpeed: 1 },
            13: { kingHealth: 6272, princessHealth: 3135, damage: 155, hitSpeed: 1 },
            14: { kingHealth: 6899, princessHealth: 3448, damage: 170, hitSpeed: 1 },
            15: { kingHealth: 7589, princessHealth: 3793, damage: 187, hitSpeed: 1 },
        };

        let selectedSpawningUnit = null;
        let isSpawningSpell = false;
        let spellRadius = 0;
        let placementRadius = 0;
        let canPlace = false;
        const arenaFloors = { 0: "Arena 1: Emoji Valley", 250: "Arena 2: Laughing Village", 500: "Arena 3: Lava Town", 750: "Arena 4: The Farm", 1000: "Arena 5: Skull Kingdom", 1250: "Arena 6: Warlock's Workshop", 1500: "Arena 7: Mages Graveyard", 1750: "Arena 8: Chaos Canyon", 2000: "Arena 9: Titan's Peak", 2250: "Arena 10: Chaos Realm" };
        let currentArenaFloor = 0;
        let currentArenaTheme = 'arena-1'; // For canvas styling

        // --- NEW: Level Cap at 15 ---
        const upgradeCosts = {
            1: { cards: 2, gold: 50 }, 2: { cards: 4, gold: 150 }, 3: { cards: 10, gold: 400 },
            4: { cards: 20, gold: 1000 }, 5: { cards: 50, gold: 2000 }, 6: { cards: 100, gold: 4000 },
            7: { cards: 200, gold: 8000 }, 8: { cards: 400, gold: 16000 }, 9: { cards: 800, gold: 32000 },
            10: { cards: 1000, gold: 50000 }, 11: { cards: 1500, gold: 75000 }, 12: { cards: 2000, gold: 100000 },
            13: { cards: 3000, gold: 150000 }, 14: { cards: 5000, gold: 200000 },
        };
        let isDataSaved = true; // Flag to control saving
        let isInitialAuthCheck = true; // Flag to stop auto-login
        let loadTimeout; // Timer for stuck loads
        let isLoading = false; // Flag to prevent double-loads
        let hasShownUpdateLog = false; // Flag to track if update log has been shown this session
        let generateKeyTimeout; // NEW: Timer for save key generation
        
        // --- NEW: Demo Mode ---
        let isDemoMode = false;
        
        // --- Background Particle System ---
        const bgCanvas = document.getElementById('bgCanvas');
        const bgCtx = bgCanvas.getContext('2d');
        let bgParticles = [];

        function resizeBg() {
            bgCanvas.width = window.innerWidth;
            bgCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeBg);
        resizeBg();

        class BgParticle {
            constructor(initial = false) { 
                this.reset(initial); 
            }
            reset(initial = false) {
                this.x = Math.random() * bgCanvas.width;
                this.y = Math.random() * bgCanvas.height;
                this.size = Math.random() * 4 + 1; // Smaller: 1-5px
                this.speedX = (Math.random() - 0.5) * 1.5; // Faster
                this.speedY = (Math.random() - 0.5) * 1.5;
                this.maxLife = Math.random() * 300 + 200;
                this.life = initial ? Math.random() * this.maxLife : 0;
                this.state = initial ? 'idle' : 'in';
                this.targetAlpha = 0.3 + Math.random() * 0.3; // More varied opacity
                this.alpha = initial ? this.targetAlpha : 0;
            }
            update() {
                this.x += this.speedX; 
                this.y += this.speedY;
                
                // Wrap around screen
                if (this.x < 0) this.x = bgCanvas.width;
                if (this.x > bgCanvas.width) this.x = 0;
                if (this.y < 0) this.y = bgCanvas.height;
                if (this.y > bgCanvas.height) this.y = 0;

                if (this.state === 'in') {
                    this.alpha += 0.01;
                    if (this.alpha >= this.targetAlpha) this.state = 'idle';
                } else if (this.state === 'idle') {
                    this.life++;
                    if (this.life > this.maxLife) this.state = 'out';
                } else if (this.state === 'out') {
                    this.alpha -= 0.01;
                    if (this.alpha <= 0) this.reset();
                }
            }
            draw() {
                // Snow White
                bgCtx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
                bgCtx.beginPath();
                bgCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                bgCtx.fill();
            }
        }
        // More particles, start pre-populated
        for(let i=0; i<80; i++) bgParticles.push(new BgParticle(true));

        function animateBg() {
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            // Draw Grid
            bgCtx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            bgCtx.lineWidth = 1;
            const gridSize = 40;
            bgCtx.beginPath();
            for(let x=0; x<=bgCanvas.width; x+=gridSize) { bgCtx.moveTo(x,0); bgCtx.lineTo(x, bgCanvas.height); }
            for(let y=0; y<=bgCanvas.height; y+=gridSize) { bgCtx.moveTo(0,y); bgCtx.lineTo(bgCanvas.width, y); }
            bgCtx.stroke();
            
            bgParticles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(animateBg);
        }
        animateBg();
        let demoLoopTimer = 15 * 60; // 15 seconds
        const DEMO_LOOP_TIME = 15 * 60;
        let demoFadingOut = false; // NEW
        let demoFadeTimer = 0; // NEW
        const DEMO_FADE_TIME = 30; // 0.5 seconds

        // --- NEW: Game Mode State ---
        let gameMode = 'trophy'; // 'trophy', 'party1v1', '2v2'
        let is2v2Friend = false;
        let is2v2AITeammate = false;
        let twoVtwoLobbyCode = null;
        let twoVtwoLobbyLocked = false;
        let twoVtwoInFriendMatch = false;
        let twoVtwoPlayAgainRequested = false;

        // --- Start Game ---
        window.onload = () => {

            // --- Domain Lock Security ---
            const isLocalFile = window.location.protocol === 'file:';
            const allowedHosts = [
                'coolrandomwebsite99-lab.github.io',
                'scf.usercontent.goog'
            ];
            const currentHost = window.location.hostname;
            const isLocalhost = currentHost === "localhost" || currentHost === "";
            
            const isAllowed = allowedHosts.some(host => currentHost.endsWith(host)) || isLocalhost;

            if (!isAllowed) {
                console.error("Game running on unauthorized domain:", currentHost);
                
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('introScreen').style.display = 'none';
                const gameScreen = document.getElementById('gameScreen');
                if (gameScreen) gameScreen.style.display = 'flex';
                
                const unauthScreen = document.getElementById('unauthorizedScreen');
                if (unauthScreen) {
                    unauthScreen.style.display = 'flex';
                    unauthScreen.querySelector('#errorReasonText').textContent = 'Error: This game is not authorized to run on this domain.';
                    unauthScreen.querySelector('#imagineText').textContent = 'Imagine... what could have been.';
                }

                document.getElementById('cardHand').style.display = 'none';
                document.getElementById('nextCardSlot').parentElement.style.display = 'none';
                document.getElementById('elixirBar').parentElement.parentElement.style.display = 'none';
                document.getElementById('timerDisplay').style.display = 'none';
                document.getElementById('menuButton').style.display = 'none';

                isDemoMode = true;
                lastTime = performance.now();
            }

            // Debug menu enabled for all environments
            if (false) {
                const debugButtons = document.querySelectorAll('[data-screen="debug"]');
                debugButtons.forEach(btn => btn.style.display = 'none');
                const debugScreen = document.getElementById('debugScreen');
                if (debugScreen) debugScreen.style.display = 'none';
            }
            // --- END: Domain Lock Security ---


            // --- Game Constants ---
            const WIDTH = 400; // Define constants first
            const HEIGHT = 500;
            const RIVER_Y = HEIGHT / 2;
            const BRIDGE_Y = RIVER_Y;
            const PLAYER_SPAWN_LIMIT_Y = RIVER_Y;
            const AI_SPAWN_LIMIT_Y = RIVER_Y;
            const AI_SPAWN_ZONE_LIMIT = HEIGHT * 0.3; // NEW: 30% from top
            const LANE_LEFT_X = WIDTH / 4;
            const LANE_RIGHT_X = (WIDTH / 4) * 3;
            const MAX_ELIXIR = 10;
            const BASE_ELIXIR_REGEN_RATE = 0.008;
            const REGULATION_TIME = 120 * 60;
            const OVERTIME_TIME = 120 * 60;
            
            // NEW: Drag sensitivity
            const DRAG_SENSITIVITY = 10; // Pixels
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;

            // --- Enemy AI (2v2: two AIs) ---
            let aiThinkTimer = 0;
            let ai2ThinkTimer = 0;
            let aiElixir = 0;
            let ai2Elixir = 0;
            let aiHand = [];
            let ai2Hand = [];
            let aiDeck = [];
            let ai2Deck = [];
            let aiDiscardPile = [];
            let ai2DiscardPile = [];
            let aiNextCard = null;
            let ai2NextCard = null; // Add NEXT card for second AI
            let aiTowerLevel = 1;
            let ai2TowerLevel = 1;
            let currentAiStatLevel = 1;
            let currentAi2StatLevel = 1;
            let gameTimer = REGULATION_TIME;
            let isOvertime = false;
            let currentElixirRate = BASE_ELIXIR_REGEN_RATE;
            let isTieBreaker = false;
            let tieBreakerTick = 0;
            let overtimeInitialPlayerTowers = 0; // NEW: For sudden death
            let overtimeInitialAiTowers = 0; // NEW: For sudden death
            // NEW: Track destroyed towers for spawn zones
            let playerLeftTowerDestroyed = false;
            let playerRightTowerDestroyed = false;
            let aiLeftTowerDestroyed = false;
            let aiRightTowerDestroyed = false;

            // --- Game State ---
            let gameObjects = [];
            let playerElixir = 3;
            let gameRunning = false;

            // --- DOM Elements ---
            const screens = document.querySelectorAll('.screen');
            const navButtons = document.querySelectorAll('.nav-btn');
            const persistentNav = document.getElementById('bottomNav');
            const navHighlight = document.getElementById('navHighlight');
            const logoutBtn = document.getElementById('logoutBtn');
            if (logoutBtn) {
                // Direct assignment to replace any existing listeners
                logoutBtn.onclick = async (e) => {
                    e.preventDefault();
                    if (confirm('Log out and return to title screen?')) {
                        try {
                            if (auth) await signOut(auth);
                        } catch (e) {
                            console.warn("Sign out error (ignoring):", e);
                        }
                        
                        // Reset local session state
                        initGuestSession();
                        
                        // Force UI updates
                        const intro = document.getElementById('introScreen');
                        if (intro) intro.style.display = 'none';
                        if (persistentNav) persistentNav.style.display = 'none';
                        
                        // Reset all screens scroll position
                        document.querySelectorAll('.screen').forEach(s => s.scrollTop = 0);

                        // Navigate to login
                        showScreen('login');
                    }
                };
            }
            const loginScreen = document.getElementById('loginScreen');
            const googleLoginBtn = document.getElementById('googleLoginBtn');
            const trueGuestLoginBtn = document.getElementById('trueGuestLoginBtn'); // FIXED
            const loginError = document.getElementById('loginError'); 
            const loadingScreen = document.getElementById('loadingScreen');
            const menuScreen = document.getElementById('menuScreen');
            const gameScreen = document.getElementById('gameScreen');
            const deckScreen = document.getElementById('deckScreen');
            const towerScreen = document.getElementById('towerScreen');
            const arenaScreen = document.getElementById('arenaScreen'); // NEW
            const debugScreen = document.getElementById('debugScreen'); // NEW
            const battleButton = document.getElementById('battleButton');
            const modeTrophy = document.getElementById('modeTrophy');
            const modeParty1v1 = document.getElementById('modeParty1v1');
            const mode2v2 = document.getElementById('mode2v2');
            const modeDisplay = document.getElementById('modeDisplay');
            const arenaButton = document.getElementById('arenaButton'); // NEW
            const arenaBackButton = document.getElementById('arenaBackButton'); // NEW
            const trophyDisplay = document.getElementById('trophyDisplay');
            const goldDisplay = document.getElementById('goldDisplay');
            const chestSlots = document.getElementById('chestSlots');
            const arenaName = document.getElementById('arenaName');
            const arenaEmoji = document.getElementById('arenaEmoji');
            const deckCardGrid = document.getElementById('deckCardGrid');
            const collectionCardGrid = document.getElementById('collectionCardGrid');
            const lockedCardGrid = document.getElementById('lockedCardGrid'); 
            const deckCount = document.getElementById('deckCount');
            const teammateChoiceModal = document.getElementById('teammateChoiceModal');
            const aiTeammateBtn = document.getElementById('aiTeammateBtn');
            const friendTeammateBtn = document.getElementById('friendTeammateBtn');
            const cancelTeammateBtn = document.getElementById('cancelTeammateBtn');
            const friendCodeModal = document.getElementById('friendCodeModal');
            const createCodeBtn = document.getElementById('createCodeBtn');
            const joinCodeBtn = document.getElementById('joinCodeBtn');
            const cancelFriendBtn = document.getElementById('cancelFriendBtn');
            const createCodeModal = document.getElementById('createCodeModal');
            const generatedCode = document.getElementById('generatedCode');
            const cancelCreateBtn = document.getElementById('cancelCreateBtn');
            const joinCodeModal = document.getElementById('joinCodeModal');
            const codeInput = document.getElementById('codeInput');
            const confirmJoinBtn = document.getElementById('confirmJoinBtn');
            const cancelJoinBtn = document.getElementById('cancelJoinBtn');
            const aiTeammateUI = document.getElementById('aiTeammateUI');
            const aiTeammateHand = document.getElementById('aiTeammateHand');
            const aiTeammateNext = document.getElementById('aiTeammateNext');
            const aiTeammateElixirBar = document.getElementById('aiTeammateElixirBar');
            const aiTeammateElixirCount = document.getElementById('aiTeammateElixirCount');
            const cardHandEl = document.getElementById('cardHand');
            const nextCardSlotEl = document.getElementById('nextCardSlot');
            const placementIndicator = document.getElementById('placementIndicator');
            const placementOverlay = document.getElementById('placementOverlay'); // NEW
            const menuButton = document.getElementById('menuButton');
            const towerLevelDisplay = document.getElementById('towerLevelDisplay');
            const towerInfoStats = document.getElementById('towerInfoStats');
            const towerInfoProgressContainer = document.getElementById('towerInfoProgressContainer');
            const towerInfoProgressBar = document.getElementById('towerInfoProgressBar');
            const towerInfoProgressText = document.getElementById('towerInfoProgressText');
            const towerUpgradeButton = document.getElementById('towerUpgradeButton');
            const cardInfoModal = document.getElementById('cardInfoModal');
            const cardInfoCloseBtn = document.getElementById('cardInfoCloseBtn');
            const cardInfoDisplay = document.getElementById('cardInfoDisplay');
            const cardInfoName = document.getElementById('cardInfoName');
            const cardInfoType = document.getElementById('cardInfoType');
            const cardInfoLevel = document.getElementById('cardInfoLevel');
            const cardInfoStats = document.getElementById('cardInfoStats');
            const cardInfoButtons = document.getElementById('cardInfoButtons'); 
            const cardInfoProgressContainer = document.getElementById('cardInfoProgressContainer');
            const cardInfoProgressBar = document.getElementById('cardInfoProgressBar');
            const cardInfoProgressText = document.getElementById('cardInfoProgressText');
            const cardInfoButton = document.getElementById('cardInfoButton');
            const chestOpenOverlay = document.getElementById('chestOpenOverlay');
            const chestRewardList = document.getElementById('chestRewardList');
            const chestCloseButton = document.getElementById('chestCloseButton');
            // Debug Buttons
            const debugArena2 = document.getElementById('debugArena2');
            const debugArena3 = document.getElementById('debugArena3');
            const debugArena4 = document.getElementById('debugArena4'); // NEW
            const debugArena5 = document.getElementById('debugArena5'); // NEW
            const debugArena6 = document.getElementById('debugArena6');
            const debugArena7 = document.getElementById('debugArena7');
            const debugArena8 = document.getElementById('debugArena8');
            const debugArena9 = document.getElementById('debugArena9');
            const debugArena10 = document.getElementById('debugArena10');
            const debugUnlockAll = document.getElementById('debugUnlockAll');
            const debugUpgradeAll = document.getElementById('debugUpgradeAll');
            const debugGetChest = document.getElementById('debugGetChest');
            const debugAddGold = document.getElementById('debugAddGold');
            const debugReset = document.getElementById('debugReset');
            // Debug Password
            const debugPasswordOverlay = document.getElementById('debugPasswordOverlay');
            const debugPasswordInput = document.getElementById('debugPasswordInput');
            const debugPasswordSubmit = document.getElementById('debugPasswordSubmit');
            const debugPasswordCancel = document.getElementById('debugPasswordCancel');
            // NEW: Save/Load Data
            const saveDataBtn = document.getElementById('saveDataBtn');
            const saveDataOverlay = document.getElementById('saveDataOverlay');
            const generateKeyBtn = document.getElementById('generateKeyBtn');
            const saveKeyOutput = document.getElementById('saveKeyOutput');
            const saveDataCancel = document.getElementById('saveDataCancel');
            const loadKeyBtn = document.getElementById('loadKeyBtn');
            const loadDataOverlay = document.getElementById('loadDataOverlay');
            const loadKeyInput = document.getElementById('loadKeyInput');
            const loadKeySubmit = document.getElementById('loadKeySubmit');
            const loadDataCancel = document.getElementById('loadDataCancel');
            // Update Log
            const updateLogOverlay = document.getElementById('updateLogOverlay');
            const updateLogContent = document.getElementById('updateLogContent');
            const updateLogClose = document.getElementById('updateLogClose');


            // --- Game Elements (from gameScreen) ---
    const canvas = document.getElementById('gameCanvas');
    let ctx;
    if (!canvas) {
        console.error("Critical Error: Game canvas not found. Stopping game initialization.");
        return;
    }
    ctx = canvas.getContext('2d');
            const elixirBar = document.getElementById('elixirBar');
            const elixirText = document.getElementById('elixirText');
            const messageOverlay = document.getElementById('messageOverlay');
            const messageText = document.getElementById('messageText');
            const startButton = document.getElementById('startButton');
            const timerDisplay = document.getElementById('timerDisplay');


            // ==============================================
            // FIREBASE & USER DATA
            // ==============================================
            
            // This is the function that runs after a login attempt
            async function handleAuth(user) {
                // This 'if' block stops the auto-login on page load
                if (isInitialAuthCheck) {
                    isInitialAuthCheck = false;
                    
                    // --- REFERENCEERROR FIX ---
                    // initCardSystem() call REMOVED from here. It's now called *after* classes are defined.
                    // --- END FIX ---
                    
                    return;
                }
                
                // If the login was real (not auto), and not a guest
                if (user && !user.isAnonymous) {
                    // Prevent this from running twice if it's already loading
                    if (isLoading) return;
                    isLoading = true;

                    userId = user.uid;
                    userDocRef = doc(db, 'artifacts', appId, 'users', userId);
                    isDataSaved = true; // Assume we can save unless timer fires
                    
                    showScreen('loading');
                    loadingScreen.querySelector('p').textContent = 'Loading Progress...';
                    
                    // Clear any old timer
                    clearTimeout(loadTimeout);
                    
                    // --- NEW: The 8-second "failsafe" timer ---
                    loadTimeout = setTimeout(() => {
                        console.warn("Firebase load took too long! (8s)");
                        // If it's still loading, force it to stop and start a new game
                        if (isLoading) {
                            isLoading = false;
                            isDataSaved = false; // Disable saving to prevent overwrite
                            initNewUser(); // Load a blank game locally
                            showScreen('menu'); // Go to menu
                        }
                    }, 8000); // 8 seconds

                    try {
                        await loadUserData();
                    } catch (error) {
                        console.error("Error in loadUserData:", error);
                        initNewUser(); // If loading fails, start a new game
                    } finally {
                        // This code runs *only if* loading finishes *before* the 8-second timer
                        if (isLoading) {
                            clearTimeout(loadTimeout); // Cancel the failsafe timer
                            isLoading = false;
                            showScreen('menu'); // Go to menu normally
                        }
                    }

                } else {
                    // Not logged in or is anonymous
                    userId = null;
                    userDocRef = null;
                    isDataSaved = false;
                    isLoading = false;
                    showScreen('login');
                }
            }

            function initNewUser() {
                trophies = 0;
                gold = 500;
                towerLevel = 1;
                towerCardCount = 0;
                selectedTower = 'princess';
                towerCollection = { 'princess': { level: 1, count: 0, unlocked: true } };
                trophyChests = [];
                cardCollection = initNewUserCards(false);
                playerDeck = initNewUserCards(true);
                playerDeck2v2 = []; 
                playerDeckParty = [];
                lastClaimDate = "";
                // We don't save here, we let the game save after a win/loss
            }

            // NEW: "Guest (No Save)" logic
            function initGuestSession() {
                initNewUser(); // Load default data
                
                // Disable saving
                userDocRef = null; 
                userId = null;
                isDataSaved = false; // Prevent save attempts
            }

            async function loadUserData(dataToLoad = null) {
                // Load from a manual save key (guest-style)
                if (dataToLoad) {
                    trophies = dataToLoad.trophies || 0;
                    gold = dataToLoad.gold || 500;
                    towerLevel = dataToLoad.towerLevel || 1;
                    towerCardCount = dataToLoad.towerCardCount || 0;
                    trophyChests = dataToLoad.trophyChests || [];
                    cardCollection = dataToLoad.cardCollection || initNewUserCards(false);
                    playerDeck = dataToLoad.playerDeck || initNewUserCards(true);
                    playerDeck2v2 = dataToLoad.playerDeck2v2 || [];
                    playerDeckParty = dataToLoad.playerDeckParty || [];
                    lastClaimDate = dataToLoad.lastClaimDate || "";
                    return;
                }

                // Normal Firebase-backed load
                if (!userDocRef) {
                    // No user doc; just start a new user locally
                    initNewUser();
                    return;
                }

                try {
                    const docSnap = await getDoc(userDocRef);
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        trophies = data.trophies || 0;
                        gold = data.gold || 500;
                        towerLevel = data.towerLevel || 1;
                        towerCardCount = data.towerCardCount || 0;
                        selectedTower = data.selectedTower || 'princess';
                        towerCollection = data.towerCollection || { 'princess': { level: data.towerLevel || 1, count: data.towerCardCount || 0, unlocked: true } };
                        trophyChests = data.trophyChests || [];
                    cardCollection = data.cardCollection || initNewUserCards(false);
                    playerDeck = data.playerDeck || initNewUserCards(true);
                    playerDeck2v2 = data.playerDeck2v2 || [];
                    playerDeckParty = data.playerDeckParty || [];
                    lastClaimDate = data.lastClaimDate || "";
                    } else {
                        // First time user: init defaults
                        initNewUser();
                    }
                } catch (error) {
                    console.error("Error loading user data:", error);
                    // If loading fails, just start a new game locally and disable saving
                    isDataSaved = false;
                    initNewUser();
                }
            }

            function initNewUserCards(deckOnly = false) {
                let newCollection = {};
                
                // Add all cards to collection with count 0 (except Arena 1)
                for (const cardId in allCards) {
                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Don't add tower or internal mini to collection
                    newCollection[cardId] = { level: 1, count: 0, unlocked: false }; // ADDED unlocked
                }
                
                // Add Arena 1 cards with count 1
                for (const cardId in allCards) {
                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Don't add tower or internal mini to collection
                    if (allCards[cardId].arena === 1) {
                        newCollection[cardId] = { level: 1, count: 1, unlocked: true }; // ADDED unlocked
                    }
                }
                
                if (deckOnly) {
                    // FIX: Filter out 'tower' from starting deck
                    return Object.keys(allCards).filter(id => allCards[id].arena === 1 && id !== 'tower' && id !== 'stoneGiant' && id !== 'miniStoneGiant');
                }
                return newCollection;
            }

            async function saveUserData() {
                if (!isDataSaved) return; // This will be false for guests
                
                // Use Firebase if logged in
                if (userDocRef) {
                    isDataSaved = false; // Prevent multiple saves
                    try {
                        const dataToSave = {
                            trophies,
                            gold,
                            towerLevel,
                            towerCardCount,
                            selectedTower,
                            towerCollection,
                            trophyChests,
                            cardCollection,
                            playerDeck,
                            playerDeck2v2,
                            playerDeckParty,
                            lastClaimDate,
                            lastSaved: new Date().toISOString()
                        };
                        await setDoc(userDocRef, dataToSave, { merge: true });
                    } catch (error) {
                        console.error("Error saving user data:", error);
                    }
                    isDataSaved = true; // Allow saving again
                }
                // If not logged in (e.g., guest mode), we simply don't save.
            }
            
            if (googleLoginBtn) googleLoginBtn.addEventListener('click', async () => {
                loginError.textContent = '';
                try {
                    // This will trigger the onAuthStateChanged listener
                    await signInWithPopup(auth, provider);
                } catch (error) {
                    isLoading = false; // Make sure loading stops on fail
                    if (error.code === 'auth/unauthorized-domain') {
                        loginError.textContent = 'Google Sign-in is not set up.';
                    } else if (error.code === 'auth/popup-blocked') {
                        loginError.textContent = 'Pop-up blocked! Please allow pop-ups.';
                    } else {
                        loginError.textContent = 'Could not sign in. Please try again.';
                    } 
                }
            });
            
            // "Play as Guest (No Save)" button
            if (trueGuestLoginBtn) trueGuestLoginBtn.addEventListener('click', () => {
                loginError.textContent = ''; // Clear errors
                initGuestSession(); // Load default data, disable saving
                showScreen('loading');
                loadingScreen.querySelector('p').textContent = 'Starting Guest Game...';
                setTimeout(() => showScreen('menu'), 1000); // Short delay
            });

            // --- NEW: Save/Load Key Logic ---
            if (saveDataBtn) saveDataBtn.addEventListener('click', () => {
                if (saveKeyOutput) saveKeyOutput.value = "Generating key...";
                if (generateKeyBtn) generateKeyBtn.disabled = true;
                if (generateKeyBtn) generateKeyBtn.textContent = 'Generate New Key (30s)';
                if (saveDataOverlay) saveDataOverlay.style.display = 'flex';

                // Generate key
                const dataToSave = {
                    trophies, gold, towerLevel, towerCardCount, 
                    trophyChests, cardCollection, playerDeck, playerDeck2v2, playerDeckParty, lastClaimDate
                };
                const jsonString = JSON.stringify(dataToSave);
                const saveKey = btoa(jsonString); // Base64 encode
                saveKeyOutput.value = saveKey;

                // Start cooldown
                let cooldown = 30;
                generateKeyBtn.textContent = `Generate New Key (${cooldown}s)`;
                clearTimeout(generateKeyTimeout);
                generateKeyTimeout = setInterval(() => {
                    cooldown--;
                    generateKeyBtn.textContent = `Generate New Key (${cooldown}s)`;
                    if (cooldown <= 0) {
                        clearInterval(generateKeyTimeout);
                        generateKeyBtn.textContent = 'Generate New Key';
                        generateKeyBtn.disabled = false;
                    }
                }, 1000);
            });
            if (saveDataCancel) saveDataCancel.addEventListener('click', () => {
                if (saveDataOverlay) saveDataOverlay.style.display = 'none';
                clearInterval(generateKeyTimeout);
                if (generateKeyBtn) generateKeyBtn.disabled = false;
                if (generateKeyBtn) generateKeyBtn.textContent = 'Generate New Key';
            });
            if (generateKeyBtn) generateKeyBtn.addEventListener('click', () => {
                // Re-generate key and start cooldown
                if (saveDataBtn) saveDataBtn.click(); // Just re-click the main button
            });
            if (loadKeyBtn) loadKeyBtn.addEventListener('click', () => {
                if (loadKeyInput) {
                    loadKeyInput.value = '';
                    loadKeyInput.placeholder = 'Paste your key here';
                }
                if (loadDataOverlay) loadDataOverlay.style.display = 'flex';
            });
            loadDataCancel.addEventListener('click', () => {
                loadDataOverlay.style.display = 'none';
            });

            // --- Mode Selector Logic ---
            function updateModeUI() {
                // Reset all
                [modeTrophy, modeParty1v1, mode2v2].forEach(btn => {
                    btn.classList.remove('bg-red-600', 'text-white');
                    btn.classList.add('bg-gray-700', 'text-gray-400');
                    btn.classList.remove('active');
                });
                
                let activeBtn;
                let modeText = "";
                if (gameMode === 'trophy') { activeBtn = modeTrophy; modeText = "Trophy Road"; }
                else if (gameMode === 'party1v1') { activeBtn = modeParty1v1; modeText = "1v1"; }
                else if (gameMode === '2v2') { activeBtn = mode2v2; modeText = "2v2"; }

                if (activeBtn) {
                    activeBtn.classList.remove('bg-gray-700', 'text-gray-400');
                    activeBtn.classList.add('bg-red-600', 'text-white');
                    activeBtn.classList.add('active');
                }
                if (modeDisplay) modeDisplay.textContent = modeText;
                updateAITeammateUI(); // NEW: Update AI Teammate UI visibility when mode changes
            }

            if (modeTrophy) modeTrophy.addEventListener('click', () => { gameMode = 'trophy'; updateModeUI(); renderDeckScreen(); updateBattleButtonState(); });
            if (modeParty1v1) modeParty1v1.addEventListener('click', () => { gameMode = 'party1v1'; updateModeUI(); renderDeckScreen(); updateBattleButtonState(); });
            if (mode2v2) mode2v2.addEventListener('click', () => { gameMode = '2v2'; updateModeUI(); renderDeckScreen(); updateBattleButtonState(); });

            // Initialize mode UI
            updateModeUI();

            // --- 2v2 Teammate Choice Modal ---
            function show2v2TeammateChoice() {
                // Always play with AI Teammate as 'friend' button is removed
                aiTeammateBtn.click();
            }

            function hide2v2TeammateChoice() {
                teammateChoiceModal.style.display = 'none';
            }

            if (aiTeammateBtn) aiTeammateBtn.addEventListener('click', () => {
                hide2v2TeammateChoice();
                is2v2AITeammate = true;
                is2v2Friend = false;
                // TODO: replace with 2v2 initGame2v2 later
                menuScreen.classList.remove('active');
                loadingScreen.classList.add('active');
                loadingScreen.querySelector('p').textContent = 'Finding 2v2 Match...';
                setTimeout(() => {
                    showScreen('game');
                    messageText.textContent = 'Get Ready!';
                    startButton.style.display = 'none';
                    menuButton.style.display = 'none';
                    messageOverlay.style.display = 'flex';
                    setTimeout(() => {
                        initGame(); // TEMP: use normal init until 2v2 logic is added
                        lastTime = performance.now();
                        gameLoopId = requestAnimationFrame(gameLoop);
                    }, 1500);
                }, 1000);
            });

                        if (friendTeammateBtn) friendTeammateBtn.addEventListener('click', () => {
                hide2v2TeammateChoice();
                is2v2Friend = true;
                is2v2AITeammate = false;
                showFriendCodeModal();
            });

            if (cancelTeammateBtn) cancelTeammateBtn.addEventListener('click', () => {
                hide2v2TeammateChoice();
            });
            function hideFriendCodeModal() {
                friendCodeModal.style.display = 'none';
            }

            function showCreateCodeModal() {
                alert("Multiplayer features are currently disabled.");
            }

            function hideCreateCodeModal() {
                createCodeModal.style.display = 'none';
            }

            function showJoinCodeModal() {
                joinCodeModal.style.display = 'flex';
                codeInput.value = '';
            }

            function hideJoinCodeModal() {
                joinCodeModal.style.display = 'none';
            }

            function startFriend2v2Match() {
                // This function is now handled by the multiplayer script at the bottom
            }

            friendTeammateBtn.addEventListener('click', () => {
                hide2v2TeammateChoice();
                showFriendCodeModal();
            });

            if (cancelFriendBtn) cancelFriendBtn.addEventListener('click', () => {
                hideFriendCodeModal();
            });

            if (createCodeBtn) createCodeBtn.addEventListener('click', () => {
                hideFriendCodeModal();
                showCreateCodeModal();
            });

            // cancelCreateBtn is now handled in the multiplayer script

            if (joinCodeBtn) joinCodeBtn.addEventListener('click', () => {
                hideFriendCodeModal();
                showJoinCodeModal();
            });

            
                        // cancelJoinBtn is now handled in the multiplayer script
            if (loadKeySubmit) loadKeySubmit.addEventListener('click', async () => {
                const saveKey = loadKeyInput.value;
                if (!saveKey) return;
                try {
                    // We're loading a key, so treat as a "Guest" session (no Firebase save)
                    initGuestSession(); 
                    // Now, load the data from the key
                    const decodedString = atob(saveKey); // Decode Base64
                    const parsedData = JSON.parse(decodedString); // Parse JSON
                    await loadUserData(parsedData); 

                    loadDataOverlay.style.display = 'none';
                    showScreen('loading');
                    loadingScreen.querySelector('p').textContent = 'Loading Progress...';
                    setTimeout(() => showScreen('menu'), 1000);

                } catch (error) {
                    console.error("Failed to load save key:", error);
                    loadKeyInput.value = '';
                    loadKeyInput.placeholder = 'Invalid key! Please try again.';
                }
            });


            // ==============================================
            // SCREEN & NAVIGATION LOGIC
            // ==============================================
                        const navOrder = ['menu', 'deck', 'tower', 'events', 'debug'];
            function showScreen(screenId) {
                // Handle Screen Transitions
                const prevScreenIndex = navOrder.indexOf(currentScreen);
                const nextScreenIndex = navOrder.indexOf(screenId);
                const isNavTransition = prevScreenIndex !== -1 && nextScreenIndex !== -1;

                currentScreen = screenId;

                screens.forEach(s => {
                    s.classList.remove('active', 'swipe-left', 'swipe-right', 'fade-in');
                    if (s.id === screenId + 'Screen') {
                        s.classList.add('active');
                        if (isNavTransition) {
                            if (nextScreenIndex > prevScreenIndex) s.classList.add('swipe-right');
                            else s.classList.add('swipe-left');
                        } else {
                            s.classList.add('fade-in');
                        }
                    }
                });
                
                // Handle Persistent Nav
                if (['menu', 'deck', 'tower', 'events', 'debug'].includes(screenId)) {
                    persistentNav.style.display = 'block';
                    // Slight delay to allow display:block to apply before transform if needed
                    requestAnimationFrame(() => persistentNav.style.transform = 'translate(-50%, 0)');

                    navButtons.forEach((btn, index) => { 
                        btn.classList.remove('text-yellow-400'); 
                        btn.classList.add('text-gray-400'); 

                        if (btn.dataset.screen === screenId) { 
                            btn.classList.add('text-yellow-400'); 
                            btn.classList.remove('text-gray-400');
                            // Move Highlight
                            if (navHighlight) {
                                navHighlight.style.left = `${index * 20}%`;
                            }
                        }
                    });
                } else {
                    // Hide nav for non-main screens (login, game, etc)
                    persistentNav.style.display = 'none';
                }
                
                if (screenId === 'deck') { renderDeckScreen(); }
                if (screenId === 'tower') { renderTowerScreen(); }
                if (screenId === 'events') { updateChristmasUI(); }
                if (screenId === 'menu') { 
                    updateArena(); 
                    trophyDisplay.textContent = `üèÜ ${trophies}`; 
                    goldDisplay.textContent = `üí∞ ${gold}`; 
                    renderChests(); 
                    updateBattleButtonState(); 
                    // Show update log once after loading screen
                    if (!hasShownUpdateLog) {
                        hasShownUpdateLog = true;
                        setTimeout(() => showUpdateLog(), 300); // Small delay to ensure menu is visible
                    }
                }
            }

            function showDebugPassword() {
                // isLocalFile check removed to enable debug for all environments
                debugPasswordInput.value = '';
                debugPasswordOverlay.style.display = 'flex';
                debugPasswordInput.focus();
            }
                        if (debugPasswordSubmit) debugPasswordSubmit.addEventListener('click', () => {
                // isLocalFile check removed to enable debug for all environments
                if (debugPasswordInput && debugPasswordInput.value.toUpperCase() === 'GEOMETRIC') {
                    // Correct password entered: hide overlay, enable debug, show debug screen
                    if (debugPasswordOverlay) debugPasswordOverlay.style.display = 'none';
                    document.documentElement.removeAttribute('data-no-debug');
                    showScreen('debug'); // Show debug screen
                } else if (debugPasswordInput) { // If input exists and password is wrong
                    debugPasswordInput.value = '';
                    debugPasswordInput.placeholder = 'Wrong! Try again.';
                }
            });
            if (debugPasswordCancel) debugPasswordCancel.addEventListener('click', () => {
                if (debugPasswordOverlay) debugPasswordOverlay.style.display = 'none';
            });

            // NEW: Show update log function
            function showUpdateLog() {
            const updates = [
                { date: '11/28/2025', title: 'Tower Power & Arena Update', items: [
                    'üè∞ New Towers! Waffle Maker üßá, Machine Gun üî´, Rocketeer üöÄ',
                    'ü™¶ Added Arena 9: Titan\'s Peak (2000+ trophies)!',
                    'ü¶¥ New Card: Skeleton Yard - Spell that continuously spawns Skeletons.',
                        'üíÄüí£ New Card: Huge Skeleton - Tank that drops a giant bomb on death.',
                        'ü•∑ New Card: Ninja - Fast melee unit with high burst damage.',
                        '‚òÑÔ∏è New Card: Meteor - Powerful damage spell.',
                        'üî• Added Arena 10: Chaos Realm (2250+ trophies)!',
                        '‚ö°üí™ New Card: Zap Giant - Tank with electric field that zaps nearby enemies.',
                        'üí• New Card: Mega Smasher - Tank that deals spawn damage and jumps on enemies.',
                        'üê≤üî• New Card: Flame Dragon - Flying unit that ramps up damage over time.',
                        'üèØüî• New Card: Flame Tower - Defensive building with a ramping damage beam.',
                        'ü§ñ New Card: Bot - A tanky, hard-hitting mechanical walker.'
                    ]},
                    { date: '11/27/2025', title: 'Latest Update', items: [
                        'üéÑ Winter Wonderland Event is Live!',
                        '‚òÉÔ∏è Snowman Challenge: Battle the Snowman King!',
                        '‚ú® Visual Updates: New glowing text effects in Events tab'
                    ]},
                    { date: '11/25/2025', title: 'Previous Update', items: [
                        'Added 2v2 Mode: Team up with an AI teammate against two AI opponents',
                        'New King Tower Visuals: Combined king tower in 2v2 mode shows two crowns',
                        'AI Improvements: 2v2 AI opponents and teammates now use all available cards',
                        'UI Updates: Added health text display on all towers',
                        'Fixed various bugs with card restrictions and deck initialization'
                    ]},
                    { date: '11/24/2025', title: 'Previous Update', items: [
                        'Added Arena 8: Chaos Canyon (1750+ trophies) with custom card classes',
                        'Added Chaos Elemental card - Melee unit with high damage and speed (üëπ)',
                        'Added Shadow Clone card - Ranged unit with moderate damage (üë§)',
                        'Added Void Trap spell - Area damage spell for area control (‚ö´)',
                        'Added Stone Giant card - Tank unit with high health (üóø)',
                        'Added Chaos Orb spell - Damage spell for offense (üåÄ)',
                        'Buffed all Spirits: health increased from 50 to 150 (now takes 3 tower hits to kill)',
                        'Updated AI difficulty scaling per arena: Arena 1 lvl 1, Arena 2 lvl 1-2, Arena 3 lvl 2-3, Arena 4 lvl 2-3, Arena 5 lvl 4-5, Arena 6 lvl 4-5, Arena 7 lvl 5-6, Arena 8 lvl 5-6, Arena 9 lvl 6-7',
                        'Chests now give more money and cards in higher arenas'
                    ]},
                    { date: '11/22/2025', title: 'Previous Update', items: [
                        'Added Arena 7: Mages Graveyard (1500+ trophies)',
                        'Added Mage card - Ranged unit with splash damage, attacks ground and air. Every 5 seconds, spawns 4 Skeletons in a square around her.',
                        'Added Phantom Knight card: Spawns invisible and cannot be seen by enemy troops. Only attacks ground units. When attacking, becomes fully visible and can be targeted by enemy troops. Returns to invisible after 3 seconds of not attacking. Spells still hit invisible Phantom Knights. Spirits cannot see invisible Phantom Knights. Visual effect shows semi-transparent ghost when invisible.',
                        'Added Spirit Lantern card - Spawns a random spirit (Zap, Cold, or Life Spirit) every 6 seconds.',
                        'Added Arena 6: Warlock\'s Workshop (1250+ trophies)',
                        'Added Warlock card - Ranged unit with splash damage, attacks ground and air',
                        'Added Zap Spirit - Jumps on enemies and chains electricity to up to 10 targets',
                        'Added Cold Spirit - Jumps and freezes enemies in area for 3 seconds',
                        'Added Life Spirit - Jumps and creates healing circle for friendly units (3 seconds)',
                        'Added Bomb Spirit - Jumps and explodes damaging enemies in area',
                        'Added Spear Goblins card - Spawns 3 spear goblins (unlocks Arena 2)',
                        'Added Anger spell - Purple pool that gives 2x damage and 1.5x attack speed (5 seconds, persists 3s after leaving)',
                        'Buffed Skeletons and Skeleton Group: damage increased from 2 to 5'
                    ]},
                    { date: 'Previous Updates', title: 'Previous Features', items: [
                        'Arena system with 5 arenas',
                        'Card collection and deck building',
                        'Tower upgrades',
                        'Chest system',
                        'Multiple unit types and spells',
                        'AI opponents',
                        'Save/load system'
                    ]}
                ];
                
                let html = '';
                updates.forEach(update => {
                    html += `<div class="mb-4"><h3 class="font-bold text-lg text-yellow-400 mb-2">${update.title} - ${update.date}</h3><ul class="list-disc list-inside space-y-1">`;
                    update.items.forEach(item => {
                        html += `<li>${item}</li>`;
                    });
                    html += `</ul></div>`;
                });
                updateLogContent.innerHTML = html;
                updateLogOverlay.style.display = 'flex';
            }
            
            if (updateLogClose) updateLogClose.addEventListener('click', () => {
                if (updateLogOverlay) updateLogOverlay.style.display = 'none';
            });


            function updateArena() {
                // Reset theme first
                canvas.className = '';
                
                let currentTrophyFloor = 0;
                let arenaDisplayName = "Arena 1: Emoji Valley";
                let emoji = "üèûÔ∏è";
                currentArenaTheme = 'arena-1';
                
                for (const floor in arenaFloors) { if (trophies >= parseInt(floor)) { currentTrophyFloor = parseInt(floor); arenaDisplayName = arenaFloors[floor]; } }
                currentArenaFloor = currentTrophyFloor;
                
                if (arenaDisplayName.includes("Laughing Village")) {
                    emoji = "üèòÔ∏è";
                    currentArenaTheme = 'arena-2';
                } else if (arenaDisplayName.includes("Lava Town")) {
                    emoji = "üåã";
                    currentArenaTheme = 'arena-3';
                } else if (arenaDisplayName.includes("Mages Graveyard")) {
                    emoji = "ü™¶";
                    currentArenaTheme = 'arena-7';
                } else if (arenaDisplayName.includes("The Farm")) { // NEW
                    emoji = "üöú"; // NEW
                    currentArenaTheme = 'arena-4'; // NEW
                } else if (arenaDisplayName.includes("Skull Kingdom")) { // NEW
                    emoji = "üíÄ"; // NEW
                    currentArenaTheme = 'arena-5'; // NEW
                } else if (arenaDisplayName.includes("Warlock's Workshop")) { // NEW
                    emoji = "üîÆ"; // NEW
                    currentArenaTheme = 'arena-6'; // NEW
                } else if (arenaDisplayName.includes("Chaos Canyon")) { // NEW
                    emoji = "‚ö°"; // NEW
                    currentArenaTheme = 'arena-8'; // NEW
                } else if (arenaDisplayName.includes("Titan's Peak")) {
                    emoji = "üíÄ";
                    currentArenaTheme = 'arena-9';
                } else if (arenaDisplayName.includes("Chaos Realm")) {
                    emoji = "üî•";
                    currentArenaTheme = 'arena-10';
                }
                arenaName.textContent = arenaDisplayName;
                arenaEmoji.textContent = emoji;
                
                if (gameMode === 'snowman_challenge') {
                    canvas.className = 'christmas';
                } else {
                    canvas.className = currentArenaTheme;
                }
            }

            function renderChests() {
                const slots = document.querySelectorAll('#chestSlots .chest-slot');
                slots.forEach((slot, index) => {
                    slot.innerHTML = '';
                    slot.onclick = null;
                    if (trophyChests[index]) {
                        slot.innerHTML = `üì¶`;
                        slot.classList.remove('text-gray-500', 'bg-gray-700');
                        slot.classList.add('bg-yellow-700', 'cursor-pointer');
                        slot.onclick = () => openChest(index);
                    } else {
                        slot.innerHTML = ``;
                        slot.classList.add('text-gray-500', 'bg-gray-700');
                        slot.classList.remove('bg-yellow-700', 'cursor-pointer');
                    }
                });
            
            function getChestRewardMultiplier() {
                const arenaLevel = getAILevel();
                const multipliers = {
                    1: 1.0,
                    2: 1.2,
                    3: 1.4,
                    4: 1.6,
                    5: 1.8,
                    6: 2.0,
                    7: 2.3,
                    8: 2.6,
                    9: 2.9,
                    10: 3.2
                };
                return multipliers[arenaLevel] || 1.0;
            }
            
            let currentChestIndex = -1;
            let isChristmasOpening = false;
            let currentChestStars = 1;
            let chestClicks = 0;
            const MAX_CHEST_CLICKS = 4;

            function updateChestUI(stars, statusMsg) {
                const chestTitle = document.getElementById('chestTitle');
                const chestStars = document.getElementById('chestStars');
                const chestStatusText = document.getElementById('chestStatusText');
                
                chestTitle.textContent = `${stars} Star Box`;
                chestStars.innerHTML = '‚≠ê'.repeat(stars);
                chestStatusText.innerHTML = statusMsg;
            }

            function openChest(index) {
                const chest = trophyChests[index];
                if (!chest) return;
                currentChestIndex = index;
                currentChestStars = 1;
                chestClicks = 0;
                isChristmasOpening = false;
                document.getElementById('chestEmoji').textContent = 'üì¶';
                
                chestOpenOverlay.style.display = 'flex';
                document.getElementById('chestRewardList').innerHTML = '';
                document.getElementById('chestCloseButton').style.display = 'none';
                document.getElementById('chestEmoji').style.display = 'block';
                document.getElementById('chestClickArea').style.pointerEvents = 'auto';
                document.getElementById('chestClickCounter').textContent = 'Tap to Upgrade (0/4)';
                
                updateChestUI(1, 'Found a Basic Box!');
            }
            
            const chestClickArea = document.getElementById('chestClickArea');
            if (chestClickArea) chestClickArea.addEventListener('click', () => {
                const chestEmoji = document.getElementById('chestEmoji');
                
                // Animate click (Shake)
                if (chestEmoji) chestEmoji.classList.remove('shake-anim');
                if (chestEmoji) void chestEmoji.offsetWidth; // Trigger reflow
                chestEmoji.classList.add('shake-anim');

                if (chestClicks < MAX_CHEST_CLICKS) {
                    chestClicks++;
                    document.getElementById('chestClickCounter').textContent = `Tap to Upgrade (${chestClicks}/4)`;
                    
                    // Upgrade Logic
                    let chances = {1: 0.5, 2: 0.3, 3: 0.15, 4: 0.05}; // Standard
                    if (isChristmasOpening) {
                        chances = {1: 0.70, 2: 0.60, 3: 0.30, 4: 0.15}; // 70%, 60%, 30%, 15%
                    }
                    const roll = Math.random();
                    const required = chances[currentChestStars] || 0;

                    if (currentChestStars < 5 && roll < required) {
                        currentChestStars++;
                        chestEmoji.classList.add('animate-pulse');
                        setTimeout(() => chestEmoji.classList.remove('animate-pulse'), 500);
                        updateChestUI(currentChestStars, 'Upgrade Successful! ‚ú®');
                    } else {
                        // Failed upgrade, but we keep going until 5th click
                        updateChestUI(currentChestStars, 'No Upgrade...');
                    }
                } else {
                    // 5th Click: Open
                    document.getElementById('chestClickArea').style.pointerEvents = 'none';
                    document.getElementById('chestClickCounter').textContent = '';
                    finalizeChest(currentChestIndex, currentChestStars);
                }
            });

            function finalizeChest(index, stars) {
                if (!isChristmasOpening) {
                    trophyChests.splice(index, 1);
                } else {
                    lastClaimDate = new Date().toDateString();
                }
                document.getElementById('chestEmoji').style.display = 'none';
                document.getElementById('chestStatusText').textContent = 'Rewards';
                
                const starMultipliers = {1: 1.0, 2: 1.5, 3: 2.5, 4: 4.0, 5: 10.0};
                const starMult = starMultipliers[stars];
                const arenaMult = getChestRewardMultiplier();
                const totalMult = starMult * arenaMult;

                const rewardGold = Math.floor((50 + Math.floor(Math.random() * 50)) * totalMult);
                gold += rewardGold;
                
                const unlockedCards = getUnlockedCards(true);
                const numCardStacks = Math.max(1, Math.floor((2 + Math.floor(Math.random() * 2)) * Math.sqrt(totalMult)));
                
                const rewards = [];
                rewards.push({ type: 'gold', count: rewardGold, name: 'Gold' });
                
                for(let i = 0; i < numCardStacks; i++) {
                    const cardId = unlockedCards[Math.floor(Math.random() * unlockedCards.length)];
                    const baseCount = 3 + Math.floor(Math.random() * 5);
                    const cardCount = Math.floor(baseCount * totalMult);
                    rewards.push({ type: 'card', id: cardId, count: cardCount });
                    
                    if (cardId === 'tower') {
                        towerCardCount += cardCount;
                    } else {
                        if (!cardCollection[cardId]) cardCollection[cardId] = { level: 1, count: 0, unlocked: false };
                        cardCollection[cardId].unlocked = true;
                        cardCollection[cardId].count += cardCount;
                    }
                }
                
                // Pop-up animation loop (Improved)
                const list = document.getElementById('chestRewardList');
                list.innerHTML = '';
                let i = 0;
                function showNextReward() {
                    if (i >= rewards.length) {
                        document.getElementById('chestCloseButton').style.display = 'block';
                        document.getElementById('chestCloseButton').classList.add('animate-bounce');
                        renderChests();
                        updateArena();
                        if (isChristmasOpening) {
                            updateChristmasUI();
                            isChristmasOpening = false;
                        }
                        saveUserData();
                        return;
                    }
                    const r = rewards[i];
                    const div = document.createElement('div');
                    // Use new animation class
                    div.className = 'reward-item bg-gray-700 p-2 rounded flex items-center justify-center space-x-2';
                    
                    if (r.type === 'gold') {
                        div.innerHTML = `<span class="text-3xl">üí∞</span> <div class="flex flex-col"><span class="text-yellow-400 font-bold text-xl">+${r.count}</span><span class="text-xs text-gray-400">Gold</span></div>`;
                    } else {
                        const card = allCards[r.id];
                        div.innerHTML = `<span class="text-3xl">${card.emoji}</span> <div class="flex flex-col"><span class="font-bold text-xl text-white">+${r.count}</span><span class="text-xs text-gray-400">${card.name}</span></div>`;
                    }
                    list.appendChild(div);
                    i++;
                    setTimeout(showNextReward, 300); // Faster cadence
                }
                showNextReward();
            }
            if (chestCloseButton) chestCloseButton.addEventListener('click', () => {
                if (chestOpenOverlay) chestOpenOverlay.style.display = 'none';
            });

            navButtons.forEach(btn => { 
                btn.addEventListener('click', () => { 
                    if (btn.dataset.screen === currentScreen) return;
                    if (btn.dataset.screen === 'debug') {
                        // isLocalFile check removed to enable debug for all environments
                        showDebugPassword();
                    } else {
                        showScreen(btn.dataset.screen); 
                    }
                }); 
            });
            // NEW: Show update log function
            function showUpdateLog() {
                const updates = [
                    { date: '11/28/2025', title: 'Tower Power & Arena Update', items: [
                        'üè∞ New Special Towers! (Unlock at Arena 10+)',
                        'üßá Waffle Maker: Heals and Levels up friendly troops!',
                        'üî´ Machine Gun: Rapid fire bursts for high DPS!',
                        'üöÄ Rocketeer: Slow but devastating rocket attacks!',
                        'üëÅÔ∏è Tower Preview: Test towers in the Tower Menu!',
                        'ü™¶ Added Arena 9: Titan\'s Peak (2000+ trophies)',
                        'üî• Added Arena 10: Chaos Realm (2250+ trophies)',
                        'üíÄ New Cards: Huge Skeleton, Ninja, Meteor, Skeleton Yard',
                        '‚ö° New Cards: Zap Giant, Mega Smasher, Flame Dragon, Bot'
                    ]},
                    { date: '11/27/2025', title: 'Winter Event', items: [
                        'üéÑ Winter Wonderland Event is Live!',
                        '‚òÉÔ∏è Snowman Challenge: Battle the Snowman King!',
                        '‚ú® Visual Updates: New glowing text effects in Events tab'
                    ]},
                    { date: '11/25/2025', title: 'Previous Update', items: [
                        'Added 2v2 Mode: Team up with an AI teammate against two AI opponents',
                        'New King Tower Visuals: Combined king tower in 2v2 mode shows two crowns',
                        'AI Improvements: 2v2 AI opponents and teammates now use all available cards',
                        'UI Updates: Added health text display on all towers',
                        'Fixed various bugs with card restrictions and deck initialization'
                    ]},
                    { date: '11/24/2025', title: 'Previous Update', items: [
                        'Added Arena 8: Chaos Canyon (1750+ trophies) with custom card classes',
                        'Added Chaos Elemental card - Melee unit with high damage and speed (üëπ)',
                        'Added Shadow Clone card - Ranged unit with moderate damage (üë§)',
                        'Added Void Trap spell - Area damage spell for area control (‚ö´)',
                        'Added Stone Giant card - Tank unit with high health (üóø)',
                        'Added Chaos Orb spell - Damage spell for offense (üåÄ)',
                        'Buffed all Spirits: health increased from 50 to 150 (now takes 3 tower hits to kill)',
                        'Updated AI difficulty scaling per arena: Arena 1 lvl 1, Arena 2 lvl 1-2, Arena 3 lvl 2-3, Arena 4 lvl 2-3, Arena 5 lvl 4-5, Arena 6 lvl 4-5, Arena 7 lvl 5-6, Arena 8 lvl 5-6',
                        'Chests now give more money and cards in higher arenas'
                    ]},
                    { date: '11/22/2025', title: 'Previous Update', items: [
                        'Added Arena 7: Mages Graveyard (1500+ trophies)',
                        'Added Mage card - Ranged unit with splash damage, attacks ground and air. Every 5 seconds, spawns 4 Skeletons in a square around her.',
                        'Added Phantom Knight card: Spawns invisible and cannot be seen by enemy troops. Only attacks ground units. When attacking, becomes fully visible and can be targeted by enemy troops. Returns to invisible after 3 seconds of not attacking. Spells still hit invisible Phantom Knights. Spirits cannot see invisible Phantom Knights. Visual effect shows semi-transparent ghost when invisible.',
                        'Added Spirit Lantern card - Spawns a random spirit (Zap, Cold, or Life Spirit) every 6 seconds.',
                        'Added Arena 6: Warlock\'s Workshop (1250+ trophies)',
                        'Added Warlock card - Ranged unit with splash damage, attacks ground and air',
                        'Added Zap Spirit - Jumps on enemies and chains electricity to up to 10 targets',
                        'Added Cold Spirit - Jumps and freezes enemies in area for 3 seconds',
                        'Added Life Spirit - Jumps and creates healing circle for friendly units (3 seconds)',
                        'Added Bomb Spirit - Jumps and explodes damaging enemies in area',
                        'Added Spear Goblins card - Spawns 3 spear goblins (unlocks Arena 2)',
                        'Added Anger spell - Purple pool that gives 2x damage and 1.5x attack speed (5 seconds, persists 3s after leaving)',
                        'Buffed Skeletons and Skeleton Group: damage increased from 2 to 5'
                    ]},
                    { date: 'Previous Updates', title: 'Previous Features', items: [
                        'Arena system with 5 arenas',
                        'Card collection and deck building',
                        'Tower upgrades',
                        'Chest system',
                        'Multiple unit types and spells',
                        'AI opponents',
                        'Save/load system'
                    ]}
                ];
                
                let html = '';
                updates.forEach(update => {
                    html += `<div class="mb-4"><h3 class="font-bold text-lg text-yellow-400 mb-2">${update.title} - ${update.date}</h3><ul class="list-disc list-inside space-y-1">`;
                    update.items.forEach(item => {
                        html += `<li>${item}</li>`;
                    });
                    html += `</ul></div>`;
                });
                updateLogContent.innerHTML = html;
                updateLogOverlay.style.display = 'flex';
            }
            
            updateLogClose.addEventListener('click', () => {
                updateLogOverlay.style.display = 'none';
            });
            
            if (battleButton) battleButton.addEventListener('click', () => {
                if (battleButton.disabled) return;
                
                if (gameMode === 'party1v1') {
                     if (playerDeckParty.length !== 8) {
                        alert('Add 8 cards to your 1v1 Party deck first!');
                        showScreen('deck');
                        return;
                     }
                     // Start 1v1 Party directly
                     menuScreen.classList.remove('active');
                     loadingScreen.classList.add('active');
                     loadingScreen.querySelector('p').textContent = 'Finding Party Opponent...';
                     setTimeout(() => {
                        showScreen('game');
                        messageText.textContent = 'Get Ready!';
                        startButton.style.display = 'none';
                        menuButton.style.display = 'none';
                        messageOverlay.style.display = 'flex';
                        setTimeout(() => {
                            initGame();
                            lastTime = performance.now();
                            gameLoopId = requestAnimationFrame(gameLoop);
                        }, 1500);
                     }, 1000);
                     return;
                }

                if (gameMode === '2v2') {
                    if (playerDeck2v2.length !== 8) {
                        alert('Add 8 cards to your 2v2 deck first!');
                        showScreen('deck');
                        return;
                    }
                    // Show teammate choice modal
                    show2v2TeammateChoice();
                } else {
                    // Normal flow
                    menuScreen.classList.remove('active');
                    loadingScreen.classList.add('active');
                    loadingScreen.querySelector('p').textContent = 'Finding Opponent...';
                    setTimeout(() => {
                        showScreen('game');
                        messageText.textContent = 'Get Ready!';
                        startButton.style.display = 'none';
                        menuButton.style.display = 'none';
                        messageOverlay.style.display = 'flex';
                        setTimeout(() => {
                            initGame();
                            lastTime = performance.now();
                            gameLoopId = requestAnimationFrame(gameLoop);
                        }, 1500);
                    }, 1000);
                }
            });
            // NEW: Arena screen buttons
            if (arenaButton) arenaButton.addEventListener('click', () => {
                showScreen('arena');
            });
            if (arenaBackButton) arenaBackButton.addEventListener('click', () => {
                showScreen('menu');
            });
            if (menuButton) menuButton.addEventListener('click', () => {
                gameRunning = false;
                cancelAnimationFrame(gameLoopId);
                // Reset mode if leaving challenge to prevent theme leak
                if (gameMode === 'snowman_challenge') {
                    gameMode = 'trophy';
                    updateModeUI();
                }
                showScreen('menu'); 
            });

            // ==============================================
            
                if (debugArena2) {
                    debugArena2.addEventListener('click', () => {
                        trophies = 250;
                        updateArena();
                        saveUserData();
                        showScreen('menu');
                    });
                }
                if (debugArena3) {
                    debugArena3.addEventListener('click', () => {
                        trophies = 500;
                        updateArena();
                        saveUserData();
                        showScreen('menu');
                    });
                }
                if (debugArena4) {
                    debugArena4.addEventListener('click', () => {
                        trophies = 750;
                        updateArena();
                        saveUserData();
                        showScreen('menu');
                    });
                }
                if (debugArena5) {
                    debugArena5.addEventListener('click', () => {
                        trophies = 1000;
                        updateArena();
                        saveUserData();
                        showScreen('menu');
                    });
                }
                if (debugArena6) {
                    debugArena6.addEventListener('click', () => {
                        trophies = 1250;
                        updateArena();
                        saveUserData();
                        showScreen('menu');
                    });
                }
                if (debugArena7) {
                    debugArena7.addEventListener('click', () => {
                        trophies = 1500;
                        updateArena();
                        saveUserData();
                        showScreen('menu');
                    });
                }
                if (debugArena8) {
                    debugArena8.addEventListener('click', () => {
                        trophies = 1750;
                        updateArena();
                        saveUserData();
                        showScreen('menu');
                    });
                }
                if (debugArena9) {
                    debugArena9.addEventListener('click', () => {
                        trophies = 2000;
                        updateArena();
                        saveUserData();
                        showScreen('menu');
                    });
                }
                if (debugArena10) {
                    debugArena10.addEventListener('click', () => {
                        trophies = 2250;
                        updateArena();
                        saveUserData();
                        showScreen('menu');
                    });
                }
                if (debugUnlockAll) {
                    debugUnlockAll.addEventListener('click', () => {
                        for (const cardId in allCards) {
                            if (cardId === 'tower' || cardId === 'miniStoneGiant') continue;
                            if (!cardCollection[cardId]) {
                                cardCollection[cardId] = { level: 1, count: 1, unlocked: true };
                            } else {
                                cardCollection[cardId].unlocked = true;
                                if (cardCollection[cardId].count === 0) {
                                    cardCollection[cardId].count = 1;
                                }
                            }
                        }
                        saveUserData();
                        console.log('All cards unlocked!');
                    });
                }
                if (debugUpgradeAll) {
                    debugUpgradeAll.addEventListener('click', () => {
                        for (const cardId in cardCollection) {
                            const cardData = cardCollection[cardId];
                            if (cardData.unlocked && cardData.level < 15) {
                                cardData.level++;
                            }
                        }
                        if (towerLevel < 15) towerLevel++;
                        saveUserData();
                        console.log('All owned cards and tower upgraded +1 level!');
                    });
                }
                if (debugGetChest) {
                    debugGetChest.addEventListener('click', () => {
                        if (trophyChests.length < 4) {
                            trophyChests.push({ id: 'wood', openTime: 0 });
                            renderChests();
                            saveUserData();
                            console.log('Got a chest!');
                        } else {
                            console.log('Chest slots are full!');
                        }
                    });
                }
                if (debugAddGold) {
                    debugAddGold.addEventListener('click', () => {
                        gold += 1000;
                        goldDisplay.textContent = `üí∞ ${gold}`;
                        saveUserData();
                        console.log('+1000 Gold!');
                    });
                }
                if (debugReset) {
                    debugReset.addEventListener('click', () => {
                        if (true) {
                            initNewUser();
                            saveUserData();
                            showScreen('menu');
                            console.log('Account reset!');
                        }
                    });
                }
            }


            // --- Christmas Event Logic ---
            const claimChristmasBtn = document.getElementById('claimChristmasBtn');
            const christmasGiftStatus = document.getElementById('christmasGiftStatus');
            
            function updateChristmasUI() {
                if (!claimChristmasBtn) return;
                const today = new Date().toDateString();
                if (lastClaimDate === today) {
                    claimChristmasBtn.disabled = true;
                    claimChristmasBtn.textContent = 'Come Back Tomorrow!';
                    claimChristmasBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    christmasGiftStatus.textContent = 'üéÅ Gift Claimed!';
                } else {
                    claimChristmasBtn.disabled = false;
                    claimChristmasBtn.textContent = 'Open Santa\'s Gift üéÅ';
                    claimChristmasBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    christmasGiftStatus.textContent = '‚ú® Gift Available! ‚ú®';
                }
            }

            const btnSnowmanChallenge = document.getElementById('btnSnowmanChallenge');
            if (btnSnowmanChallenge) {
                btnSnowmanChallenge.addEventListener('click', () => {
                     gameMode = 'snowman_challenge';
                     updateArena(); // Force theme update
                     // Start Game directly
                     showScreen('loading');
                     loadingScreen.querySelector('p').textContent = 'Entering the Frozen Arena...';
                     setTimeout(() => {
                        showScreen('game');
                        messageText.textContent = 'Snowman Challenge!';
                        startButton.style.display = 'none';
                        menuButton.style.display = 'none';
                        messageOverlay.style.display = 'flex';
                        setTimeout(() => {
                            initGame();
                            lastTime = performance.now();
                            gameLoopId = requestAnimationFrame(gameLoop);
                        }, 1500);
                     }, 1000);
                });
            }

            if (claimChristmasBtn) {
                claimChristmasBtn.addEventListener('click', () => {
                    const today = new Date().toDateString();
                    if (lastClaimDate !== today) {
                        // Start Christmas Opening
                        isChristmasOpening = true;
                        currentChestStars = 1;
                        chestClicks = 0;
                        currentChestIndex = -1;

                        chestOpenOverlay.style.display = 'flex';
                        document.getElementById('chestRewardList').innerHTML = '';
                        document.getElementById('chestCloseButton').style.display = 'none';
                        const emojiEl = document.getElementById('chestEmoji');
                        emojiEl.textContent = 'üéÅ';
                        emojiEl.style.display = 'block';
                        document.getElementById('chestClickArea').style.pointerEvents = 'auto';
                        document.getElementById('chestClickCounter').textContent = 'Tap to Upgrade (0/4)';
                        
                        updateChestUI(1, 'Santa\'s Gift! üéÖ');
                    }
                });
            }

            // ==============================================
            // CARD & DECK LOGIC
            // ==============================================

            function createCardDOM(cardId, isSmall = false, inHand = false) {
                const card = allCards[cardId];
                if (!card) return null;
                
                const cardData = cardCollection[cardId];
                // In 2v2 or Party mode, treat all cards as unlocked
                const isParty = (gameMode === '2v2' || gameMode === 'party1v1');
                const isLocked = isParty ? false : (!inHand && (!cardData || !cardData.unlocked));
                
                const cardEl = document.createElement('div');
                // Added btn-shine to cards
                cardEl.className = `card-ui btn-shine ${isSmall ? 'card-ui-small' : ''}`;
                cardEl.dataset.unit = cardId;
                
                if (isLocked) { 
                    cardEl.classList.add('card-ui-locked');
                    let lockedText = ``;
                    // Only show "Unlocks in Arena X" if it's NOT Arena 1
                    if (card.arena !== 1) {
                        lockedText = `<div class="card-ui-locked-arena">Unlocks in Arena ${card.arena}</div>`;
                    }
                    cardEl.innerHTML = `
                        <div class="card-ui-cost">${card.cost}</div>
                        <span class="card-ui-name">${card.name}</span>
                        <span class="card-ui-emoji">${card.emoji}</span>
                        <span class="card-ui-type">${card.type}</span>
                        ${lockedText}
                    `;
                    return cardEl;
                }

                const displayLevel = isParty ? 15 : ((cardData && cardData.level) ? cardData.level : 1);
                const displayCount = (cardData && cardData.count) ? cardData.count : 0;
                
                cardEl.dataset.cost = card.cost;
                cardEl.dataset.type = card.type;
                cardEl.dataset.emoji = card.emoji;
                cardEl.dataset.radius = card.placementRadius;
                if (card.radius) cardEl.dataset.spellRadius = card.radius;
                let progressBarHTML = '';
                let levelTextHTML = `<div class="card-ui-level">Lvl ${displayLevel}</div>`;
                if (!inHand) {
                    const costs = upgradeCosts[displayLevel];
                    let progress = 0;
                    let canUpgrade = false;
                    if (costs) {
                        progress = (displayCount / costs.cards) * 100;
                        if (displayCount >= costs.cards && gold >= costs.gold) { canUpgrade = true; }
                    } else { progress = 100; } // Max level
                    progressBarHTML = `<div class="card-ui-progress-bar"><div class="card-ui-progress ${canUpgrade ? 'can-upgrade' : ''}" style="width: ${Math.min(100, progress)}%;"></div></div>`;
                } else { levelTextHTML = ''; }
                cardEl.innerHTML = `<div class="card-ui-cost">${card.cost}</div><span class="card-ui-name">${card.name}</span><span class="card-ui-emoji">${card.emoji}</span><span class="card-ui-type">${card.type}</span>${levelTextHTML}${progressBarHTML}`;
                return cardEl;
            }

            function getUnlockedCards(includeTower = false, aiLevel = 0) {
                const unlocked = [];
                // Use AI level if provided, otherwise use player's trophies
                const arenaNum = aiLevel > 0 ? aiLevel : (currentArenaFloor === 0 ? 1 : (currentArenaFloor === 250 ? 2 : (currentArenaFloor === 500 ? 3 : (currentArenaFloor === 750 ? 4 : 5)))); // UPDATED
                
                for (const cardId in allCards) {
                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Never include tower or internal mini in this list
                    if (allCards[cardId].arena <= arenaNum) {
                        unlocked.push(cardId);
                    }
                }
                if (includeTower) {
                    unlocked.push('tower');
                }
                return unlocked;
            }

            function renderDeckScreen() {
                deckCardGrid.innerHTML = '';
                collectionCardGrid.innerHTML = '';
                lockedCardGrid.innerHTML = ''; 
                
                let currentDeck;
                if (gameMode === '2v2') currentDeck = playerDeck2v2;
                else if (gameMode === 'party1v1') currentDeck = playerDeckParty;
                else currentDeck = playerDeck;

                const deckCountEl = document.getElementById('deckCount');
                if (deckCountEl) deckCountEl.textContent = `${currentDeck.length} / 8`;

                // Calculate Average Elixir
                let totalCost = 0;
                currentDeck.forEach(id => { if (allCards[id]) totalCost += allCards[id].cost; });
                const avg = currentDeck.length > 0 ? (totalCost / currentDeck.length).toFixed(1) : "0.0";
                const avgElixirEl = document.getElementById('avgElixir');
                if (avgElixirEl) avgElixirEl.textContent = avg;

                // Render Deck (BIG CARDS, isSmall=false)
                currentDeck.forEach(cardId => { 
                    const cardEl = createCardDOM(cardId, false); 
                    cardEl.addEventListener('click', () => openCardModal(cardId)); 
                    deckCardGrid.appendChild(cardEl); 
                });
                
                // Render Collection & Locked Cards (SMALL CARDS, isSmall=true)
                for (const cardId in allCards) {
                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; 
                    
                    const cardData = cardCollection[cardId];
                    const isParty = (gameMode === '2v2' || gameMode === 'party1v1');
                    const isLocked = isParty ? false : (!cardData || !cardData.unlocked);
                    
                    const cardEl = createCardDOM(cardId, true);
                    cardEl.addEventListener('click', () => openCardModal(cardId));
                    
                    if (isParty) {
                        // In party modes, all cards go to collection and visually look unlocked
                        collectionCardGrid.appendChild(cardEl);
                    } else {
                        // Normal mode: respect locks
                        if (isLocked) {
                            lockedCardGrid.appendChild(cardEl);
                        } else {
                            collectionCardGrid.appendChild(cardEl);
                        }
                    }
                }
                
                updateBattleButtonState();
            }
            
            function renderTowerScreen() {
                // --- NEW: Render Collection Grid ---
                const screenDiv = document.querySelector('#towerScreen > div');
                screenDiv.innerHTML = `
                    <h1 class="text-3xl font-bold mb-4">Tower Collection</h1>
                    <p class="text-sm text-gray-400 mb-6">Reach Arena 10 to unlock special towers!</p>
                    <div id="towerGrid" class="grid grid-cols-2 gap-4 w-full"></div>
                `;
                const grid = document.getElementById('towerGrid');
                
                Object.keys(towerDefs).forEach(type => {
                    const def = towerDefs[type];
                    const data = towerCollection[type] || { level: 1, count: 0, unlocked: false };
                    // Unlock others at Arena 10 (2250 trophies)
                    if (type !== 'princess' && trophies >= 2250 && !data.unlocked) {
                        data.unlocked = true;
                        towerCollection[type] = data;
                    }
                    
                    const el = document.createElement('div');
                    el.className = `relative bg-gray-800 border-4 rounded-xl p-4 flex flex-col items-center cursor-pointer transition transform hover:scale-105 ${selectedTower === type ? 'border-yellow-400 shadow-[0_0_15px_rgba(250,204,21,0.5)]' : 'border-gray-600'}`;
                    if (!data.unlocked) el.classList.add('grayscale');

                    // Progress Bar Calculation
                    const costs = towerUpgradeCosts[data.level];
                    let progressHTML = '';
                    if (costs && data.unlocked) {
                        const pct = Math.min(100, (data.count / costs.cards) * 100);
                        const canUp = data.count >= costs.cards && gold >= costs.gold;
                        progressHTML = `<div class="w-full h-2 bg-gray-900 rounded-full mt-2 overflow-hidden border border-gray-700"><div class="h-full ${canUp ? 'bg-yellow-400' : 'bg-blue-500'}" style="width: ${pct}%"></div></div>`;
                    }
                    
                    el.innerHTML = `
                        <div class="text-5xl mb-2">${def.emoji}</div>
                        <h3 class="font-bold text-white">${def.name}</h3>
                        <p class="text-xs text-gray-400 text-center mt-1">${def.desc}</p>
                        ${data.unlocked ? `<div class="mt-2 text-yellow-300 font-bold">Lvl ${data.level}</div>` : '<div class="mt-2 text-red-400 font-bold text-xs">Arena 10+</div>'}
                        ${progressHTML}
                        ${selectedTower === type ? '<div class="absolute top-2 right-2 text-yellow-400">‚úÖ</div>' : ''}
                    `;
                    el.onclick = () => openTowerModal(type);
                    grid.appendChild(el);
                });
            }
            
            function openTowerModal(type) {
                const def = towerDefs[type];
                const data = towerCollection[type] || { level: 1, count: 0, unlocked: false };
                currentPreviewCardId = type; // Set for preview loop
                
                // Re-use card modal logic mostly
                cardInfoDisplay.innerHTML = `<div class="text-8xl">${def.emoji}</div>`;
                cardInfoName.textContent = def.name;
                cardInfoType.textContent = 'Tower';
                cardInfoLevel.textContent = `Level ${data.level}`;
                
                // Good/Weak Against
                const previewStrongHeader = document.getElementById('previewStrongHeader');
                const previewWeakHeader = document.getElementById('previewWeakHeader');
                const previewStrong = document.getElementById('previewStrong');
                const previewWeak = document.getElementById('previewWeak');

                let sText = "Good Against: Balanced Units";
                let wText = "Weak Against: Tanks, Swarms";
                let sDesc = "Versatile defense against most threats.";
                let wDesc = "Can be overwhelmed by large numbers.";

                if (type === 'waffle') {
                    sText = "Good Against: Friendly Troops (Support)";
                    wText = "Weak Against: Rushes";
                    sDesc = "King throws waffles to heal/level up allies. Princess towers are weaker.";
                    wDesc = "Lower stats make defense harder without troop support.";
                } else if (type === 'machineGun') {
                    sText = "Good Against: Swarms, Glass Cannons";
                    wText = "Weak Against: Tanks (Recharge)";
                    sDesc = "Bursts fire rapidly, shredding low HP units.";
                    wDesc = "Vulnerable during the long recharge period after bursting.";
                } else if (type === 'rocketeer') {
                    sText = "Good Against: Tanks, Clusters";
                    wText = "Weak Against: Fast Swarms";
                    sDesc = "Deals massive damage per hit.";
                    wDesc = "Very slow fire rate makes it bad against many small units.";
                }

                if (previewStrongHeader) previewStrongHeader.textContent = sText;
                if (previewWeakHeader) previewWeakHeader.textContent = wText;
                
                if (previewStrong) { previewStrong.style.display = 'flex'; previewStrong.innerHTML = `<div class="text-xs text-gray-400">${sDesc}</div>`; }
                if (previewWeak) { previewWeak.style.display = 'flex'; previewWeak.innerHTML = `<div class="text-xs text-gray-400">${wDesc}</div>`; }

                // Stats
                const base = towerStats[data.level];
                const hp = Math.round(base.princessHealth * def.healthMod);
                const dmg = Math.round(base.damage * def.dmgMod);
                const spd = (base.hitSpeed * def.speedMod).toFixed(1);
                
                let extraStats = '';
                if (type === 'waffle') extraStats = '<div>Ability: <span>Waffle Throw</span></div><div>Rate: <span>25s</span></div>';
                if (type === 'machineGun') extraStats = '<div>Ability: <span>Rapid Burst</span></div><div>Burst: <span>3s</span></div>';
                if (type === 'rocketeer') extraStats = '<div>Type: <span>High Damage</span></div><div>Speed: <span>Slow</span></div>';

                cardInfoStats.innerHTML = `
                    <div>Health: <span>${hp}</span></div>
                    <div>Damage: <span>${dmg}</span></div>
                    <div>Hit Speed: <span>${spd}s</span></div>
                    ${extraStats}
                    <div class="text-xs text-gray-400 mt-2">${def.desc}</div>
                `;
                
                cardInfoButtons.innerHTML = '';
                
                // Equip Button
                const equipBtn = document.createElement('button');
                const isLocked = !data.unlocked;
                equipBtn.className = `modal-btn ${selectedTower === type ? 'bg-gray-500' : (isLocked ? 'bg-gray-600 cursor-not-allowed' : 'bg-blue-600')}`;
                equipBtn.textContent = selectedTower === type ? 'Equipped' : (isLocked ? 'Locked' : 'Equip');
                
                equipBtn.disabled = (selectedTower === type) || isLocked;
                equipBtn.onclick = () => {
                    selectedTower = type;
                    renderTowerScreen();
                    closeModal();
                    saveUserData();
                };
                cardInfoButtons.appendChild(equipBtn);
                
                // Upgrade Logic
                const costs = towerUpgradeCosts[data.level];
                if (costs) {
                    cardInfoProgressContainer.style.display = 'block';
                    const progress = (data.count / costs.cards);
                    cardInfoProgressBar.style.width = `${Math.min(100, progress * 100)}%`;
                    cardInfoProgressText.textContent = `${data.count} / ${costs.cards}`;
                    
                    cardInfoButton.style.display = 'block';
                    const canUpgrade = data.count >= costs.cards && gold >= costs.gold;
                    cardInfoButton.className = 'modal-btn upgrade';
                    cardInfoButton.textContent = `Upgrade (üí∞ ${costs.gold})`;
                    cardInfoButton.disabled = !canUpgrade;
                    cardInfoButton.onclick = () => {
                        data.count -= costs.cards;
                        gold -= costs.gold;
                        data.level++;
                        goldDisplay.textContent = `üí∞ ${gold}`;
                        openTowerModal(type); // Refresh
                        renderTowerScreen();
                        saveUserData();
                    };
                } else {
                    cardInfoProgressContainer.style.display = 'none';
                    cardInfoButton.style.display = 'none';
                }
                
                // Enable preview tab for towers
                document.getElementById('cardTabPreview').style.display = 'flex';
                document.getElementById('cardTabStats').click();

                // Populate Test Cards List for Tower Preview
                const allCardsList = document.getElementById('previewAllCardsList');
                const searchInput = document.getElementById('previewSearchInput');
                allCardsList.innerHTML = '';
                searchInput.value = '';
                previewCameraY = 0;

                const sortedCards = Object.keys(allCards)
                    .filter(id => id !== 'tower' && id !== 'miniStoneGiant')
                    .sort((a, b) => allCards[a].name.localeCompare(allCards[b].name));

                sortedCards.forEach(cid => {
                    const el = createCardDOM(cid, true);
                    el.onclick = (e) => {
                        e.stopPropagation();
                        currentPreviewOpponentId = cid;
                        document.querySelectorAll('#previewAllCardsList .card-ui').forEach(c => c.style.borderColor = '');
                        el.style.borderColor = '#3b82f6';
                        startPreviewLoop();
                    };
                    el.dataset.searchName = allCards[cid].name.toLowerCase();
                    allCardsList.appendChild(el);
                });
                
                cardInfoModal.style.display = 'flex';
            }


            function updateBattleButtonState() {
                let currentDeck;
                if (gameMode === '2v2') currentDeck = playerDeck2v2;
                else if (gameMode === 'party1v1') currentDeck = playerDeckParty;
                else currentDeck = playerDeck;

                if (currentDeck.length === 8) {
                    battleButton.disabled = false;
                    battleButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    battleButton.textContent = 'BATTLE!';
                } else {
                    battleButton.disabled = true;
                    battleButton.classList.add('opacity-50', 'cursor-not-allowed');
                    battleButton.textContent = `Deck must have 8 cards (${currentDeck.length}/8)`;
                }
            }

            // --- PREVIEW SYSTEM VARIABLES ---
            let previewAnimationId = null;
            let previewSimulationObjects = [];
            let currentPreviewCardId = null;
            let currentPreviewOpponentId = null;
            let previewSpellTimer = 0;
            let previewCameraY = 0;
            const previewCanvas = document.getElementById('cardPreviewCanvas');
            const previewCtx = previewCanvas.getContext('2d');

            // --- Helper: Get Counters ---
            function getCardRoles(cardId) {
                const map = {
                    'knight': { strong: 'Support/Glass Cannons', weak: 'Air & Swarms' },
                    'archer': { strong: 'Air & Ground', weak: 'Splash & Burst' },
                    'giant': { strong: 'Buildings', weak: 'Swarms & Tank Killers' },
                    'goblins': { strong: 'Distraction/DPS', weak: 'Splash' },
                    'skeletons': { strong: 'Distraction', weak: 'Splash' },
                    'tinyBot': { strong: 'Killing Tanks', weak: 'Swarms' },
                    'fireball': { strong: 'Swarms & Clumps', weak: 'Tanks' },
                    'arrows': { strong: 'Low HP Swarms', weak: 'Tanks' },
                    'hut': { strong: 'Passive Pressure', weak: 'Spells' },
                    'skeletonArmy': { strong: 'Killing Tanks', weak: 'Splash' },
                    'goblinGang': { strong: 'Tanks & Air', weak: 'Splash' },
                    'spearGoblins': { strong: 'Air/Chip Damage', weak: 'Splash' },
                    'fireDragon': { strong: 'Swarms', weak: 'Single Ranged' },
                    'barbarians': { strong: 'Killing Tanks', weak: 'Splash' },
                    'battleRam': { strong: 'Buildings', weak: 'Swarms' },
                    'barbarianHut': { strong: 'Pressure', weak: 'Spells' },
                    'axeSwinger': { strong: 'Ground Swarms', weak: 'Air Units' },
                    'pigs': { strong: 'Buildings', weak: 'Splash' },
                    'farmer': { strong: 'Ground Area', weak: 'Air Units' },
                    'poison': { strong: 'Area Denial', weak: 'Fast Units' },
                    'flyingSkeletons': { strong: 'Ground Units', weak: 'Splash' },
                    'megaFlyingSkeleton': { strong: 'Killing Tanks', weak: 'Swarms' },
                    'flyingSkeletonGroup': { strong: 'Killing Tanks', weak: 'Splash' },
                    'warlock': { strong: 'Swarms', weak: 'High DPS' },
                    'mage': { strong: 'Swarms', weak: 'High DPS' },
                    'phantomKnight': { strong: 'Single Target', weak: 'Swarms' },
                    'spiritLantern': { strong: 'Support', weak: 'Spells' },
                    'zapSpirit': { strong: 'Swarms/Stun', weak: 'Ranged' },
                    'coldSpirit': { strong: 'Freeze/Stun', weak: 'Ranged' },
                    'lifeSpirit': { strong: 'Healing', weak: 'Ranged' },
                    'bombSpirit': { strong: 'Swarms', weak: 'Ranged' },
                    'anger': { strong: 'Boosting Units', weak: 'N/A' },
                    'chaosElemental': { strong: 'Killing Tanks', weak: 'Swarms' },
                    'shadowClone': { strong: 'Support', weak: 'Splash' },
                    'voidTrap': { strong: 'Area Control', weak: 'Spread Units' },
                    'stoneGiant': { strong: 'Buildings', weak: 'Swarms' },
                    'miniStoneGiant': { strong: 'Distraction', weak: 'Splash' },
                    'chaosOrb': { strong: 'Area Damage', weak: 'Tanks' },
                    'skeletonYard': { strong: 'Surprise Attack', weak: 'Poison/Splash' },
                    'titan': { strong: 'Anything Ground', weak: 'Inferno/Swarms' }
                };
                return map[cardId] || { strong: 'Specific Units', weak: 'Specific Counters' };
            }

            function getCardCounters(card) {
                const strong = [];
                const weak = [];
                const allIds = Object.keys(allCards).filter(id => id !== 'tower' && id !== 'miniStoneGiant');
                
                // Helper to get stats (approximate level 1 for logic)
                const s1 = (c) => c.stats && c.stats[1] ? c.stats[1] : { damage: 0, health: 0, hitSpeed: 1, count: 1 };
                
                // Card Properties
                const myStats = s1(card);
                const isMySwarm = card.type === 'Swarm' || (myStats.count && myStats.count > 1) || ['mage', 'hut', 'barbarianHut', 'spiritLantern', 'goblinGang', 'skeletonArmy'].includes(card.id);
                const isMySplash = (myStats.splashRadius && myStats.splashRadius > 0) || card.type === 'Spell' || ['axeSwinger', 'warlock', 'mage', 'fireDragon', 'chaosOrb', 'voidTrap', 'bombSpirit', 'coldSpirit', 'zapSpirit'].includes(card.id);
                const isMyFlying = card.isFlying;
                const isMyBuilding = card.type === 'Building';
                const isMyTank = myStats.health > 800;
                const isMyHighDps = (myStats.damage / myStats.hitSpeed) > 100;
                const myTargetsAir = card.targets === 'Air & Ground';
                const myTargetsBuildings = card.targets === 'Buildings' || card.targets === 'Towers';

                allIds.forEach(id => {
                    if (id === card.id) return;
                    const other = allCards[id];
                    const otherStats = s1(other);
                    const isOtherSwarm = other.type === 'Swarm' || (otherStats.count && otherStats.count > 1) || ['mage', 'hut', 'barbarianHut', 'spiritLantern', 'goblinGang', 'skeletonArmy'].includes(id);
                    const isOtherSplash = (otherStats.splashRadius && otherStats.splashRadius > 0) || other.type === 'Spell' || ['axeSwinger', 'warlock', 'mage', 'fireDragon', 'chaosOrb', 'voidTrap', 'bombSpirit', 'coldSpirit', 'zapSpirit'].includes(id);
                    const isOtherFlying = other.isFlying;
                    const isOtherBuilding = other.type === 'Building';
                    const isOtherTank = otherStats.health > 800;
                    const isOtherHighDps = (otherStats.damage / otherStats.hitSpeed) > 100;
                    const otherTargetsAir = other.targets === 'Air & Ground';
                    
                    // --- WEAK AGAINST (This card loses to Other) ---
                    let isWeak = false;
                    let isStrong = false;

                    // 1. Single Target Ground vs Swarm/Spawner
                    if (!isMySplash && !isMyFlying && !isMySwarm && isOtherSwarm) isWeak = true;
                    
                    // 2. Swarm vs Splash
                    if (isMySwarm && isOtherSplash) isWeak = true;

                    // 3. Ground vs Flying (if can't hit air)
                    if (!isMyFlying && !myTargetsAir && isOtherFlying && other.type !== 'Building') isWeak = true;
                    
                    // 4. Low Health vs Spells/Splash
                    if (myStats.health < 300 && isOtherSplash) isWeak = true;
                    
                    // 5. Tank vs High DPS (Tank melters)
                    if (isMyTank && isOtherHighDps && !isOtherSwarm) isWeak = true;
                    
                    // 6. Flying vs Air Counters (High DPS Ranged)
                    if (isMyFlying && otherTargetsAir && isOtherHighDps) isWeak = true;
                    
                    // 7. General Stat Check (if no specific interaction found)
                    if (!isWeak && !isStrong) {
                        if (other.cost >= card.cost && isOtherHighDps && !isMySwarm) isWeak = true;
                    }

                    if (isWeak) weak.push(id);

                    // --- STRONG AGAINST (This card beats Other) ---
                    isStrong = false;

                    // 1. Splash vs Swarm
                    if (isMySplash && isOtherSwarm) isStrong = true;

                    // 2. Swarm vs Single Target (Non-Splash)
                    if (isMySwarm && !isOtherSplash && !isOtherFlying) isStrong = true;

                    // 3. High DPS vs Tank
                    if (isMyHighDps && isOtherTank && !isMySwarm) isStrong = true;

                    // 4. Air Attacker vs Flying
                    if (myTargetsAir && isOtherFlying) isStrong = true;

                    // 5. Tank vs Buildings
                    if (isMyTank && isOtherBuilding) isStrong = true; 
                    
                    // 6. Building Targeter vs Building
                    if (myTargetsBuildings && isOtherBuilding) isStrong = true;

                    // 7. Spell logic
                    if (card.type === 'Spell') {
                         if (isOtherSwarm) isStrong = true;
                         if (myStats.damage >= otherStats.health && otherStats.health > 0) isStrong = true;
                    }
                    
                    // 8. General Stat Check
                    if (!isStrong && !isWeak) {
                         if (card.cost > other.cost && !isOtherSwarm) isStrong = true;
                    }

                    if (isStrong) strong.push(id);
                });
                
                // --- FALLBACKS TO ENSURE NON-EMPTY ---
                let finalStrong = [...new Set(strong)].filter(x => !weak.includes(x));
                let finalWeak = [...new Set(weak)];
                
                if (finalStrong.length === 0) {
                    // Fallback: Add generic targets
                    const fallbackCandidates = ['skeletons', 'knight', 'goblins', 'archer'];
                    for (const cand of fallbackCandidates) {
                        if (cand !== card.id && !finalWeak.includes(cand) && allIds.includes(cand)) {
                            finalStrong.push(cand);
                            if (finalStrong.length >= 2) break;
                        }
                    }
                }
                
                if (finalWeak.length === 0 && card.type !== 'Spell') {
                    // Fallback: Add generic counters
                    const fallbackCandidates = ['stoneGiant', 'skeletonArmy', 'warlock', 'fireDragon'];
                    for (const cand of fallbackCandidates) {
                        if (cand !== card.id && allIds.includes(cand)) {
                            finalWeak.push(cand);
                            if (finalWeak.length >= 2) break;
                        }
                    }
                }
                
                return { 
                    strong: finalStrong.sort(() => 0.5 - Math.random()).slice(0, 5), 
                    weak: finalWeak.sort(() => 0.5 - Math.random()).slice(0, 5) 
                };
            }

            function openCardModal(cardId) {
                const card = allCards[cardId];
                // Assign ID to card object for reference if missing
                card.id = cardId;
                currentPreviewCardId = cardId;
                
                const cardData = cardCollection[cardId];
                if (!card) return;
                
                const isParty = (gameMode === '2v2' || gameMode === 'party1v1');
                const isLocked = isParty ? false : (!cardData || !cardData.unlocked);
                const displayLevel = isParty ? 15 : ((cardData && cardData.level) ? cardData.level : 1);
                const stats = card.stats ? card.stats[displayLevel] : null;

                // --- Header ---
                cardInfoDisplay.innerHTML = '';
                cardInfoDisplay.appendChild(createCardDOM(cardId, false));
                cardInfoName.textContent = card.name;
                cardInfoType.textContent = card.type || 'Special';
                cardInfoLevel.textContent = isLocked ? "Not Unlocked" : `Level ${displayLevel}`;

                // --- Reset Tabs ---
                switchTab('stats');

                // --- Populate Stats Tab ---
                cardInfoStats.innerHTML = `<div>Targets: <span>${card.targets || '-'}</span></div>`;
                if (card.isFlying) cardInfoStats.innerHTML += `<div>Placement: <span>Air</span></div>`;
                else if (card.type !== 'Spell' && card.type !== 'Building') cardInfoStats.innerHTML += `<div>Placement: <span>Ground</span></div>`;

                if (stats) {
                    for (const [key, value] of Object.entries(stats)) { 
                        if (key !== 'barbLevel') cardInfoStats.innerHTML += `<div>${key.charAt(0).toUpperCase() + key.slice(1).replace('_', ' ')}: <span>${value}</span></div>`; 
                    }
                    if (card.type === 'Spell') { cardInfoStats.innerHTML += `<div>Radius: <span>${card.radius}</span></div>`; }
                    if (stats.damage && stats.hitSpeed) { const dps = (stats.damage / stats.hitSpeed).toFixed(1); cardInfoStats.innerHTML += `<div>DPS: <span>${dps}</span></div>`; }
                }
                // Extra stats logic (Mage, StoneGiant) ...
                if (cardId === 'mage') {
                    const skelStats = allCards['skeletons'] && allCards['skeletons'].stats ? allCards['skeletons'].stats[1] : null;
                    if (skelStats) {
                        cardInfoStats.innerHTML += `<div class='mt-2 font-bold text-yellow-300'>Spawns 4 Skeletons every 5s:</div>`;
                        cardInfoStats.innerHTML += `<div>Skeleton HP: <span>${skelStats.health}</span></div>`;
                    }
                }
                if (cardId === 'stoneGiant') {
                    const miniStats = allCards['stoneGiant'] && allCards['stoneGiant'].miniStats ? allCards['stoneGiant'].miniStats[1] : null;
                    if (miniStats) {
                        cardInfoStats.innerHTML += `<div class='mt-2 font-bold text-yellow-300'>Splits into 2 Mini Stone Giants:</div>`;
                        cardInfoStats.innerHTML += `<div>Mini HP: <span>${miniStats.health}</span></div>`;
                    }
                }

                // Buttons & Progress
                cardInfoButtons.innerHTML = '';
                cardInfoProgressContainer.style.display = 'none';
                cardInfoButton.style.display = 'none';

                if (isLocked || !stats) {
                    if(isLocked) cardInfoLevel.textContent = `Unlocks in Arena ${card.arena}`;
                } else {
                    let currentDeck;
                    if (gameMode === '2v2') currentDeck = playerDeck2v2;
                    else if (gameMode === 'party1v1') currentDeck = playerDeckParty;
                    else currentDeck = playerDeck;

                    const isInDeck = currentDeck.includes(cardId);
                    let addRemoveBtn = document.createElement('button');
                    addRemoveBtn.id = 'addRemoveBtn';
                    if (isInDeck) {
                        addRemoveBtn.textContent = 'Remove from Deck';
                        addRemoveBtn.className = 'modal-btn remove';
                        addRemoveBtn.onclick = () => removeFromDeck(cardId);
                    } else {
                        addRemoveBtn.textContent = 'Add to Deck';
                        addRemoveBtn.className = 'modal-btn add';
                        addRemoveBtn.onclick = () => addToDeck(cardId);
                        addRemoveBtn.disabled = currentDeck.length >= 8;
                        if (currentDeck.length >= 8) addRemoveBtn.textContent = 'Deck is Full (8/8)';
                    }
                    cardInfoButtons.appendChild(addRemoveBtn);
                    cardInfoProgressContainer.style.display = 'block';
                    cardInfoButton.style.display = 'block';
                    
                    const displayCount = cardData.count || 0;
                    const costs = upgradeCosts[displayLevel];
                    
                    if (costs) {
                        const progress = (displayCount / costs.cards);
                        cardInfoProgressBar.style.width = `${Math.min(100, progress * 100)}%`;
                        cardInfoProgressText.textContent = `${displayCount} / ${costs.cards}`;
                        const canUpgrade = displayCount >= costs.cards && gold >= costs.gold;
                        cardInfoProgressBar.classList.toggle('can-upgrade', canUpgrade);
                        cardInfoButton.className = 'modal-btn upgrade';
                        cardInfoButton.textContent = `Upgrade (üí∞ ${costs.gold})`;
                        cardInfoButton.disabled = !canUpgrade;
                        cardInfoButton.onclick = () => upgradeCard(cardId);
                    } else {
                        cardInfoProgressContainer.style.display = 'none';
                        cardInfoButton.className = 'modal-btn';
                        cardInfoButton.textContent = 'Max Level (15)';
                        cardInfoButton.disabled = true;
                    }
                }
                
                // --- Populate Preview Tab ---
                const roles = getCardRoles(cardId);
                
                const previewStrongHeader = document.getElementById('previewStrongHeader');
                const previewWeakHeader = document.getElementById('previewWeakHeader');
                if (previewStrongHeader) previewStrongHeader.textContent = `Good Against: ${roles.strong}`;
                if (previewWeakHeader) previewWeakHeader.textContent = `Weak Against: ${roles.weak}`;

                const previewStrong = document.getElementById('previewStrong');
                const previewWeak = document.getElementById('previewWeak');
                const previewWeakContainer = document.getElementById('previewWeakContainer');

                // Hide detailed lists as requested, but keep headers
                if (previewStrong) { previewStrong.innerHTML = ''; previewStrong.style.display = 'none'; }
                if (previewWeak) { previewWeak.innerHTML = ''; previewWeak.style.display = 'none'; }

                if (card.type === 'Spell') {
                    if (previewWeakContainer) previewWeakContainer.style.display = 'none';
                } else {
                    if (previewWeakContainer) previewWeakContainer.style.display = 'block';
                }

                // --- NEW: Populate All Cards List ---
                const allCardsList = document.getElementById('previewAllCardsList');
                const searchInput = document.getElementById('previewSearchInput');
                allCardsList.innerHTML = '';
                searchInput.value = '';

                // Helper to clear all highlights
                const clearAllHighlights = () => {
                     document.querySelectorAll('#previewStrong .card-ui, #previewWeak .card-ui, #previewAllCardsList .card-ui').forEach(c => c.style.borderColor = '');
                };

                // Patch existing items in Strong/Weak to clear All List highlights
                [previewStrong, previewWeak].forEach(container => {
                    Array.from(container.children).forEach(child => {
                        if (child.classList.contains('card-ui')) {
                            const originalClick = child.onclick;
                            child.onclick = (e) => {
                                clearAllHighlights(); // Clear everything first
                                if (originalClick) originalClick(e); // Then let original logic run
                            };
                        }
                    });
                });

                // Populate All Cards
                const sortedCards = Object.keys(allCards)
                    .filter(id => id !== 'tower' && id !== 'miniStoneGiant')
                    .sort((a, b) => allCards[a].name.localeCompare(allCards[b].name));

                sortedCards.forEach(cid => {
                    const el = createCardDOM(cid, true);
                    el.onclick = (e) => {
                        e.stopPropagation();
                        currentPreviewOpponentId = cid;
                        clearAllHighlights();
                        el.style.borderColor = '#3b82f6'; // blue-500
                        startPreviewLoop();
                    };
                    el.dataset.searchName = allCards[cid].name.toLowerCase();
                    allCardsList.appendChild(el);
                });

                // Search Listener (Once)
                if (!searchInput.dataset.hasListener) {
                    searchInput.dataset.hasListener = 'true';
                    searchInput.addEventListener('input', (e) => {
                        const term = e.target.value.toLowerCase();
                        Array.from(allCardsList.children).forEach(child => {
                            const name = child.dataset.searchName || '';
                            child.style.display = name.includes(term) ? 'flex' : 'none';
                        });
                    });
                }

                cardInfoModal.style.display = 'flex';
            }

            // --- Tab Switching Logic ---
            const tabStats = document.getElementById('cardTabStats');
            const tabPreview = document.getElementById('cardTabPreview');
            const panelStats = document.getElementById('cardInfoStatsPanel');
            const panelPreview = document.getElementById('cardInfoPreviewPanel');

            tabStats.addEventListener('click', () => switchTab('stats'));
            tabPreview.addEventListener('click', () => switchTab('preview'));

            function switchTab(tab) {
                if(tab === 'stats') {
                    panelStats.style.display = 'block';
                    panelPreview.style.display = 'none';
                    panelPreview.classList.remove('flex');
                    tabStats.classList.add('bg-gray-600', 'text-white', 'shadow-md');
                    tabStats.classList.remove('text-gray-400', 'hover:bg-gray-600', 'hover:text-white');
                    tabPreview.classList.remove('bg-gray-600', 'text-white', 'shadow-md');
                    tabPreview.classList.add('text-gray-400', 'hover:bg-gray-600', 'hover:text-white');
                    stopPreviewLoop();
                } else {
                    panelStats.style.display = 'none';
                    panelPreview.style.display = 'flex';
                    tabPreview.classList.add('bg-gray-600', 'text-white', 'shadow-md');
                    tabPreview.classList.remove('text-gray-400', 'hover:bg-gray-600', 'hover:text-white');
                    tabStats.classList.remove('bg-gray-600', 'text-white', 'shadow-md');
                    tabStats.classList.add('text-gray-400', 'hover:bg-gray-600', 'hover:text-white');
                    startPreviewLoop();
                }
            }

            function startPreviewLoop() {
                if (previewAnimationId) cancelAnimationFrame(previewAnimationId);
                previewSimulationObjects = [];
                previewSpellTimer = 0;
                let previewOpponentSpellTimer = 0;
                let previewFrame = 0;
                // Capture the global deltaTime before the preview loop overwrites it.
                const originalGlobalDeltaTime = deltaTime;
                let lastPreviewTime = performance.now();

                // Handle Tower Previews
                let card = allCards[currentPreviewCardId];
                let playerTowerType = 'princess';
                if (!card && towerDefs[currentPreviewCardId]) {
                    // It is a tower preview
                    card = { type: 'TowerPreview', name: towerDefs[currentPreviewCardId].name };
                    playerTowerType = currentPreviewCardId;
                }

                const opponent = currentPreviewOpponentId ? allCards[currentPreviewOpponentId] : null;
                
                // --- Setup Simulation Board ---
                // 1. Add Towers (Arena 1 Theme)
                // Blue Princess (Bottom) - Use selected tower type if previewing tower
                previewSimulationObjects.push(new Tower(130, 180, 'player', false, 10, false, playerTowerType));
                // Red Princess (Top)
                previewSimulationObjects.push(new Tower(130, 20, 'ai', false, 10));
                
                // Waffle Preview Extras
                if (currentPreviewCardId === 'waffle') {
                    // Add King Tower for Waffle Preview (off-screen normally, viewable via switch)
                    previewSimulationObjects.push(new Tower(130, 280, 'player', true, 10, false, 'waffle'));
                    // Add Friendly Unit to be buffed
                    previewSimulationObjects.push(new Knight(130, 240, 'player', 10));
                }

                const spawnX = 130;
                const blueSpawnY = 140;
                const redSpawnY = 60;

                // --- CONTEXT SWAP FOR SPAWN ---
                // We swap gameObjects to previewSimulationObjects so that Swarm classes (which push to gameObjects)
                // correctly populate the preview array instead of the main game array.
                const globalGameObjects = gameObjects;
                gameObjects = previewSimulationObjects;

                try {
                    // 2. Spawn Main Unit (Player Team) at Bottom
                    if (card.type !== 'Spell' && card.type !== 'TowerPreview') {
                        const level = 10;
                        if (card.unitClass) {
                             const unit = new card.unitClass(spawnX, blueSpawnY, 'player', level);
                             // If it returned a Single Unit (GameObject), we push it manually.
                             // If it was a Swarm, it already pushed itself to gameObjects (aliased to previewSimulationObjects).
                             if (unit instanceof GameObject) previewSimulationObjects.push(unit);
                        }
                    } else {
                        previewSpellTimer = 60;
                    }

                    // 3. Spawn Opponent (AI Team) at Top
                    if (opponent) {
                         if (opponent.type !== 'Spell') {
                             const level = 10;
                             if (opponent.unitClass) {
                                 const unit = new opponent.unitClass(spawnX, redSpawnY, 'ai', level);
                                 if (unit instanceof GameObject) previewSimulationObjects.push(unit);
                             }
                         } else {
                             previewOpponentSpellTimer = 90;
                         }
                    } else if (currentPreviewCardId === 'machineGun') {
                         // Force spawn a tank for MG preview so user sees the slow down
                         const tank = new Giant(spawnX, redSpawnY, 'ai', 10);
                         tank.health = 5000; 
                         tank.maxHealth = 5000;
                         previewSimulationObjects.push(tank);
                    }
                } catch(e) {
                    console.warn("Preview spawn error", e);
                } finally {
                    // Restore global context immediately
                    gameObjects = globalGameObjects;
                }

                function loop(timestamp) {
                    if (!timestamp) timestamp = performance.now();
                    deltaTime = (timestamp - lastPreviewTime) / 1000;
                    lastPreviewTime = timestamp;
                    if (deltaTime > 0.1) deltaTime = 0.016;

                    // --- Auto-Restart Logic ---
                    previewFrame++;
                    const towerDied = previewSimulationObjects.some(o => o instanceof Tower && o.health <= 0);
                    if (previewFrame > 600 || towerDied) { // Restart after 10s or if a tower dies
                         startPreviewLoop();
                         return;
                    }
                    // --- TEMPORARY CONTEXT SWAP ---
                    const mainCtx = ctx;
                    ctx = previewCtx;

                    ctx.clearRect(0, 0, 300, 200);
                    ctx.save();
                    ctx.translate(0, -previewCameraY);
                    
                    // --- Draw Arena 1 Background (Extended for Scrolling) ---
                    ctx.fillStyle = '#15803d'; // Green Grass
                    ctx.fillRect(0, 0, 300, 400); // Taller for scroll
                    
                    // River
                    ctx.fillStyle = '#3b82f6'; // Blue River
                    ctx.fillRect(0, 90, 300, 20);
                    
                    // Bridge
                    ctx.fillStyle = '#a16207'; // Brown
                    ctx.fillRect(115, 85, 30, 30);

                    // Swap Globals for Logic Update
                    const globalGameObjects = gameObjects;
                    gameObjects = previewSimulationObjects;

                    try {
                        // Main Spell Logic
                        if (card.type === 'Spell' && previewSpellTimer > 0) {
                             previewSpellTimer--;
                             if (previewSpellTimer === 0) {
                                 const level = 10; const s = card.stats[level];
                                 // Target opponent unit if exists, else top tower
                                 let tx = 130, ty = 60;
                                 const target = gameObjects.find(o => o.team === 'ai' && o instanceof Unit);
                                 if (target) { tx = target.x; ty = target.y; }
                                 else { tx = 130; ty = 20; } // Fallback to tower

                                 if (currentPreviewCardId === 'poison') gameObjects.push(new PoisonSpell(tx, ty, 'player', s.damagePerSecond, card.radius, s.duration));
                                 else if (currentPreviewCardId === 'anger') gameObjects.push(new AngerSpell(tx, ty, 'player', card.radius, s.duration, s.damage));
                                 else if (currentPreviewCardId === 'voidTrap') gameObjects.push(new VoidTrapEffect(tx, ty, 'player', card.radius, s.damage));
                                 else if (currentPreviewCardId === 'chaosOrb') gameObjects.push(new ChaosOrbEffect(tx, ty, 'player', card.radius, s.damage));
                                 else if (currentPreviewCardId === 'skeletonYard') gameObjects.push(new SkeletonYard(tx, ty, 'player', s.duration, card.radius, 10));
                                 else gameObjects.push(new Spell(tx, ty, 'player', s.damage, card.radius, card.emoji));
                             }
                        }
                        
                        // Opponent Spell Logic
                        if (opponent && opponent.type === 'Spell' && previewOpponentSpellTimer > 0) {
                             previewOpponentSpellTimer--;
                             if (previewOpponentSpellTimer === 0) {
                                 const level = 10; const s = opponent.stats[level];
                                 // Target player unit if exists, else bottom tower
                                 let tx = 130, ty = 140;
                                 const target = gameObjects.find(o => o.team === 'player' && o instanceof Unit);
                                 if (target) { tx = target.x; ty = target.y; }
                                 else { tx = 130; ty = 180; }
                                 
                                 if (currentPreviewOpponentId === 'poison') gameObjects.push(new PoisonSpell(tx, ty, 'ai', s.damagePerSecond, opponent.radius, s.duration));
                                 else if (currentPreviewOpponentId === 'anger') gameObjects.push(new AngerSpell(tx, ty, 'ai', opponent.radius, s.duration, s.damage));
                                 else if (currentPreviewOpponentId === 'voidTrap') gameObjects.push(new VoidTrapEffect(tx, ty, 'ai', opponent.radius, s.damage));
                                 else if (currentPreviewOpponentId === 'chaosOrb') gameObjects.push(new ChaosOrbEffect(tx, ty, 'ai', opponent.radius, s.damage));
                                 else if (currentPreviewOpponentId === 'skeletonYard') gameObjects.push(new SkeletonYard(tx, ty, 'ai', s.duration, opponent.radius, 10));
                                 else gameObjects.push(new Spell(tx, ty, 'ai', s.damage, opponent.radius, opponent.emoji));
                             }
                        }

                        // Update All
                        previewSimulationObjects.forEach(o => o.update());
                        
                        // Cleanup Dead
                    // Cleanup Dead (Refactored to match main game loop pattern)
                    const newPreviewObjects = [];
                    for (const obj of previewSimulationObjects) {
                        if (obj.health > 0) {
                            newPreviewObjects.push(obj);
                            continue;
                        }

                        // Handle death effects and special spawns
                        if (obj instanceof Unit) {
                            newPreviewObjects.push(new DeathEffect(obj.x, obj.y, obj.emoji));
                        }
                        if (obj instanceof BattleRam && !obj.didHit) {
                            obj.spawnBarbs(); // This also sets health to 0, so it won't be re-added
                            // Note: spawnBarbs pushes directly to gameObjects, which is aliased to newPreviewObjects here
                        }
                        if (obj instanceof StoneGiant && !obj.didSpawnMinis) {
                            obj.spawnMinis(); // This also pushes directly
                        }
                        // Huge Skeleton specific logic
                        if (obj instanceof HugeSkeleton && !obj.droppedBomb) {
                            obj.droppedBomb = true; // Mark as dropped
                            // The GiantBomb itself should be added to the newPreviewObjects
                            newPreviewObjects.push(new GiantBomb(obj.x, obj.y, obj.team, obj.bombDamage, 100));
                        }

                        // Don't remove towers in preview, just let them sit at 0 HP
                        if (obj instanceof Tower) {
                            if (obj.health <= 0) obj.health = 0;
                            newPreviewObjects.push(obj); // Keep towers regardless of health for continuous preview
                        }
                        // Other dead objects (like spells, projectiles) are simply not pushed to newPreviewObjects.
                    }
                    previewSimulationObjects = newPreviewObjects;

                    } catch(e) { console.error("Preview Loop Error:", e); }
                    finally {
                        // Restore Globals
                        deltaTime = originalGlobalDeltaTime; // Restore global deltaTime
                        gameObjects = globalGameObjects;
                        // Removed redundant `ctx = mainCtx;` as it's handled once outside the finally block.
                    }

                    // Draw All
                    previewSimulationObjects.forEach(o => o.draw());
                    
                    // Indicators
                    if (card.type === 'Spell' && previewSpellTimer > 0) {
                        ctx.save(); ctx.globalAlpha = 0.5; ctx.fillStyle = '#60a5fa';
                        ctx.beginPath(); ctx.arc(130, 60, card.radius, 0, Math.PI*2); ctx.fill(); ctx.restore();
                    }

                    ctx.restore(); // Restore Camera Transform
                    // --- RESTORE MAIN CONTEXT ---
                    ctx = mainCtx;
                    previewAnimationId = requestAnimationFrame(loop);
                }
                loop(performance.now()); // Call loop for the first time with current timestamp
            }

            function stopPreviewLoop() {
                if (previewAnimationId) cancelAnimationFrame(previewAnimationId);
                previewSimulationObjects = [];
                currentPreviewOpponentId = null;
            }
            
            function closeModal() {
                stopPreviewLoop();
                cardInfoModal.style.display = 'none';
            }
            
            async function addToDeck(cardId) {
                let currentDeck;
                if (gameMode === '2v2') currentDeck = playerDeck2v2;
                else if (gameMode === 'party1v1') currentDeck = playerDeckParty;
                else currentDeck = playerDeck;

                if (currentDeck.length < 8) {
                    currentDeck.push(cardId);
                    renderDeckScreen();
                    updateBattleButtonState(); // Update battle button immediately
                    openCardModal(cardId);
                    await saveUserData();
                }
            }
            async function removeFromDeck(cardId) {
                let currentDeck;
                if (gameMode === '2v2') currentDeck = playerDeck2v2;
                else if (gameMode === 'party1v1') currentDeck = playerDeckParty;
                else currentDeck = playerDeck;

                const index = currentDeck.indexOf(cardId);
                if (index > -1) {
                    currentDeck.splice(index, 1);
                    renderDeckScreen();
                    updateBattleButtonState(); // Update battle button immediately
                    openCardModal(cardId);
                    await saveUserData();
                }
            }
            async function upgradeCard(cardId) {
                const cardData = cardCollection[cardId];
                const costs = upgradeCosts[cardData.level];
                if (costs && cardData.count >= costs.cards && gold >= costs.gold) {
                    cardData.count -= costs.cards;
                    gold -= costs.gold;
                    cardData.level++;
                    goldDisplay.textContent = `üí∞ ${gold}`;
                    renderDeckScreen();
                    openCardModal(cardId);
                    await saveUserData();
                }
            }

            function shuffleDeck(deck) {
                let shuffled = [...deck]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } return shuffled;
            }

            function startGameDecks() {
                // Player
                let deckToUse;
                if (gameMode === '2v2') deckToUse = playerDeck2v2;
                else if (gameMode === 'party1v1') deckToUse = playerDeckParty;
                else deckToUse = playerDeck;

                gameDeck = shuffleDeck(deckToUse);
                hand = [];
                discardPile = [];
                for (let i = 0; i < 4; i++) { hand.push(gameDeck.pop()); }
                nextCard = gameDeck.pop();
                renderHand();
                
                // AI
                if (gameMode === 'snowman_challenge') {
                    // Special Deck for Snowman Challenge (Removed Snowman card, added Ice Spirit theme)
                    aiDeck = shuffleDeck(['coldSpirit', 'coldSpirit', 'giant', 'archer', 'arrows', 'skeletons', 'knight', 'fireball']);
                } else {
                    // Normal AI Deck Logic
                    const aiArenaLevel = getAILevel(); 
                    const aiArenaCards = getUnlockedCards(false, aiArenaLevel);
                    
                    aiDeck = [];
                    let availableCards = [...aiArenaCards];
                    for (let i = 0; i < 8; i++) {
                        if (availableCards.length === 0) availableCards = [...aiArenaCards]; 
                        let cardIndex = Math.floor(Math.random() * availableCards.length);
                        aiDeck.push(availableCards.splice(cardIndex, 1)[0]);
                    }
                    aiDeck = shuffleDeck(aiDeck);
                }
                aiHand = [];
                aiDiscardPile = [];
                for (let i = 0; i < 4; i++) { if(aiDeck.length > 0) aiHand.push(aiDeck.pop()); }
                if(aiDeck.length > 0) aiNextCard = aiDeck.pop();
            }
            
            function aiPlayCard(cardId) {
                if (!allCards[cardId]) return; // Safety check
                aiElixir -= allCards[cardId].cost;
                aiDiscardPile.push(cardId);
                const handIndex = aiHand.indexOf(cardId);
                if (handIndex > -1) { aiHand.splice(handIndex, 1); }
                aiHand.push(aiNextCard);
                if (aiDeck.length === 0) { aiDeck = shuffleDeck(aiDiscardPile); aiDiscardPile = []; }
                aiNextCard = aiDeck.pop() || null;
            }

            function renderHand() {
                cardHandEl.innerHTML = '';
                hand.forEach((cardId, index) => {
                    const cardEl = createCardDOM(cardId, false, true);
                    cardEl.dataset.handIndex = index;
                    // Handle touch/mouse down for card selection
                    cardEl.addEventListener('mousedown', (e) => selectCard(e, cardEl, cardId));
                    cardEl.addEventListener('touchstart', (e) => selectCard(e, cardEl, cardId), { passive: false });
                    cardHandEl.appendChild(cardEl);
                });
                nextCardSlotEl.innerHTML = '';
                if (nextCard) {
                    nextCardSlotEl.appendChild(createCardDOM(nextCard, true, true));
                }
                updateCardUI();
            }

            function selectCard(e, cardEl, cardId) {
                e.preventDefault(); // Prevent scrolling/other actions
                if (!gameRunning) return;
                const card = allCards[cardId];
                if (card.cost > playerElixir) { console.log("Not enough elixir!"); return; }
                
                // Deselect if already selected
                if (selectedSpawningUnit && selectedSpawningUnit.id === cardId) {
                    cancelPlacement();
                    return;
                }

                // NEW: Click-to-select logic
                isDragging = false;
                let initialPos = (e.touches && e.touches[0]) ? e.touches[0] : e;
                dragStartX = initialPos.clientX;
                dragStartY = initialPos.clientY;

                document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));
                placementIndicator.style.display = 'block'; // FIX: Show immediately
                placementOverlay.style.display = 'block'; // Show red overlay
                placementIndicator.innerHTML = '';
                
                selectedSpawningUnit = {
                    id: cardId, cost: card.cost, type: card.type, radius: card.radius || 0, placementRadius: card.placementRadius,
                    emoji: card.emoji, isFlying: card.isFlying, handIndex: cardEl.dataset.handIndex
                };
                
                if (card.type === 'Spell') {
                    isSpawningSpell = true;
                    spellRadius = card.radius;
                    placementIndicator.className = 'spell';
                    placementIndicator.style.width = `${card.radius * 2}px`;
                    placementIndicator.style.height = `${card.radius * 2}px`;
                    if (cardId === 'poison') { // NEW: Poison color
                        placementIndicator.style.background = 'rgba(234, 179, 8, 0.2)';
                        placementIndicator.style.borderColor = '#eab308';
                    } else if (cardId === 'anger') { // NEW: Anger color
                        placementIndicator.style.background = 'rgba(147, 51, 234, 0.2)';
                        placementIndicator.style.borderColor = '#9333ea';
                    }
                } else if (card.type === 'Spirit') { // NEW: Handle spirits
                    isSpawningSpell = false;
                    placementRadius = card.placementRadius;
                    placementIndicator.className = '';
                    placementIndicator.style.width = `${placementRadius * 2}px`;
                    placementIndicator.style.height = `${placementRadius * 2}px`;
                    placementIndicator.innerHTML = card.emoji;
                } else {
                    isSpawningSpell = false;
                    placementRadius = card.placementRadius;
                    placementIndicator.className = '';
                    placementIndicator.style.width = `${placementRadius * 2}px`;
                    placementIndicator.style.height = `${placementRadius * 2}px`;
                    placementIndicator.innerHTML = card.emoji;
                }
                cardEl.classList.add('selected');
                
                // Update placement overlay based on destroyed towers
                updatePlacementOverlay();
                
                // Move indicator to initial touch/mouse position
                movePlacementIndicator(initialPos);
            }
            
            function cancelPlacement() {
                isSpawningSpell = false;
                placementIndicator.style.display = 'none';
                placementIndicator.style.background = 'rgba(255, 255, 255, 0.2)'; // NEW: Reset poison/anger color
                placementIndicator.style.borderColor = 'white';
                placementOverlay.style.display = 'none'; // Hide red overlay
                selectedSpawningUnit = null;
                isDragging = false; // NEW
                document.querySelectorAll('#cardHand .card-ui.selected').forEach(c => c.classList.remove('selected'));
                updateCardUI();
            }

            function playCard(cardId, handIndex) {
                playerElixir -= allCards[cardId].cost;
                discardPile.push(cardId);
                hand.splice(handIndex, 1);
                hand.push(nextCard);
                if (gameDeck.length === 0) { gameDeck = shuffleDeck(discardPile); discardPile = []; }
                nextCard = gameDeck.pop();
                renderHand();
            }

            // --- NEW: Demo Mode AI for "Player" ---
            function demoRunPlayerAI() {
                if (playerElixir < 5) return; // Don't spam
                let affordableCards = hand.filter(id => allCards[id] && allCards[id].cost <= playerElixir && allCards[id].type !== 'Spell');
                if (affordableCards.length > 0) {
                    const cardId = affordableCards[Math.floor(Math.random() * affordableCards.length)];
                    const card = allCards[cardId];
                    const handIndex = hand.indexOf(cardId);
                    
                    // Find a valid spawn pos
                    const x = LANE_LEFT_X + Math.random() * (LANE_RIGHT_X - LANE_LEFT_X);
                    const y = RIVER_Y + 20 + Math.random() * 100; // Player's side

                    if (checkPlacement(x, y, card.placementRadius, card.type)) {
                        const level = (gameMode === '2v2') ? 15 : 5; // Demo level, force 15 in 2v2
                        // Safety check: ensure unitClass exists
                        if (!card.unitClass || typeof card.unitClass !== 'function') {
                            console.error('Invalid unitClass for card:', cardId, card);
                            return;
                        }
                        const newUnit = new card.unitClass(x, y, 'player', level);
                        if (newUnit instanceof GameObject) {
                            gameObjects.push(newUnit);
                        }
                        playCard(cardId, handIndex);
                    }
                }
            }


            // ==============================================
            // GAME OBJECTS (CLASSES)
            // ==============================================
                        class GameObject {
                constructor(x, y, radius, team, health) { 
                    this.x = x; this.y = y; this.radius = radius; this.team = team; this.health = health; this.maxHealth = health; this.id = Math.random(); 
                    // Visual Effects
                    this.spawnTimer = 0;
                    this.spawnMax = 12;
                    this.prevHealth = health;
                    this.hitFlashTimer = 0;
                }
                                drawHealthBar(level) {
                    const barWidth = this.radius * 2; 
                    const barHeight = 5; 
                    const barX = this.x - this.radius; 
                    // Adjusted barY to make space for health text
                    const barY = this.y - this.radius - (this instanceof Tower ? (this.isKing ? 15 : 10) : 12); 
                    
                    // Simple Shadow for bar
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(barX + 1, barY + 1, barWidth, barHeight);

                    if (this.health < this.maxHealth) {
                        ctx.fillStyle = '#7f1d1d'; // Dark Red bg
                        ctx.fillRect(barX, barY, barWidth, barHeight); 
                        ctx.fillStyle = '#22c55e'; 
                        ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight); 
                    } else {
                        ctx.fillStyle = '#22c55e'; 
                        ctx.fillRect(barX, barY, barWidth, barHeight); 
                    }
                    // Black outline
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                    
                    let levelTextY = null;
                    if (level) {
                        ctx.font = 'bold 11px Inter';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'black';
                        ctx.fillStyle = this.team === 'player' ? '#fff' : '#fcd34d'; 
                        let textX = this.x;
                        levelTextY = barY - 2; // Position level text slightly above the bar
                        if (this.isCombinedDoubleKing) levelTextY = this.y - this.height/2 - 14;
                        ctx.strokeText(`Lvl ${level}`, textX, levelTextY);
                        ctx.fillText(`Lvl ${level}`, textX, levelTextY);
                    }

                    // NEW: Draw health text ONLY for towers
                    if (this instanceof Tower) {
                        ctx.font = 'bold 10px Inter'; // Slightly smaller font for health
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top'; // Align to top of text, so Y is the top edge
                        ctx.fillStyle = 'white';
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        const healthText = `${Math.round(this.health)}`; // Show current health only

                        let healthTextY;
                        if (this.isCombinedDoubleKing) {
                            // The combined king tower is drawn with height `this.radius * 1.6` centered at `this.y`.
                            // So its bottom edge is `this.y + (this.radius * 1.6 / 2)`.
                            healthTextY = this.y + (this.radius * 1.6 / 2) + 5; // 5px below the bottom of the drawn rect
                        } else {
                            // Standard towers are drawn with height `this.radius * 2` centered at `this.y`.
                            // So its bottom edge is `this.y + this.radius`.
                            healthTextY = this.y + this.radius + 5; // 5px below the bottom of the drawn rect
                        }
                        
                        ctx.strokeText(healthText, this.x, healthTextY);
                        ctx.fillText(healthText, this.x, healthTextY);
                    }
                }
                draw(color, emoji, level) { 
                    // Spawn Animation Logic
                    let scale = 1;
                    if (this.spawnTimer < this.spawnMax) {
                        this.spawnTimer++;
                        const t = this.spawnTimer / this.spawnMax;
                        // Elastic pop effect
                        scale = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                        if (scale > 1.2) scale = 1.2;
                        if (t >= 1) scale = 1;
                    }

                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.scale(scale, scale);
                    
                    // Check Damage for Flash
                    if (this.health < this.prevHealth) {
                        this.hitFlashTimer = 5;
                        this.prevHealth = this.health;
                    }

                    // Shadow
                    ctx.beginPath();
                    ctx.ellipse(0, this.radius * 0.4, this.radius, this.radius * 0.4, 0, 0, Math.PI*2);
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fill();

                    // Unit Body
                    ctx.beginPath(); 
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2); 
                    ctx.fillStyle = color; 
                    
                    // Hit Flash Override
                    if (this.hitFlashTimer > 0) {
                        ctx.fillStyle = '#ffffff';
                        this.hitFlashTimer--;
                    }

                    ctx.fill(); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.stroke(); 
                    
                    if (emoji) { 
                        ctx.font = `${this.radius * 1.5}px Arial`; 
                        ctx.textAlign = 'center'; 
                        ctx.textBaseline = 'middle'; 
                        // No shadow for text inside to keep clean
                        ctx.fillText(emoji, 0, 0); 
                    }

                    ctx.restore(); // Restore scale/translate

                    this.drawHealthBar(level); 
                }
                update() {}
            }

            class DeathEffect extends GameObject {
                constructor(x, y, emoji) {
                    super(x, y, 0, 'neutral', 1);
                    this.emoji = emoji;
                    this.timer = 20;
                    this.rise = 0;
                }
                update() {
                    this.timer--;
                    this.rise += 1;
                    if (this.timer <= 0) this.health = 0;
                }
                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.timer / 20;
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = 'black'; // Shadow
                    ctx.fillText(this.emoji || 'üíÄ', this.x, this.y - this.rise);
                    ctx.restore();
                }
            }

            class ParticleExplosion extends GameObject {
                constructor(x, y, color) {
                    super(x, y, 0, 'neutral', 1);
                    this.particles = [];
                    // Bigger and more particles
                    for(let i=0; i<12; i++) {
                        const angle = (Math.PI * 2 * i) / 12;
                        this.particles.push({ 
                            x: 0, y: 0, 
                            vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4,
                            life: 20,
                            size: 4 + Math.random() * 4
                        });
                    }
                    this.color = color || '#ffc107';
                }
                update() {
                    let active = false;
                    this.particles.forEach(p => {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.life--;
                        if (p.life > 0) active = true;
                    });
                    if (!active) this.health = 0;
                }
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.fillStyle = this.color;
                    this.particles.forEach(p => {
                        if (p.life > 0) {
                            ctx.globalAlpha = p.life / 20;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                            ctx.fill();
                        }
                    });
                    ctx.restore();
                }
            }

            class DamageText extends GameObject {
                constructor(x, y, damage) {
                    super(x, y, 0, 'neutral', 1);
                    this.damage = Math.floor(damage);
                    this.life = 40;
                    this.maxLife = 40;
                    this.vY = -1.5;
                    this.vX = (Math.random() - 0.5) * 1;
                }
                update() {
                    this.life--;
                    this.x += this.vX;
                    this.y += this.vY;
                    if (this.life <= 0) this.health = 0;
                }
                draw() {
                    ctx.save();
                    const alpha = Math.max(0, this.life / 20);
                    ctx.globalAlpha = alpha;
                    ctx.font = 'bold 16px Inter';
                    ctx.fillStyle = '#ef4444';
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.textAlign = 'center';
                    ctx.strokeText(`-${this.damage}`, this.x, this.y);
                    ctx.fillText(`-${this.damage}`, this.x, this.y);
                    ctx.restore();
                }
            }

            function applyDamage(target, amount) {
                if (target && target.health > 0) {
                    target.health -= amount;
                    if (amount > 0) {
                        gameObjects.push(new DamageText(target.x, target.y - (target.radius || 10), amount));
                    }
                }
            }

            class WaffleProjectile extends GameObject {
                constructor(x, y, target) {
                    super(x, y, 6, 'neutral', 1);
                    this.target = target;
                    this.speed = 4;
                }
                update() {
                    if (!this.target || this.target.health <= 0) { this.health = 0; return; }
                    const dist = getDistance(this, this.target);
                    if (dist < this.speed) {
                        // Level up logic
                        if (this.target instanceof Unit) {
                             this.target.level = (this.target.level || 1) + 1;
                             gameObjects.push(new DamageText(this.target.x, this.target.y - 30, "UP!"));
                             // Recalculate stats based on new level if possible, or just heal full
                             this.target.health = this.target.maxHealth; // Simple bonus: full heal
                        }
                        this.health = 0;
                        return;
                    }
                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                    this.x += Math.cos(angle) * this.speed * (deltaTime * 60);
                    this.y += Math.sin(angle) * this.speed * (deltaTime * 60);
                }
                draw() {
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üßá', this.x, this.y);
                }
            }

            class Tower extends GameObject {
                constructor(x, y, team, isKing = false, level = 1, isCombinedDoubleKing = false, type = 'princess') {
                    const base = towerStats[level] || towerStats[1];
                    const def = towerDefs[type] || towerDefs['princess'];
                    
                    // Apply mods only to non-king towers (except for ability inheritance)
                    const hMod = isKing ? 1 : def.healthMod;
                    const dMod = isKing ? 1 : def.dmgMod;
                    const sMod = isKing ? 1 : def.speedMod;

                    const width = isCombinedDoubleKing ? 40 : (isKing ? 25 : 20);
                    const height = isCombinedDoubleKing ? 35 : (isKing ? 25 : 20);
                    super(x, y, width, team, (isKing ? base.kingHealth : base.princessHealth) * hMod);
                    
                    this.machineGunTimer = 0;
                    this.type = type;
                    this.def = def;
                    this.isKing = isKing;
                    this.isCombinedDoubleKing = isCombinedDoubleKing;
                    this.height = height;
                    this.level = level;
                    this.attackRange = 150;
                    this.attackDamage = base.damage * dMod;
                    this.baseAttackCooldown = (base.hitSpeed * sMod) * 60;
                    this.attackCooldown = this.baseAttackCooldown;
                    this.cooldownTimer = 0;
                    this.target = null;
                    this.isActive = isKing ? false : true;
                    this.activationAnimation = 0;
                    this.dyingAnimationTimer = 0;
                    
                    // Special timers
                    this.waffleTimer = 25 * 60;
                    // Machine Gun State
                    this.mgState = 'ready'; // 'ready' (bursting) or 'recharging'
                    this.mgTimer = 180; // 3s burst capacity initially
                }
                
                update() {
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; }

                    // Waffle Ability (King Only)
                    if (this.isKing && this.def.special === 'waffle') {
                        if (this.waffleTimer > 0) this.waffleTimer -= deltaTime * 60;
                        if (this.waffleTimer <= 0) {
                            const friend = gameObjects.find(o => o.team === this.team && o instanceof Unit);
                            if (friend) {
                                gameObjects.push(new WaffleProjectile(this.x, this.y, friend));
                                this.waffleTimer = 25 * 60;
                            }
                        }
                    }

                    // Machine Gun Logic (Non-King)
                    if (!this.isKing && this.def.special === 'burst') {
                        if (this.mgState === 'ready') {
                            this.attackCooldown = 15; // 0.25s Fast Fire
                            if (this.target) {
                                this.mgTimer -= deltaTime * 60;
                                if (this.mgTimer <= 0) {
                                    this.mgState = 'recharging';
                                    this.mgTimer = 600; // 10s recharge
                                    this.cooldownTimer = 90; // Force immediate slow delay
                                }
                            }
                        } else {
                            this.attackCooldown = 90; // 1.5s Slow Fire
                            this.mgTimer -= deltaTime * 60;
                            if (this.mgTimer <= 0) {
                                this.mgState = 'ready';
                                this.mgTimer = 180; // Reset to 3s burst
                            }
                        }
                    }



                    let kingNeedsToActivate = false;
                    if (this.isKing) {
                        const princessTowersDown = gameObjects.filter(t => t.team === this.team && !t.isKing && t.health > 0).length === 0;
                        if (princessTowersDown || this.health < this.maxHealth) {
                            if (!this.isActive) { 
                                this.isActive = true; 
                                this.activationAnimation = 30; 
                            }
                            kingNeedsToActivate = true;
                        }
                        if (!kingNeedsToActivate) return;
                    }

                    if (this.isActive) {
                        this.findTarget();
                        if (this.target && this.cooldownTimer <= 0) { this.attack(); }
                    }
                }
                findTarget() { 
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) { return; } 
                    this.target = null; 
                    let closestDist = this.attackRange; 
                    for (const obj of gameObjects) { 
                        if (obj.team !== this.team && (obj instanceof Unit)) {
                            if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                            const dist = getDistance(this, obj); 
                            if (dist < closestDist) { 
                                closestDist = dist; 
                                this.target = obj; 
                            } 
                        } 
                    } 
                }
                attack() { 
                    if (this.target) { 
                        if (this.isCombinedDoubleKing) {
                            const offset = 8;
                            gameObjects.push(new Projectile(this.x - offset, this.y, this.target, this.team, this.attackDamage)); 
                            gameObjects.push(new Projectile(this.x + offset, this.y, this.target, this.team, this.attackDamage)); 
                        } else {
                            // Visuals for different towers
                            if (this.def.special === 'rocket') {
                                 // Rocket logic: Create projectile with Rocket emoji
                                 const p = new Projectile(this.x, this.y, this.target, this.team, this.attackDamage);
                                 p.radius = 8; // Bigger
                                 p.speed = 3; // Slower
                                 gameObjects.push(p);
                                 // We don't have emoji support in Projectile class yet, relies on draw color. 
                                 // Let's leave as standard projectile for stability but high dmg.
                            } else {
                                 gameObjects.push(new Projectile(this.x, this.y, this.target, this.team, this.attackDamage)); 
                            }
                        }
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                }

                draw() { 
                    ctx.save(); 
                    
                    // Enhanced Tower Visuals
                    const baseColor = this.team === 'player' ? '#1e3a8a' : '#7f1d1d'; // Darker base
                    const mainColor = this.team === 'player' ? '#3b82f6' : '#ef4444'; // Main color
                    const highlight = this.team === 'player' ? '#60a5fa' : '#f87171'; // Highlight
                    
                    // Shake effect if dying
                    if (this.dyingAnimationTimer > 0) { 
                        ctx.globalAlpha = Math.max(0, this.dyingAnimationTimer / 30); 
                        const shakeX = (Math.random() - 0.5) * 4; 
                        const shakeY = (Math.random() - 0.5) * 4; 
                        ctx.translate(shakeX, shakeY);
                    }

                    if (this.isCombinedDoubleKing) {
                        // Double King Tower logic (simplified for now but using new colors)
                        const w = this.radius * 2.5;
                        const h = this.radius * 1.6;
                        ctx.fillStyle = baseColor;
                        ctx.fillRect(this.x - w/2, this.y - h/2 + 5, w, h); // Shadow/Base
                        ctx.fillStyle = mainColor;
                        ctx.fillRect(this.x - w/2, this.y - h/2, w, h);
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this.x - w/2, this.y - h/2, w, h);
                        
                        // Battlements
                        const batW = w / 5;
                        ctx.fillStyle = mainColor;
                        for(let i=0; i<5; i+=2) {
                             ctx.fillRect(this.x - w/2 + i*batW, this.y - h/2 - 6, batW, 6);
                             ctx.strokeRect(this.x - w/2 + i*batW, this.y - h/2 - 6, batW, 6);
                        }

                        const emojiSpacing = this.radius * 0.8;
                        ctx.font = `${this.radius * 0.8}px Arial`;
                        ctx.textAlign = 'center'; 
                        ctx.textBaseline = 'middle';
                        ctx.fillText('üëë', this.x - emojiSpacing/2, this.y);
                        ctx.fillText('üëë', this.x + emojiSpacing/2, this.y);

                    } else {
                        // Standard Tower Visuals (Castle Style)
                        const w = this.radius * 2;
                        const h = this.radius * 2;
                        
                        // REMOVED Darker Base Shadow as requested
                        // Main Body
                        ctx.fillStyle = mainColor;
                        ctx.fillRect(this.x - this.radius, this.y - this.radius, w, h);
                        
                        // 3D Highlight (Left side)
                        ctx.fillStyle = highlight;
                        ctx.fillRect(this.x - this.radius, this.y - this.radius, 4, h);

                        // Stone Texture (Horizontal Lines)
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        ctx.fillRect(this.x - this.radius, this.y - this.radius + h/3, w, 2);
                        ctx.fillRect(this.x - this.radius, this.y - this.radius + 2*h/3, w, 2);

                        // Battlements (Top)
                        const batW = w / 3;
                        const batH = 8;
                        ctx.fillStyle = mainColor;
                        // Left Battlement
                        ctx.fillRect(this.x - this.radius, this.y - this.radius - batH, batW/2, batH);
                        ctx.strokeRect(this.x - this.radius, this.y - this.radius - batH, batW/2, batH);
                        // Middle Battlement
                        ctx.fillRect(this.x - batW/4, this.y - this.radius - batH, batW/2, batH);
                        ctx.strokeRect(this.x - batW/4, this.y - this.radius - batH, batW/2, batH);
                        // Right Battlement
                        ctx.fillRect(this.x + this.radius - batW/2, this.y - this.radius - batH, batW/2, batH);
                        ctx.strokeRect(this.x + this.radius - batW/2, this.y - this.radius - batH, batW/2, batH);

                        // Border
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this.x - this.radius, this.y - this.radius, w, h);
                        
                        // Door (for King Tower) or Window
                        if (this.isKing) {
                             ctx.fillStyle = '#4b2e2e'; // Dark wood
                             ctx.beginPath();
                             ctx.arc(this.x, this.y + this.radius, this.radius/2.5, Math.PI, 0);
                             ctx.fill();
                        }

                        // Emoji
                        const emoji = this.isKing ? 'üëë' : (this.def.emoji || 'üë∏');
                        ctx.font = `${this.radius * 1.3}px Arial`;
                        ctx.textAlign = 'center'; 
                        ctx.textBaseline = 'middle';
                        ctx.fillText(emoji, this.x, this.y - 2);
                    }
                    
                    // Draw activation animation
                    if (this.activationAnimation > 0) { 
                        this.activationAnimation--; 
                        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 * (this.activationAnimation / 30)})`; 
                        ctx.beginPath(); 
                        ctx.arc(this.x, this.y, this.radius + 15, 0, Math.PI * 2); 
                        ctx.fill(); 
                    }

                    // Draw Machine Gun Bar
                    if (!this.isKing && this.def.special === 'burst') {
                        ctx.fillStyle = '#4b5563'; ctx.fillRect(this.x - 15, this.y - 40, 30, 4);
                        if (this.mgState === 'ready') {
                            // Bursting: Green bar draining
                            const p = Math.max(0, this.mgTimer / 180);
                            ctx.fillStyle = '#22c55e'; ctx.fillRect(this.x - 15, this.y - 40, 30 * p, 4);
                        } else {
                            // Recharging: Orange bar filling up
                            const p = Math.max(0, (600 - this.mgTimer) / 600);
                            ctx.fillStyle = '#f97316'; ctx.fillRect(this.x - 15, this.y - 40, 30 * p, 4);
                        }
                        // Border
                        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.strokeRect(this.x - 15, this.y - 40, 30, 4);
                    }
                    // Draw Waffle Bar
                    if (this.isKing && this.def.special === 'waffle') {
                        const p = Math.max(0, this.waffleTimer / (25 * 60));
                        ctx.fillStyle = '#4b5563'; ctx.fillRect(this.x - 20, this.y - 50, 40, 6);
                        ctx.fillStyle = '#f59e0b'; ctx.fillRect(this.x - 20, this.y - 50, 40 * (1-p), 6);
                    }
                    
                    this.drawHealthBar(this.level);
                    ctx.restore(); 
                }
            }

            class Building extends GameObject {
                constructor(x, y, team, level = 1, cardId) {
                    const s = allCards[cardId].stats[level];
                    super(x, y, 20, team, s.health);
                    this.level = level; // Store level
                    this.maxLifetime = parseFloat(s.lifetime) * 60;
                    this.lifetime = this.maxLifetime;
                    this.dyingAnimationTimer = 0;
                    this.spawnTimer = 0;
                    this.spawnRate = parseFloat(s.spawn_speed) * 60;
                    this.spawnLevel = level;
                    this.cardId = cardId;
                    this.emoji = allCards[cardId].emoji;
                }
                update() { 
                    if (this.health <= 0) return; 
                    this.lifetime -= deltaTime * 60; /* Scale lifetime by delta time */ 
                    
                    // --- BUILDING HEALTH DECAY FIX ---
                    // Calculate health decay per frame and subtract it
                    const decayPerFrame = this.maxHealth / this.maxLifetime;
                    this.health -= decayPerFrame * (deltaTime * 60);
                    // --- END FIX ---
                    
                    if (this.lifetime <= 0 || this.health <= 0) { // Check both
                        this.health = 0; 
                        return; 
                    } 
                    
                    this.spawnTimer -= deltaTime * 60; /* Scale spawn timer by delta time */
                    if (this.spawnTimer <= 0) {
                        let unitToSpawn = null;
                        if (this.cardId === 'hut') unitToSpawn = Goblin;
                        if (this.cardId === 'barbarianHut') unitToSpawn = Barbarian;
                        
                        if (unitToSpawn) {
                            gameObjects.push(new unitToSpawn(this.x + (Math.random()*10-5), this.y + (Math.random()*10-5), this.team, this.spawnLevel));
                        }
                        this.spawnTimer = this.spawnRate; 
                    } 
                }
                draw() { 
                    ctx.save(); 
                    if (this.dyingAnimationTimer > 0) { 
                        ctx.globalAlpha = Math.max(0, this.dyingAnimationTimer / 30); 
                        const shakeX = (Math.random() - 0.5) * 4; 
                        const shakeY = (Math.random() - 0.5) * 4; 
                        ctx.translate(shakeX, shakeY); 
                    } 
                    const color = this.team === 'player' ? '#3b82f6' : '#ef4444'; 
                    ctx.fillStyle = color; 
                    ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.strokeStyle = 'black'; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); 
                    ctx.font = `${this.radius * 1.5}px Arial`; 
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle'; 
                    ctx.fillText(this.emoji, this.x, this.y); 
                    this.drawHealthBar(this.level); // Pass level
                    ctx.restore(); 
                }
            }
            class GoblinHut extends Building { constructor(x, y, team, level = 1) { super(x, y, team, level, 'hut'); } }
            class BarbarianHut extends Building { constructor(x, y, team, level = 1) { super(x, y, team, level, 'barbarianHut'); } }


            class Unit extends GameObject {
                constructor(x, y, radius, team, health, speed, attackRange, attackDamage, attackCooldown, emoji, isFlying = false, targetsAir = false, level = 1, aggroRange = 100) {
                    super(x, y, radius, team, health);
                    this.level = level; // Store level
                    this.speed = speed;
                    this.attackRange = attackRange;
                    this.attackDamage = attackDamage;
                    this.attackCooldown = attackCooldown * 60;
                    this.cooldownTimer = 0;
                    this.target = null;
                    this.emoji = emoji;
                    this.isFlying = isFlying;
                    this.targetsAir = targetsAir;
                    this.aggroRange = aggroRange; // NEW
                }
                findTarget(forceFindTower = false) { // Add parameter
                    // --- NEW AGGRO AI (FIX) ---
                    let closestDist = this.aggroRange;
                    let bestTarget = null;
                    
                    // 1. Find closest troop, building, OR TOWER in aggro range
                    for (const obj of gameObjects) {
                        // --- THIS IS THE FIX ---
                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                            // Skip invisible Phantom Knights
                            if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                            // --- END FIX ---
                            if (!this.targetsAir && obj.isFlying) continue; 
                            
                            const dist = getDistance(this, obj);
                            if (dist < closestDist) {
                                closestDist = dist;
                                bestTarget = obj;
                            }
                        }
                    }
                    
                    // 2. If we found a distraction, return it.
                    if (bestTarget) {
                        return bestTarget;
                    }
        
                    // 3. If no troop/building in range, AND we are forced to (e.g., target died)
                    if (forceFindTower) {
                        let closestTowerDist = Infinity;
                        let towerTarget = null;
                        // Find closest Princess Tower in its lane
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {
                                if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {
                                    const dist = getDistance(this, obj);
                                    if (dist < closestTowerDist) { 
                                        closestTowerDist = dist; 
                                        towerTarget = obj; 
                                    }
                                }
                            }
                        }
                        // If no lane tower, find King
                        if (!towerTarget) {
                            for (const obj of gameObjects) {
                                if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {
                                    const dist = getDistance(this, obj);
                                    if (dist < closestTowerDist) { 
                                        closestTowerDist = dist; 
                                        towerTarget = obj; 
                                    }
                                }
                            }
                        }
                        return towerTarget; // Return the tower
                    }
                    
                    // 4. If no distraction and not forced, return null (keep current target)
                    return null;
                    // --- END AI FIX ---
                }
                move() {
                    if (!this.target || this.frozen) return; // NEW: Don't move if frozen
                    const dist = getDistance(this, this.target);
                    if (dist <= this.attackRange) { return; }
                    let targetX = this.target.x;
                    let targetY = this.target.y;
                    if (!this.isFlying) {
                        const needsToCross = (this.team === 'player' && this.y > RIVER_Y && this.target.y < RIVER_Y) || (this.team === 'ai' && this.y < RIVER_Y && this.target.y > RIVER_Y);
                        if (needsToCross) {
                            
                            let bridgeX = (this.x < WIDTH / 2) ? LANE_LEFT_X : LANE_RIGHT_X;
                            // FIX: This was the bug. It was pathing to the target's bridge, not its own.
                            // if(this.target.x < WIDTH / 2) bridgeX = LANE_LEFT_X;
                            // else bridgeX = LANE_RIGHT_X;
                            
                            if ( (this.team === 'player' && this.y > (RIVER_Y + 10)) || (this.team === 'ai' && this.y < (RIVER_Y - 10)) ) {
                                targetX = bridgeX;
                                targetY = BRIDGE_Y;
                            }
                        }
                    }
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    this.x += Math.cos(angle) * this.speed * (deltaTime * 60); /* Scale movement by delta time */
                    this.y += Math.sin(angle) * this.speed * (deltaTime * 60);
                }
                attack() { 
                    if (this.target && this.cooldownTimer <= 0) { 
                        if (this.target instanceof PhantomKnight && this.target.isInvisible) {
                            return;
                        }
                        if (this.attackRange <= this.radius + this.target.radius + 5) { // Melee
                            applyDamage(this.target, this.attackDamage); 
                        } else { // Ranged
                            let projectileType = Projectile;
                            let damage = this.attackDamage;
                            let splash = 0;
                            if (this.emoji === 'üê≤') {
                                projectileType = FireballProjectile;
                                splash = allCards['fireDragon'].stats[this.level].splashRadius;
                            }
                            gameObjects.push(new projectileType(this.x, this.y, this.target, this.team, damage, splash)); 
                        } 
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                } 
                update() {
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; } /* Scale cooldown by delta time */
                    // NEW: Don't update if frozen
                    if (this.frozen) return;
                    
                    // --- AGGRO FIX ---
                    // 1. If we have a target and are in attack range, just attack. DO NOT look for new targets.
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack();
                        return; // <-- This is the key. Stop update here.
                    }
                    
                    // 2. We are not in attack range. Check for new distractions.
                    let distraction = this.findTarget(false); // 'false' means only scan aggro range
                    
                    // 3. If a distraction exists...
                    if (distraction) {
                        // ...and we don't have a target OR the distraction is closer than our current target
                        if (!this.target || this.target.health <= 0 || getDistance(this, distraction) < getDistance(this, this.target)) {
                            this.target = distraction;
                        }
                    } else {
                        // 4. No distraction. Check if our long-distance target is dead/gone
                        if (!this.target || this.target.health <= 0) {
                            this.target = this.findTarget(true); // Find a new tower
                        }
                        // 5. We have a valid long-distance target (troop, building, or tower), just keep it.
                    }
                    // --- END AI FIX ---

                    if (this.target && this.target.health > 0) {
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
                draw() { 
                    const color = this.team === 'player' ? '#60a5fa' : '#f87171'; 
                    super.draw(color, this.emoji, this.level);
                    // NEW: Draw purple effect for angered units
                    if (this.isAngered) {
                        ctx.save();
                        ctx.strokeStyle = '#9333ea'; // purple-600
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }

            class Knight extends Unit { constructor(x, y, team, level = 1) { const s = allCards['knight'].stats[level]; super(x, y, 12, team, s.health, 1.2, 25, s.damage, s.hitSpeed, '‚öîÔ∏è', false, false, level, allCards['knight'].aggroRange); } }
            class Archer extends Unit { constructor(x, y, team, level = 1) { const s = allCards['archer'].stats[level]; super(x, y, 10, team, s.health, 1.2, 120, s.damage, s.hitSpeed, 'üèπ', false, true, level, allCards['archer'].aggroRange); } }
            
            class Giant extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['giant'].stats[level];
                    super(x, y, 18, team, s.health, s.speed, 30, s.damage, s.hitSpeed, 'üí™', false, false, level, allCards['giant'].aggroRange);
                    this.targetLocked = false;
                }
                findTarget() {
                    // --- BUILDING-TARGETING AI FIX ---
        
                    // 1. Find the default tower target (closest tower in lane, or king)
                    let closestTowerDist = Infinity;
                    let towerTarget = null;
        
                    // Find closest Princess Tower in its lane
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {
                            if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {
                                const dist = getDistance(this, obj);
                                if (dist < closestTowerDist) { 
                                    closestTowerDist = dist; 
                                    towerTarget = obj; 
                                }
                            }
                        }
                    }
                    // If no lane tower, find King
                    if (!towerTarget) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {
                                const dist = getDistance(this, obj);
                                if (dist < closestTowerDist) { 
                                    closestTowerDist = dist; 
                                    towerTarget = obj; 
                                }
                            }
                        }
                    }
        
                    // 2. Find the closest building (as a potential distraction)
                    let closestBuildingDist = Infinity;
                    let buildingTarget = null;
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Building)) {
                            const dist = getDistance(this, obj);
                            if (dist < closestBuildingDist) { 
                                closestBuildingDist = dist; 
                                buildingTarget = obj; 
                            }
                        }
                    }
        
                    // 3. Decide: Is the building a valid, closer distraction?
                    // Use Infinity if no tower target exists
                    const towerDist = towerTarget ? closestTowerDist : Infinity;
                    
                    if (buildingTarget && closestBuildingDist <= this.aggroRange && closestBuildingDist < towerDist) {
                        // Attack the building
                        this.target = buildingTarget;
                    } else {
                        // No valid distraction, attack the tower
                        this.target = towerTarget;
                    }
                    
                    this.targetLocked = (this.target != null);
                    // --- END AI FIX ---
                }
                // FIX: Add custom update to ONLY use building-find logic
                update() {
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; } /* Scale cooldown by delta time */
                    
                    // --- TARGET LOCK-ON FIX (FOR REAL) ---
                    // 1. If we have a target and are in attack range, just attack.
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack();
                        return; // Lock in combat
                    }
    
                    // 2. We do not have a valid target OR our target is a tower (so we can be distracted)
                    if (!this.target || this.target.health <= 0 || (this.target instanceof Tower)) {
                         this.findTarget(); // This will find a tower OR a closer building
                    }
                    // 3. If our target is a building, we are "locked on" and will NOT re-scan.
                    // --- END AI FIX ---
    
                    if (this.target && this.target.health > 0) {
                        // (This check is redundant, but safe)
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
            }
            class Goblin extends Unit { constructor(x, y, team, level = 1) { const s = allCards['goblins'].stats[level]; super(x, y, 8, team, s.health, 1.2, 20, s.damage, s.hitSpeed, 'üë∫', false, false, level, allCards['goblins'].aggroRange); } } // Speed 1.5 -> 1.2
            class Skeleton extends Unit { constructor(x, y, team, level = 1) { const s = allCards['skeletons'].stats[level]; super(x, y, 7, team, s.health, 1.4, 20, s.damage, s.hitSpeed, 'üíÄ', false, false, level, allCards['skeletons'].aggroRange); } } // Speed 1.6 -> 1.4
            class TinyBot extends Unit { constructor(x, y, team, level = 1) { const s = allCards['tinyBot'].stats[level]; super(x, y, 10, team, s.health, 1.0, 25, s.damage, s.hitSpeed, 'ü§ñ', false, false, level, allCards['tinyBot'].aggroRange); } } // Speed 1.2 -> 1.0
            class Goblins { constructor(x, y, team, level = 1) { const s = allCards['goblins'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Goblin(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            class Skeletons { constructor(x, y, team, level = 1) { const s = allCards['skeletons'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Skeleton(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            
            // --- NEW CARD CLASSES ---
            class SpearGoblin extends Unit { constructor(x, y, team, level = 1) { const s = allCards['goblinGang'].stats[level]; super(x, y, 8, team, s.spear_health, 1.2, 100, s.spear_damage, s.spear_hitSpeed, 'üéØ', false, true, level, allCards['goblinGang'].aggroRange); } } // Speed 1.5 -> 1.2
            class GoblinGang { constructor(x, y, team, level = 1) { const s = allCards['goblinGang'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Goblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } for (let i = 0; i < s.spear_count; i++) { gameObjects.push(new SpearGoblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } } }
            class SkeletonArmy { constructor(x, y, team, level = 1) { const s = allCards['skeletonArmy'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Skeleton(x + Math.random()*30-15, y + Math.random()*30-15, team, level)); } } }
            class Barbarian extends Unit { constructor(x, y, team, level = 1) { const s = allCards['barbarians'].stats[level]; super(x, y, 11, team, s.health, 0.9, 25, s.damage, s.hitSpeed, 'üßî', false, false, level, allCards['barbarians'].aggroRange); } } // Speed 1.1 -> 0.9
            class Barbarians { constructor(x, y, team, level = 1) { const s = allCards['barbarians'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Barbarian(x + Math.random()*10-5, y + Math.random()*10-5, team, level)); } } }
            class FireDragon extends Unit { constructor(x, y, team, level = 1) { const s = allCards['fireDragon'].stats[level]; super(x, y, 14, team, s.health, 1.0, 110, s.damage, s.hitSpeed, 'üê≤', true, true, level, allCards['fireDragon'].aggroRange); } } // Speed 1.2 -> 1.0
            class BattleRam extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['battleRam'].stats[level];
                    super(x, y, 15, team, s.health, 1.0, 25, s.damage, 1, 'üå≤', false, false, level, allCards['battleRam'].aggroRange); // Speed 1.2 -> 1.0
                    this.barbLevel = s.barbLevel;
                    this.chargeTimer = 3 * 60;
                    this.isCharging = false;
                    this.didHit = false; // Flag to prevent double spawns
                    this.targetLocked = false;
                }
                
                findTarget() {
                    // --- BUILDING-TARGETING AI FIX ---
        
                    // 1. Find the default tower target (closest tower in lane, or king)
                    let closestTowerDist = Infinity;
                    let towerTarget = null;
        
                    // Find closest Princess Tower in its lane
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {
                            if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {
                                const dist = getDistance(this, obj);
                                if (dist < closestTowerDist) { 
                                    closestTowerDist = dist; 
                                    towerTarget = obj; 
                                }
                            }
                        }
                    }
                    // If no lane tower, find King
                    if (!towerTarget) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {
                                const dist = getDistance(this, obj);
                                if (dist < closestTowerDist) { 
                                    closestTowerDist = dist; 
                                    towerTarget = obj; 
                                }
                            }
                        }
                    }
        
                    // 2. Find the closest building (as a potential distraction)
                    let closestBuildingDist = Infinity;
                    let buildingTarget = null;
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Building)) {
                            const dist = getDistance(this, obj);
                            if (dist < closestBuildingDist) { 
                                closestBuildingDist = dist; 
                                buildingTarget = obj; 
                            }
                        }
                    }
        
                    // 3. Decide: Is the building a valid, closer distraction?
                    // Use Infinity if no tower target exists
                    const towerDist = towerTarget ? closestTowerDist : Infinity;
                    
                    if (buildingTarget && closestBuildingDist <= this.aggroRange && closestBuildingDist < towerDist) {
                        // Attack the building
                        this.target = buildingTarget;
                    } else {
                        // No valid distraction, attack the tower
                        this.target = towerTarget;
                    }
                    
                    this.targetLocked = (this.target != null);
                    // --- END AI FIX ---
                }
                
                spawnBarbs() {
                    if (this.didHit) return; // Don't spawn twice
                    this.didHit = true;
                    gameObjects.push(new Barbarian(this.x + 5, this.y, this.team, this.barbLevel));
                    gameObjects.push(new Barbarian(this.x - 5, this.y, this.team, this.barbLevel));
                    this.health = 0; // Ram is destroyed
                }

                update() {
                    if (this.health <= 0 && !this.didHit) {
                        this.spawnBarbs(); // Spawn if killed by damage
                        return;
                    }
                    if (this.didHit) return; // Already spawned, do nothing
                    
                    if (this.chargeTimer > 0) { this.chargeTimer -= deltaTime * 60; if(this.chargeTimer <= 0) this.isCharging = true; } /* Scale charge timer by delta time */
                    if (this.isCharging) this.speed = 2.0; else this.speed = 1.0;
                    
                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; } /* Scale cooldown by delta time */
    
                    // --- TARGET LOCK-ON FIX (FOR REAL) ---
                    // 1. If we have a target and are in attack range, just attack.
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack(); // This will call spawnBarbs()
                        return; // Lock in combat
                    }
    
                    // 2. We do not have a valid target OR our target is a tower (so we can be distracted)
                    if (!this.target || this.target.health <= 0 || (this.target instanceof Tower)) {
                         this.findTarget(); // This will find a tower OR a closer building
                    }
                    // 3. If our target is a building, we are "locked on" and will NOT re-scan.
                    // --- END AI FIX ---
                    
                    if (this.target && this.target.health > 0) {
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
                attack() { // Ram only attacks when it hits
                    if (this.target && this.cooldownTimer <= 0) {
                        if (this.target instanceof PhantomKnight && this.target.isInvisible) {
                            return;
                        }
                        applyDamage(this.target, this.attackDamage);
                        this.spawnBarbs(); // Spawn on hit
                    } 
                }
            }
            
            class AxeSwinger extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['axeSwinger'].stats[level];
                    super(x, y, 12, team, s.health, 1.0, 0, s.damage, s.hitSpeed, 'ü™ì', false, false, level, allCards['axeSwinger'].aggroRange); // Speed 1.2 -> 1.0
                    this.splashRadius = s.splashRadius;
                    this.attackAnimationTimer = 0; // NEW
                }
                attack() { 
                    if (this.cooldownTimer <= 0) { 
                        this.attackAnimationTimer = 20; // NEW: Start animation
                        for (const obj of gameObjects) {
                            // Hit all non-flying enemies in range
                            if (obj.team !== this.team && !obj.isFlying && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                // Skip invisible Phantom Knights
                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                if (getDistance(this, obj) < this.splashRadius) {
                                    applyDamage(obj, this.attackDamage);
                                }
                            }
                        }
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                }
                // FIX: Custom update to allow attacking at splash range
                update() {
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; } /* Scale cooldown by delta time */
                    if (this.attackAnimationTimer > 0) { this.attackAnimationTimer--; } // NEW

                    // --- AGGRO FIX (Copy from Unit) ---
                    // 1. If we have a target and are in attack range, just attack. DO NOT look for new targets.
                    let inSplashRange = false;
                    if (this.target && this.target.health > 0) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && !obj.isFlying && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                // Skip invisible Phantom Knights
                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                if (getDistance(this, obj) < this.splashRadius) {
                                    inSplashRange = true;
                                    break;
                                }
                            }
                        }
                    }

                    if (inSplashRange) {
                        this.attack();
                        return; // <-- This is the key. Stop update here.
                    }
                    
                    // 2. We are not in attack range. Check for new distractions.
                    let distraction = this.findTarget(false); // 'false' means only scan aggro range
                    
                    // 3. If a distraction exists...
                    if (distraction) {
                        // ...and we don't have a target OR the distraction is closer than our current target
                        if (!this.target || this.target.health <= 0 || getDistance(this, distraction) < getDistance(this, this.target)) {
                            this.target = distraction;
                        }
                    } else {
                        // 4. No distraction. Check if our long-distance target is dead/gone
                        if (!this.target || this.target.health <= 0) {
                            this.target = this.findTarget(true); // Find a new tower
                        }
                        // 5. We have a valid long-distance target (troop, building, or tower), just keep it.
                    }
                    // --- END AI FIX ---

                    if (this.target && this.target.health > 0) {
                        if (inSplashRange) { // Re-check
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
                // NEW: Draw attack animation
                draw() {
                    super.draw(); // Draw the unit first
                    if (this.attackAnimationTimer > 0) {
                        const progress = this.attackAnimationTimer / 20;
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.splashRadius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(220, 38, 38, ${0.5 * (1 - progress)})`; // Fade out
                        ctx.fill();
                        ctx.restore(); // <-- ADDED THIS MISSING LINE
                    }
                }
            } // <-- ADDED THIS MISSING CLOSING BRACE

            // --- FARMER (NEW) ---
            class Farmer extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['farmer'].stats[level];
                    super(x, y, 12, team, s.health, 1.0, 25, s.damage, s.hitSpeed, 'üë®‚Äçüåæ', false, false, level, allCards['farmer'].aggroRange); // Speed 1.2 -> 1.0
                    this.attackWidth = s.attackWidth;
                    this.attackHeight = s.attackHeight;
                    this.attackAnimationTimer = 0;
                    this.attackAngle = 0;
                }
                attack() { 
                    if (this.cooldownTimer <= 0) { 
                        this.attackAnimationTimer = 20; // Start animation
                        this.attackAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);

                        // Check for hits in a rectangle
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && !obj.isFlying && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                // Skip invisible Phantom Knights
                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                if (isInside(obj, this.x, this.y, this.attackWidth, this.attackHeight, this.attackAngle)) {
                                    applyDamage(obj, this.attackDamage);
                                }
                            }
                        }
                        this.cooldownTimer = this.attackCooldown; 
                    } 
                }
                update() {
                    if (this.attackAnimationTimer > 0) { this.attackAnimationTimer--; }
                    
                    // Standard unit update logic (copied from Unit)
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }
                    
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack();
                        return; 
                    }
                    let distraction = this.findTarget(false);
                    if (distraction) {
                        if (!this.target || this.target.health <= 0 || getDistance(this, distraction) < getDistance(this, this.target)) {
                            this.target = distraction;
                        }
                    } else {
                        if (!this.target || this.target.health <= 0) {
                            this.target = this.findTarget(true); 
                        }
                    }
                    if (this.target && this.target.health > 0) {
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
                draw() {
                    super.draw(); // Draw the unit
                    if (this.attackAnimationTimer > 0) {
                        const progress = this.attackAnimationTimer / 20;
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.attackAngle);
                        ctx.fillStyle = `rgba(220, 38, 38, ${0.5 * (1 - progress)})`;
                        // Draw rectangle in front of the unit
                        ctx.fillRect(this.radius, -this.attackWidth / 2, this.attackHeight, this.attackWidth);
                        ctx.restore();
                    }
                }
            }

            // --- PIG (NEW) ---
            class Pig extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['pigs'].stats[level];
                    super(x, y, 10, team, s.health, 1.4, 25, s.damage, s.hitSpeed, 'üê∑', false, false, level, allCards['pigs'].aggroRange); // Speed 1.8 -> 1.4
                    this.targetLocked = false;
                }
                // Use building-only targeting
                findTarget() {
                    // --- BUILDING-TARGETING AI FIX ---
        
                    // 1. Find the default tower target (closest tower in lane, or king)
                    let closestTowerDist = Infinity;
                    let towerTarget = null;
        
                    // Find closest Princess Tower in its lane
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {
                            if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {
                                const dist = getDistance(this, obj);
                                if (dist < closestTowerDist) { 
                                    closestTowerDist = dist; 
                                    towerTarget = obj; 
                                }
                            }
                        }
                    }
                    // If no lane tower, find King
                    if (!towerTarget) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {
                                const dist = getDistance(this, obj);
                                if (dist < closestTowerDist) { 
                                    closestTowerDist = dist; 
                                    towerTarget = obj; 
                                }
                            }
                        }
                    }
        
                    // 2. Find the closest building (as a potential distraction)
                    let closestBuildingDist = Infinity;
                    let buildingTarget = null;
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Building)) {
                            const dist = getDistance(this, obj);
                            if (dist < closestBuildingDist) { 
                                closestBuildingDist = dist; 
                                buildingTarget = obj; 
                            }
                        }
                    }
        
                    // 3. Decide: Is the building a valid, closer distraction?
                    // Use Infinity if no tower target exists
                    const towerDist = towerTarget ? closestTowerDist : Infinity;

                    if (buildingTarget && closestBuildingDist <= this.aggroRange && closestBuildingDist < towerDist) {
                        // Attack the building
                        this.target = buildingTarget;
                    } else {
                        // No valid distraction, attack the tower
                        this.target = towerTarget;
                    }
                    
                    this.targetLocked = (this.target != null);
                    // --- END AI FIX ---
                }
                update() { // Custom update to use building-only AI
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; } /* Scale cooldown by delta time */
                    
                    // --- TARGET LOCK-ON FIX (FOR REAL) ---
                    // 1. If we have a target and are in attack range, just attack.
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack();
                        return; // Lock in combat
                    }
    
                    // 2. We do not have a valid target OR our target is a tower (so we can be distracted)
                    if (!this.target || this.target.health <= 0 || (this.target instanceof Tower)) {
                         this.findTarget(); // This will find a tower OR a closer building
                    }
                    // 3. If our target is a building, we are "locked on" and will NOT re-scan.
                    // --- END AI FIX ---
    
                    if (this.target && this.target.health > 0) {
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
            }
            class Pigs { constructor(x, y, team, level = 1) { const s = allCards['pigs'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new Pig(x + Math.random()*20-10, y + Math.random()*20-10, team, level)); } } }
            
            // --- FLYING SKELETON (NEW) ---
            class FlyingSkeleton extends Unit { 
                constructor(x, y, team, level = 1) { 
                    const s = allCards['flyingSkeletons'].stats[level]; 
                    super(x, y, 9, team, s.health, 1.4, 25, s.damage, s.hitSpeed, 'üíÄü¶á', true, true, level, allCards['flyingSkeletons'].aggroRange); 
                } 
                // Removed custom draw() function to use the emoji
            }
            class FlyingSkeletons { constructor(x, y, team, level = 1) { const s = allCards['flyingSkeletons'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new FlyingSkeleton(x + Math.random()*20-10, y + Math.random()*20-10, team, level)); } } }
            
            // --- MEGA FLYING SKELETON (NEW) ---
            class MegaFlyingSkeleton extends Unit { 
                constructor(x, y, team, level = 1) { 
                    const s = allCards['megaFlyingSkeleton'].stats[level]; 
                    super(x, y, 14, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'üíÄü¶á', true, true, level, allCards['megaFlyingSkeleton'].aggroRange); 
                } 
                // Removed custom draw() function to use the emoji
            }
            
            // --- FLYING SKELETON GROUP (NEW) ---
            class FlyingSkeletonGroup { constructor(x, y, team, level = 1) { const s = allCards['flyingSkeletonGroup'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new FlyingSkeleton(x + Math.random()*30-15, y + Math.random()*30-15, team, level)); } } }

            // --- WARLOCK (NEW) ---
            class Warlock extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['warlock'].stats[level];
                    super(x, y, 12, team, s.health, 1.0, 110, s.damage, s.hitSpeed, 'üîÆ', false, true, level, allCards['warlock'].aggroRange);
                    this.splashRadius = s.splashRadius;
                }
                attack() {
                    if (this.target && this.cooldownTimer <= 0) {
                        // Create splash projectile
                        gameObjects.push(new FireballProjectile(this.x, this.y, this.target, this.team, this.attackDamage, this.splashRadius));
                        this.cooldownTimer = this.attackCooldown;
                    }
                }
            }

            // --- MAGE (ARENA 7) ---
            class Mage extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['mage'].stats[level];
                    super(x, y, 12, team, s.health, 1.0, 110, s.damage, s.hitSpeed, 'üßô‚Äç‚ôÄÔ∏è', false, true, level, allCards['mage'].aggroRange);
                    this.splashRadius = s.splashRadius;
                    this.skeletonSpawnTimer = 0; // Instantly spawn on place
                    this.hasSpawnedInitial = false;
                }
                attack() {
                    if (this.target && this.cooldownTimer <= 0) {
                        // Create splash projectile
                        gameObjects.push(new FireballProjectile(this.x, this.y, this.target, this.team, this.attackDamage, this.splashRadius));
                        this.cooldownTimer = this.attackCooldown;
                    }
                }
                update() {
                    super.update();
                    if (this.health <= 0) return;
                    if (!this.hasSpawnedInitial) {
                        // Instantly spawn 4 skeletons on placement
                        const offset = 18;
                        const positions = [
                            { dx: -offset, dy: -offset }, // top left
                            { dx: -offset, dy: offset },  // bottom left
                            { dx: offset, dy: -offset },  // top right
                            { dx: offset, dy: offset }    // bottom right
                        ];
                        for (const pos of positions) {
                            gameObjects.push(new Skeleton(this.x + pos.dx, this.y + pos.dy, this.team, this.level));
                        }
                        this.skeletonSpawnTimer = 5 * 60;
                        this.hasSpawnedInitial = true;
                    } else {
                        this.skeletonSpawnTimer -= deltaTime * 60; /* Scale spawn timer by delta time */
                        if (this.skeletonSpawnTimer <= 0) {
                            const offset = 18;
                            const positions = [
                                { dx: -offset, dy: -offset }, // top left
                                { dx: -offset, dy: offset },  // bottom left
                                { dx: offset, dy: -offset },  // top right
                                { dx: offset, dy: offset }    // bottom right
                            ];
                            for (const pos of positions) {
                                gameObjects.push(new Skeleton(this.x + pos.dx, this.y + pos.dy, this.team, this.level));
                            }
                            this.skeletonSpawnTimer = 5 * 60;
                        }
                    }
                }

            }

            // --- PHANTOM KNIGHT (ARENA 7) ---
            class PhantomKnight extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['phantomKnight'].stats[level];
                    super(x, y, 12, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'üëª‚öîÔ∏è', false, false, level, allCards['phantomKnight'].aggroRange);
                    this.isInvisible = true;
                    this.lastAttackTime = 0;
                    this.invisibilityDelay = 180;
                }
                attack() {
                    if (this.target && this.cooldownTimer <= 0) {
                        this.isInvisible = false;
                        this.lastAttackTime = 0;
                        if (this.attackRange <= this.radius + this.target.radius + 5) {
                            applyDamage(this.target, this.attackDamage);
                        } else {
                            let projectileType = Projectile;
                            let damage = this.attackDamage;
                            let splash = 0;
                            if (this.emoji === 'üê≤') {
                                projectileType = FireballProjectile;
                                splash = allCards['fireDragon'].stats[this.level].splashRadius;
                            }
                            gameObjects.push(new projectileType(this.x, this.y, this.target, this.team, damage, splash));
                        }
                        this.cooldownTimer = this.attackCooldown;
                    }
                }
                update() {
                    if (this.health <= 0) return;
                    if (this.cooldownTimer > 0) { this.cooldownTimer--; }
                    
                    if (this.frozen) return;
                    
                    if (!this.isInvisible) {
                        this.lastAttackTime += deltaTime * 60; /* Scale last attack time by delta time */
                        if (this.lastAttackTime >= this.invisibilityDelay) {
                            this.isInvisible = true;
                            this.lastAttackTime = 0;
                        }
                    }
                    
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange) {
                        this.attack();
                        return;
                    }
                    
                    let distraction = this.findTarget(false);
                    
                    if (distraction) {
                        if (!this.target || this.target.health <= 0 || getDistance(this, distraction) < getDistance(this, this.target)) {
                            this.target = distraction;
                        }
                    } else {
                        if (!this.target || this.target.health <= 0) {
                            this.target = this.findTarget(true);
                        }
                    }

                    if (this.target && this.target.health > 0) {
                        if (getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        } else {
                            this.move();
                        }
                    }
                }
                draw() {
                    if (this.isInvisible) {
                        ctx.save();
                        ctx.globalAlpha = 0.2;
                        const color = this.team === 'player' ? '#60a5fa' : '#f87171';
                        super.draw(color, this.emoji, this.level);
                        ctx.globalAlpha = 1;
                        ctx.restore();
                    } else {
                        const color = this.team === 'player' ? '#60a5fa' : '#f87171';
                        super.draw(color, this.emoji, this.level);
                    }
                }
            }

            // --- SPIRIT LANTERN (ARENA 7) ---
            class SpiritLantern extends Building {
                constructor(x, y, team, level = 1) {
                    super(x, y, team, level, 'spiritLantern');
                    this.spiritTypes = ['zapSpirit', 'coldSpirit', 'lifeSpirit'];
                    this.spawnTimer = this.spawnRate;
                }
                update() {
                    if (this.health <= 0) return;
                    this.lifetime -= deltaTime * 60; /* Scale lifetime by delta time */
                    if (this.lifetime <= 0) { this.health = 0; return; }
                    // Health decay
                    const decayPerFrame = this.maxHealth / this.maxLifetime;
                    this.health -= decayPerFrame;
                    this.spawnTimer -= deltaTime * 60; /* Scale spawn timer by delta time */
                    if (this.spawnTimer <= 0) {
                        // Randomly pick a spirit type
                        const spiritType = this.spiritTypes[Math.floor(Math.random() * this.spiritTypes.length)];
                        gameObjects.push(new allCards[spiritType].unitClass(this.x + (Math.random()-0.5)*10, this.y + (Math.random()-0.5)*10, this.team, this.level));
                        this.spawnTimer = this.spawnRate;
                    }
                }
            }

// --- SPIRIT CLASSES (NEW, FROM SCRATCH) ---
class ColdSpirit extends Unit {
    constructor(x, y, team, level = 1) {
        const s = allCards['coldSpirit'].stats[level];
        super(x, y, 9, team, s.health, 1.5, 20, 10, 1, '‚ùÑÔ∏è', false, false, level, allCards['coldSpirit'].aggroRange);
        this.jumpRadius = s.jumpRadius;
        this.effectRadius = s.effectRadius;
        this.freezeDuration = s.freezeDuration;
        this.hasJumped = false;
    }
    update() {
        if (this.health <= 0 || this.hasJumped) return;
        // Use standard land troop AI to find target in aggro range
        let target = null;
        // Find closest enemy unit (including flying), building, or tower in aggro range
        let closestDist = this.jumpRadius;
        for (const obj of gameObjects) {
            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                // Skip invisible Phantom Knights
                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                const dist = getDistance(this, obj);
                if (dist < closestDist) {
                    closestDist = dist;
                    target = obj;
                }
            }
        }
        if (target) {
            // Jump onto target and trigger freeze
            this.x = target.x;
            this.y = target.y;
            gameObjects.push(new FreezeEffect(this.x, this.y, this.team, this.effectRadius, this.freezeDuration * 60));
            this.hasJumped = true;
            this.health = 0;
        } else {
            // Move like a normal troop
            if (!this.target || this.target.health <= 0) {
                this.target = this.findTarget(true);
            }
            if (this.target && this.target.health > 0) {
                this.move();
            }
        }
    }
}

        class BombSpirit extends Unit {
            constructor(x, y, team, level = 1) {
                const s = allCards['bombSpirit'].stats[level];
                super(x, y, 9, team, s.health, 1.5, 20, 10, 1, 'üí£', false, false, level, allCards['bombSpirit'].aggroRange);
                this.jumpRadius = s.jumpRadius;
                this.effectRadius = s.effectRadius;
                this.damage = s.damage;
                this.hasJumped = false;
            }
            update() {
                if (this.health <= 0 || this.hasJumped) return;
                let target = null;
                let closestDist = this.jumpRadius;
                for (const obj of gameObjects) {
                    if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                        // Skip invisible Phantom Knights
                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                        const dist = getDistance(this, obj);
                        if (dist < closestDist) {
                            closestDist = dist;
                            target = obj;
                        }
                    }
                }
                if (target) {
                    // Jump onto target and trigger explosion
                    this.x = target.x;
                    this.y = target.y;
                    // Damage all enemy things in effect radius
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                            // Don't skip invisible Phantom Knights here - spells/explosions can hit them
                            if (getDistance(this, obj) < this.effectRadius) {
                                applyDamage(obj, this.damage);
                            }
                        }
                    }
                    gameObjects.push(new ExplosionEffect(this.x, this.y, this.effectRadius));
                    this.hasJumped = true;
                    this.health = 0;
                } else {
                    if (!this.target || this.target.health <= 0) {
                        this.target = this.findTarget(true);
                    }
                    if (this.target && this.target.health > 0) {
                        this.move();
                    }
                }
            }
        }

        class ZapSpirit extends Unit {
            constructor(x, y, team, level = 1) {
                const s = allCards['zapSpirit'].stats[level];
                super(x, y, 9, team, s.health, 1.5, 20, 10, 1, '‚ö°', false, false, level, allCards['zapSpirit'].aggroRange);
                this.jumpRadius = s.jumpRadius;
                this.effectRadius = s.effectRadius;
                this.damage = s.damage;
                this.hasJumped = false;
                this.zapChain = null; // For drawing
            }
            update() {
                if (this.health <= 0 || this.hasJumped) return;
                let target = null;
                let closestDist = this.jumpRadius;
                for (const obj of gameObjects) {
                    if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                        // Skip invisible Phantom Knights
                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                        const dist = getDistance(this, obj);
                        if (dist < closestDist) {
                            closestDist = dist;
                            target = obj;
                        }
                    }
                }
                if (target) {
                    // Jump onto target and trigger zap chain
                    this.x = target.x;
                    this.y = target.y;
                    // Chain to up to 10 enemy things in effect radius
                    let chain = [target];
                    let visited = new Set([target]);
                    let current = target;
                    for (let i = 1; i < 10; i++) {
                        // Find next closest enemy not already zapped
                        let next = null;
                        let minDist = Infinity;
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower) && !visited.has(obj) && getDistance(current, obj) < this.effectRadius) {
                                // Skip invisible Phantom Knights
                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                let d = getDistance(current, obj);
                                if (d < minDist) {
                                    minDist = d;
                                    next = obj;
                                }
                            }
                        }
                        if (next) {
                            chain.push(next);
                            visited.add(next);
                            current = next;
                        } else {
                            break;
                        }
                    }
                    // Deal damage to all in chain
                    for (const obj of chain) {
                        applyDamage(obj, this.damage);
                        // Special: If obj is a king tower, activate it
                        if (obj instanceof Tower && obj.isKing && !obj.isActive) {
                            obj.isActive = true;
                            obj.activationAnimation = 30;
                        }
                    }
                    this.zapChain = chain;
                    this.hasJumped = true;
                    this.health = 0;
                } else {
                    if (!this.target || this.target.health <= 0) {
                        this.target = this.findTarget(true);
                    }
                    if (this.target && this.target.health > 0) {
                        this.move();
                    }
                }
            }
            draw() {
                super.draw();
                // Draw zap chain after death (handled in game loop for all ZapSpirits)
            }
        }

        class LifeSpirit extends Unit {
            constructor(x, y, team, level = 1) {
                const s = allCards['lifeSpirit'].stats[level];
                super(x, y, 9, team, s.health, 1.5, 20, 10, 1, 'üíö', false, false, level, allCards['lifeSpirit'].aggroRange);
                this.jumpRadius = s.jumpRadius;
                this.effectRadius = s.effectRadius;
                this.healDuration = s.healDuration;
                this.hasJumped = false;
            }
            update() {
                if (this.health <= 0 || this.hasJumped) return;
                let target = null;
                let closestDist = this.jumpRadius;
                for (const obj of gameObjects) {
                    if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                        // Skip invisible Phantom Knights
                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                        const dist = getDistance(this, obj);
                        if (dist < closestDist) {
                            closestDist = dist;
                            target = obj;
                        }
                    }
                }
                if (target) {
                    // Jump onto target and trigger heal (heal only allies)
                    this.x = target.x;
                    this.y = target.y;
                    gameObjects.push(new HealEffect(this.x, this.y, this.team, this.effectRadius, this.healDuration * 60));
                    this.hasJumped = true;
                    this.health = 0;
                } else {
                    if (!this.target || this.target.health <= 0) {
                        this.target = this.findTarget(true);
                    }
                    if (this.target && this.target.health > 0) {
                        this.move();
                    }
                }
            }
        }


            // --- SPEAR GOBLINS (NEW) ---
            class SpearGoblins { constructor(x, y, team, level = 1) { const s = allCards['spearGoblins'].stats[level]; for (let i = 0; i < s.count; i++) { gameObjects.push(new SpearGoblin(x + Math.random()*15-7, y + Math.random()*15-7, team, level)); } } }

            // --- MEGA SMASHER (ARENA 10) ---
            class MegaSmasher extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['megaSmasher'].stats[level];
                    super(x, y, 18, team, s.health, s.speed, 25, s.damage, s.hitSpeed, 'üí•', false, false, level, allCards['megaSmasher'].aggroRange);
                    this.spawnSplashRadius = s.spawnSplashRadius;
                    this.jumpDamage = s.jumpDamage;
                    this.jumpSplashRadius = s.jumpSplashRadius;
                    this.jumpRange = s.jumpRange;
                    this.jumpCooldown = s.jumpCooldown * 60;
                    
                    this.hasDealtSpawnDamage = false;
                    this.isChargingJump = false;
                    this.chargeTimer = 0;
                    this.isJumping = false;
                    this.jumpProgress = 0;
                    this.jumpStartX = x;
                    this.jumpStartY = y;
                    this.jumpTargetX = x;
                    this.jumpTargetY = y;
                    this.currentJumpCooldown = 0;
                    this.originalEmoji = 'üí•';
                    this.greyEmoji = 'üå´Ô∏è';
                    this.attackWidth = s.attackWidth;
                    this.attackHeight = s.attackHeight;
                    this.attackAnimationTimer = 0;
                    this.attackAngle = 0;
                    this.minJumpRange = s.minJumpRange; // Added min jump range
                    this.JUMP_DURATION_FRAMES = 20; // Frames for the actual jump animation
                    this.CHARGE_DURATION_FRAMES = 30; // Frames for pre-jump charge
                }
                
                // Mega Smasher's findTarget should be general, like other melee units
                findTarget(forceFindTower = false) {
                    let closestDist = this.aggroRange;
                    let bestTarget = null;
                    
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                            if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                            if (!this.targetsAir && obj.isFlying) continue; 
                            
                            const dist = getDistance(this, obj);
                            if (dist < closestDist) {
                                closestDist = dist;
                                bestTarget = obj;
                            }
                        }
                    }
                    
                    if (bestTarget) {
                        return bestTarget;
                    }
        
                    if (forceFindTower) {
                        let closestTowerDist = Infinity;
                        let towerTarget = null;
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Tower) && !obj.isKing) {
                                if ((this.x < WIDTH / 2 && obj.x < WIDTH / 2) || (this.x > WIDTH / 2 && obj.x > WIDTH / 2)) {
                                    const dist = getDistance(this, obj);
                                    if (dist < closestTowerDist) { 
                                        closestTowerDist = dist; 
                                        towerTarget = obj; 
                                    }
                                }
                            }
                        }
                        if (!towerTarget) {
                            for (const obj of gameObjects) {
                                if (obj.team !== this.team && (obj instanceof Tower) && obj.isKing) {
                                    const dist = getDistance(this, obj);
                                    if (dist < closestTowerDist) { 
                                        closestTowerDist = dist; 
                                        towerTarget = obj; 
                                    }
                                }
                            }
                        }
                        return towerTarget; 
                    }
                    
                    return null;
                }

                initiateJump(target) {
                    if (this.currentJumpCooldown > 0) return false; 
                    if (this.isChargingJump || this.isJumping) return false;

                    this.isChargingJump = true;
                    this.chargeTimer = this.CHARGE_DURATION_FRAMES; 
                    this.jumpTargetX = target.x;
                    this.jumpTargetY = target.y;
                    this.jumpStartX = this.x;
                    this.jumpStartY = this.y;
                    return true;
                }

                attack() {
                    if (this.cooldownTimer <= 0) {
                        this.attackAnimationTimer = 20; 
                        if (this.target) {
                            this.attackAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        } else {
                            this.attackAngle = this.team === 'player' ? -Math.PI / 2 : Math.PI / 2; 
                        }

                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                if (!obj.isFlying && isInside(obj, this.x, this.y, this.attackWidth, this.attackHeight, this.attackAngle)) {
                                    applyDamage(obj, this.attackDamage);
                                }
                            }
                        }
                        this.cooldownTimer = this.attackCooldown;
                    }
                }

                performJump() {
                    this.isChargingJump = false;
                    this.isJumping = true;
                    this.jumpProgress = 0;
                }
                
                endJump() {
                    // Apply splash damage on landing
                    gameObjects.push(new ExplosionEffect(this.x, this.y, this.jumpSplashRadius));
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                            if (getDistance(this, obj) < this.jumpSplashRadius) {
                                applyDamage(obj, this.jumpDamage);
                            }
                        }
                    }
                    this.currentJumpCooldown = this.jumpCooldown;
                    this.isJumping = false; 
                    this.target = null; // Clear target to force new target search after jump
                }

                update() {
                    if (this.health <= 0) return;

                    // Apply spawn damage once
                    if (!this.hasDealtSpawnDamage) {
                        gameObjects.push(new ExplosionEffect(this.x, this.y, this.spawnSplashRadius));
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                                if (getDistance(this, obj) < this.spawnSplashRadius) {
                                    applyDamage(obj, this.attackDamage); 
                                }
                            }
                        }
                        this.hasDealtSpawnDamage = true;
                    }

                    if (this.currentJumpCooldown > 0) { this.currentJumpCooldown -= deltaTime * 60; } 
                    if (this.cooldownTimer > 0) { this.cooldownTimer -= deltaTime * 60; } 
                    if (this.attackAnimationTimer > 0) { this.attackAnimationTimer--; } 

                    // Handle Charging Jump
                    if (this.isChargingJump) {
                        this.chargeTimer -= deltaTime * 60; 
                        if (this.chargeTimer <= 0) {
                            this.performJump(); 
                        }
                        return; 
                    }

                    // Handle Animated Jump
                    if (this.isJumping) {
                        this.jumpProgress += deltaTime * 60 / this.JUMP_DURATION_FRAMES;
                        if (this.jumpProgress >= 1) {
                            this.endJump(); 
                        } else {
                            const arcHeight = 40; 
                            this.x = this.jumpStartX + (this.jumpTargetX - this.jumpStartX) * this.jumpProgress;
                            this.y = this.jumpStartY + (this.jumpTargetY - this.jumpStartY) * this.jumpProgress - arcHeight * 4 * this.jumpProgress * (1 - this.jumpProgress);
                        }
                        return; 
                    }

                    // Normal AI Behavior (after jump, or if no jump is initiated)
                    // If current target is invalid, or if it's a tower and there's a closer troop/building
                    if (!this.target || this.target.health <= 0 || (this.target instanceof Tower && this.findTarget(false) !== null) ) {
                        this.target = this.findTarget(true); 
                    }

                    // Decision Logic if target exists
                    if (this.target && this.target.health > 0) {
                        const dist = getDistance(this, this.target);

                        // Try to jump if conditions met
                        if (dist > this.attackRange && dist <= this.jumpRange && dist >= this.minJumpRange && this.currentJumpCooldown <= 0) {
                            this.initiateJump(this.target);
                            return;
                        }

                        // Melee Attack
                        if (dist <= this.attackRange) {
                            this.attack();
                        } else {
                            // Movement
                            this.move();
                        }
                    }
                }

                draw() {
                    const color = this.team === 'player' ? '#60a5fa' : '#f87171';
                    let emojiToDraw = this.originalEmoji;
                    let chargingAlpha = 1;

                    if (this.isChargingJump) {
                        emojiToDraw = this.greyEmoji;
                        // Fade in effect for grey emoji
                        chargingAlpha = 0.3 + (1 - (this.chargeTimer / this.CHARGE_DURATION_FRAMES)) * 0.7; 
                    } else if (this.isJumping) {
                        emojiToDraw = this.originalEmoji;
                        chargingAlpha = 1; // Full opacity during jump
                    }
                    
                    ctx.save();
                    ctx.globalAlpha = chargingAlpha;
                    super.draw(color, emojiToDraw, this.level);
                    ctx.restore();

                    // Draw attack animation (melee attack)
                    if (this.attackAnimationTimer > 0) {
                        const progress = this.attackAnimationTimer / 20;
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.attackAngle);
                        ctx.fillStyle = `rgba(220, 38, 38, ${0.5 * (1 - progress)})`;
                        ctx.fillRect(this.radius, -this.attackWidth / 2, this.attackHeight, this.attackWidth);
                        ctx.restore();
                    }
                }
            }

            // --- ARENA 10 NEW CLASSES ---
            class FlameDragon extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['flameDragon'].stats[level];
                    super(x, y, 12, team, s.health, s.speed, 120, s.damage, s.hitSpeed, 'üê≤üî•', true, true, level, allCards['flameDragon'].aggroRange);
                    this.rampMultiplier = s.rampMultiplier;
                    this.rampLevel = 0;
                    this.lastTarget = null;
                    this.maxDamage = s.maxDamage;
                }
                update() {
                    super.update();
                    if (!this.target || this.target.health <= 0 || getDistance(this, this.target) > this.attackRange) {
                        this.rampLevel = 0;
                        this.lastTarget = null;
                    }
                }
                attack() {
                    if (this.target && this.cooldownTimer <= 0) {
                        if (this.target !== this.lastTarget) {
                            this.rampLevel = 0;
                            this.lastTarget = this.target;
                        }
                        const rampMult = Math.pow(this.rampMultiplier, Math.min(8, this.rampLevel));
                        let damage = Math.floor(this.attackDamage * rampMult);
                        damage = Math.min(damage, this.maxDamage);
                        applyDamage(this.target, damage);
                        this.rampLevel++;
                        this.cooldownTimer = this.attackCooldown;
                    }
                }
                draw() {
                    super.draw();
                    if (this.target && this.target.health > 0 && getDistance(this, this.target) <= this.attackRange + 10) {
                        ctx.save();
                        ctx.strokeStyle = '#f97316';
                        ctx.lineWidth = 2 + Math.min(6, this.rampLevel);
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.target.x, this.target.y);
                        ctx.stroke();
                        ctx.strokeStyle = '#fef08a';
                        ctx.lineWidth = (2 + Math.min(6, this.rampLevel)) / 2;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(this.target.x, this.target.y);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }

            class FlameTower extends Building {
                constructor(x, y, team, level = 1) {
                    super(x, y, team, level, 'flameTower');
                    const s = allCards['flameTower'].stats[level];
                    this.rampMultiplier = s.rampMultiplier;
                    this.attackDamage = s.damage;
                    this.attackRange = 140;
                    this.attackCooldown = s.hitSpeed * 60;
                    this.cooldownTimer = 0;
                    this.rampLevel = 0;
                    this.lastTarget = null;
                    this.target = null;
                    this.maxDamage = s.maxDamage;
                }
                // Custom update to handle targeting like a tower
                update() {
                    super.update();
                    if (this.health <= 0) return;
                    
                    // Find Target
                    if (!this.target || this.target.health <= 0 || getDistance(this, this.target) > this.attackRange) {
                        this.target = null;
                        this.rampLevel = 0;
                        this.lastTarget = null;
                        let closestDist = this.attackRange;
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit)) {
                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                const dist = getDistance(this, obj);
                                if (dist < closestDist) {
                                    closestDist = dist;
                                    this.target = obj;
                                }
                            }
                        }
                    }

                    if (this.cooldownTimer > 0) this.cooldownTimer -= deltaTime * 60;
                    
                    if (this.target && this.cooldownTimer <= 0) {
                        if (this.target !== this.lastTarget) {
                            this.rampLevel = 0;
                            this.lastTarget = this.target;
                        }
                        const rampMult = Math.pow(this.rampMultiplier, Math.min(8, this.rampLevel));
                        const damage = Math.floor(this.attackDamage * rampMult);
                        applyDamage(this.target, damage);
                        this.rampLevel++;
                        this.cooldownTimer = this.attackCooldown;
                    }
                }
                draw() {
                    super.draw();
                    if (this.target && this.target.health > 0) {
                         ctx.save();
                         ctx.strokeStyle = '#ef4444';
                         ctx.lineWidth = 3 + Math.min(6, this.rampLevel);
                         ctx.beginPath();
                         ctx.moveTo(this.x, this.y - 20);
                         ctx.lineTo(this.target.x, this.target.y);
                         ctx.stroke();
                         ctx.strokeStyle = '#fca5a5';
                         ctx.lineWidth = 1;
                         ctx.stroke();
                         ctx.restore();
                    }
                }
            }

            class Bot extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['bot'].stats[level];
                    super(x, y, 16, team, s.health, s.speed, 25, s.damage, s.hitSpeed, 'ü§ñ', false, false, level, allCards['bot'].aggroRange);
                }
            }

            // --- ZAP GIANT (ARENA 10) ---
            class ZapGiant extends Giant {
                constructor(x, y, team, level = 1) {
                    const s = allCards['zapGiant'].stats[level];
                    super(x, y, team, level);
                    // Override Giant stats with ZapGiant stats
                    this.radius = 18;
                    this.health = s.health;
                    this.maxHealth = s.health;
                    this.speed = s.speed;
                    this.attackDamage = s.damage;
                    this.attackCooldown = s.hitSpeed * 60;
                    this.emoji = '‚ö°üí™';

                    this.zapDamage = s.zapDamage;
                    this.zapRadius = s.zapRadius;
                    this.zapInterval = s.zapInterval * 60;
                    this.zapTimer = 0;
                    this.spawnDamage = s.spawnDamage;
                    this.spawnRadius = s.spawnRadius;
                    this.hasDealtSpawnDamage = false;
                    this.zapChain = null; // For drawing
                }

                update() {
                    super.update(); // Call Giant's update for movement/attack/targeting buildings

                    if (this.health <= 0) return; // Don't do anything if dead

                    // Apply spawn damage once
                    if (!this.hasDealtSpawnDamage) {
                        gameObjects.push(new ExplosionEffect(this.x, this.y, this.spawnRadius));
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                                if (getDistance(this, obj) < this.spawnRadius) {
                                    applyDamage(obj, this.spawnDamage);
                                }
                            }
                        }
                        this.hasDealtSpawnDamage = true;
                    }

                    // Zap field logic
                    this.zapTimer -= deltaTime * 60; /* Scale zap timer by delta time */
                    if (this.zapTimer <= 0) {
                        this.zapTimer = this.zapInterval; // Reset timer
                        
                        // Find targets for zap chain
                        let mainTarget = null;
                        let closestDist = this.zapRadius;
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                                if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                const dist = getDistance(this, obj);
                                if (dist < closestDist) {
                                    closestDist = dist;
                                    mainTarget = obj;
                                }
                            }
                        }

                        if (mainTarget) {
                            let chain = [mainTarget];
                            let visited = new Set([mainTarget]);
                            let current = mainTarget;
                            for (let i = 1; i < 5; i++) { // Chain to up to 5 targets
                                let next = null;
                                let minDist = Infinity;
                                for (const obj of gameObjects) {
                                    if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower) && !visited.has(obj) && getDistance(current, obj) < this.zapRadius) {
                                        if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                        let d = getDistance(current, obj);
                                        if (d < minDist) {
                                            minDist = d;
                                            next = obj;
                                        }
                                    }
                                }
                                if (next) {
                                    chain.push(next);
                                    visited.add(next);
                                    current = next;
                                } else {
                                    break;
                                }
                            }
                            // Deal damage to all in chain
                            for (const obj of chain) {
                                applyDamage(obj, this.zapDamage);
                            }
                            this.zapChain = chain; // Store for drawing
                        } else {
                            this.zapChain = null; // No targets, no chain
                        }
                    }
                }

                draw() {
                    super.draw(); // Draw Giant body and health bar

                    // Draw electric field aura (subtle pulsing)
                    const pulseAlpha = 0.2 + Math.sin(performance.now() * 0.005) * 0.1; // Pulse between 0.1 and 0.3
                    ctx.save();
                    ctx.fillStyle = `rgba(100, 150, 255, ${pulseAlpha})`; // Light blue electric color
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.zapRadius + Math.sin(performance.now() * 0.01) * 5, 0, Math.PI * 2); // Subtle size pulse, based on zapRadius
                    ctx.fill();
                    ctx.restore();

                    // Draw zap chains after all objects (handled in main game loop for all ZapSpirit-like units)
                }
            }

            // --- ARENA 8 CARD CLASSES (NEW) ---
            class ChaosElemental extends Unit { 
                constructor(x, y, team, level = 1) { 
                    const s = allCards['chaosElemental'].stats[level]; 
                    super(x, y, 12, team, s.health, 1.2, 25, s.damage, s.hitSpeed, 'üëπ', false, false, level, allCards['chaosElemental'].aggroRange); 
                } 
            }
            class ShadowClone extends Unit { 
                constructor(x, y, team, level = 1) { 
                    const s = allCards['shadowClone'].stats[level]; 
                    super(x, y, 10, team, s.health, 1.2, 120, s.damage, s.hitSpeed, 'üë§', false, true, level, allCards['shadowClone'].aggroRange); 
                } 
            }
            class HugeSkeleton extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['hugeSkeleton'].stats[level];
                    super(x, y, 18, team, s.health, s.speed, 25, s.damage, s.hitSpeed, 'üíÄüí£', false, false, level, allCards['hugeSkeleton'].aggroRange);
                    this.bombDamage = s.bombDamage;
                    this.droppedBomb = false;
                }
            }

            class GiantBomb extends GameObject {
                constructor(x, y, team, damage, radius = 40) { /* Increased default radius */
                    super(x, y, radius, team, 1);
                    this.damage = damage;
                    this.timer = 180; // 3 seconds
                    this.maxTimer = 180;
                }
                update() {
                    this.timer -= deltaTime * 60; /* Scale timer by delta time */
                    if (this.timer <= 0) {
                        // Explode
                        gameObjects.push(new ParticleExplosion(this.x, this.y, '#ef4444'));
                        // Damage enemies
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (getDistance(this, obj) < this.radius) {
                                    applyDamage(obj, this.damage);
                                }
                            }
                        }
                        this.health = 0;
                    }
                }
                draw() {
                    // Pulse animation
                    const scale = 1 + Math.sin(this.timer * 0.2) * 0.1;
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.scale(scale, scale);
                    ctx.font = '40px Arial'; /* Increased emoji size */
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üí£', 0, 0);
                    // Draw Timer Bar
                    ctx.fillStyle = 'red';
                    ctx.fillRect(-15, -20, 30 * (this.timer / this.maxTimer), 4);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-15, -20, 30, 4);
                    ctx.restore();
                }
            }

            class Ninja extends Unit {
                constructor(x, y, team, level = 1) {
                    const s = allCards['ninja'].stats[level];
                    super(x, y, 10, team, s.health, s.speed, 20, s.damage, s.hitSpeed, 'ü•∑', false, false, level, allCards['ninja'].aggroRange);
                }
            }
class StoneGiant extends Unit {
    constructor(x, y, team, level = 1) {
        const s = allCards['stoneGiant'].stats[level];
        super(
            x,
            y,
            18,
            team,
            s.health,
            s.speed * 0.5,
            30,
            s.damage,
            s.hitSpeed,
            'üóø',
            false,
            false,
            level,
            allCards['stoneGiant'].aggroRange
        );
        this.targetLocked = false;
        this.level = level;
        this.didSpawnMinis = false; // prevent double‚Äëspawn
    }

    spawnMinis() {
        if (this.didSpawnMinis) return;
        this.didSpawnMinis = true;

        try {
            const card = allCards['miniStoneGiant'];
            if (card && card.stats) {
                const stats =
                    card.stats[this.level] || card.stats[1];

                const leftMini = new MiniStoneGiant(
                    this.x - 15,
                    this.y,
                    this.team,
                    this.level
                );
                const rightMini = new MiniStoneGiant(
                    this.x + 15,
                    this.y,
                    this.team,
                    this.level
                );

                gameObjects.push(leftMini, rightMini);
                console.log(
                    'StoneGiant spawned minis:',
                    leftMini,
                    rightMini
                );
            }
        } catch (e) {
            console.error('Error spawning mini stone giants:', e);
        }
    }

    findTarget() {
        let closestTowerDist = Infinity;
        let towerTarget = null;
        for (const obj of gameObjects) {
            if (
                obj.team !== this.team &&
                obj instanceof Tower &&
                !obj.isKing
            ) {
                if (
                    (this.x < WIDTH / 2 && obj.x < WIDTH / 2) ||
                    (this.x > WIDTH / 2 && obj.x > WIDTH / 2)
                ) {
                    const dist = getDistance(this, obj);
                    if (dist < closestTowerDist) {
                        closestTowerDist = dist;
                        towerTarget = obj;
                    }
                }
            }
        }
        if (!towerTarget) {
            for (const obj of gameObjects) {
                if (
                    obj.team !== this.team &&
                    obj instanceof Tower &&
                    obj.isKing
                ) {
                    const dist = getDistance(this, obj);
                    if (dist < closestTowerDist) {
                        closestTowerDist = dist;
                        towerTarget = obj;
                    }
                }
            }
        }
        this.target = towerTarget;
        this.targetLocked = this.target != null;
    }

    update() {
        // IMPORTANT: no spawning here, only handled in cleanup
        if (this.health <= 0) return;

        if (this.cooldownTimer > 0) {
            this.cooldownTimer--;
        }
        if (
            this.target &&
            this.target.health > 0 &&
            getDistance(this, this.target) <= this.attackRange
        ) {
            this.attack();
            return;
        }
        if (
            !this.target ||
            this.target.health <= 0 ||
            this.target instanceof Tower
        ) {
            this.findTarget();
        }
        if (this.target && this.target.health > 0) {
            if (getDistance(this, this.target) <= this.attackRange) {
                this.attack();
            } else {
                this.move();
            }
        }
    }
}

 class MiniStoneGiant extends Unit {
    constructor(x, y, team, level = 1) {
        const card = allCards['miniStoneGiant'];
        const baseStats =
            card && card.stats
                ? card.stats[level] || card.stats[1]
                : null;
        const s =
            baseStats || {
                health: 200,
                damage: 20,
                hitSpeed: 1.3,
                speed: 0.7
            };
        const emoji = card && card.emoji ? card.emoji : 'ü™®';
        const aggro =
            card && card.aggroRange ? card.aggroRange : 100;

        super(
            x,
            y,
            15,
            team,
            s.health,
            s.speed,
            25,
            s.damage,
            s.hitSpeed,
            emoji,
            false,
            false,
            level,
            aggro
        );
        this.level = level;
    }

    findTarget() {
        let closestTowerDist = Infinity;
        let towerTarget = null;
        for (const obj of gameObjects) {
            if (
                obj.team !== this.team &&
                obj instanceof Tower &&
                !obj.isKing
            ) {
                if (
                    (this.x < WIDTH / 2 && obj.x < WIDTH / 2) ||
                    (this.x > WIDTH / 2 && obj.x > WIDTH / 2)
                ) {
                    const dist = getDistance(this, obj);
                    if (dist < closestTowerDist) {
                        closestTowerDist = dist;
                        towerTarget = obj;
                    }
                }
            }
        }
        if (!towerTarget) {
            for (const obj of gameObjects) {
                if (
                    obj.team !== this.team &&
                    obj instanceof Tower &&
                    obj.isKing
                ) {
                    const dist = getDistance(this, obj);
                    if (dist < closestTowerDist) {
                        closestTowerDist = dist;
                        towerTarget = obj;
                    }
                }
            }
        }
        this.target = towerTarget;
    }

    // let Unit.update / Unit.draw handle behavior
}

            class Projectile extends GameObject {
                constructor(x, y, target, team, damage, splashRadius = 0) { 
                    super(x, y, 4, team, 1); 
                    this.target = target; 
                    this.damage = damage; 
                    this.speed = 5; 
                    this.splashRadius = splashRadius;
                }
                update() { 
                    if (!this.target || this.target.health <= 0) { this.health = 0; return; }
                    if (this.target instanceof PhantomKnight && this.target.isInvisible) { this.health = 0; return; }
                    const dist = getDistance(this, this.target); 
                    if (dist < this.speed) { 
                        // Hit target
                        applyDamage(this.target, this.damage); 
                        
                        // Handle splash
                        if (this.splashRadius > 0) {
                            for (const obj of gameObjects) {
                                if (obj.team !== this.team && obj !== this.target && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                    if (obj instanceof PhantomKnight && obj.isInvisible) continue;
                                    if (getDistance(this.target, obj) < this.splashRadius) {
                                        applyDamage(obj, this.damage); // Splash does full damage
                                    }
                                }
                            }
                            // Spawn Explosion Visual
                            gameObjects.push(new ParticleExplosion(this.x, this.y, '#ff5722'));
                        }
                        
                        this.health = 0; 
                        return; 
                    } 
                    const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); 
                    this.x += Math.cos(angle) * this.speed * (deltaTime * 60); /* Scale movement by delta time */
                    this.y += Math.sin(angle) * this.speed * (deltaTime * 60);
                }
                draw() { 
                    ctx.beginPath(); 
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); 
                    ctx.fillStyle = this.team === 'player' ? '#a5f3fc' : '#fecaca'; 
                    ctx.fill(); 
                }
            }

            class FireballProjectile extends Projectile {
                constructor(x, y, target, team, damage, splashRadius = 0) {
                    super(x, y, target, team, damage, splashRadius);
                    this.radius = 6;
                }
                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.team === 'player' ? '#ffc107' : '#ff6f00';
                    ctx.fill();
                }
            }

            // SnowmanKing extends Tower so that Building-targeters (Giants, etc) will target it automatically.
            class SnowmanKing extends Tower {
                constructor(x, y, team) {
                    super(x, y, team, true, 1); // isKing = true
                    this.health = 4000;
                    this.maxHealth = 4000;
                    this.speed = 1.0; 
                    this.radius = 20;
                    this.attackDamage = 0;
                    // Random Movement Props
                    this.targetX = x;
                    this.targetY = y;
                    this.pauseTimer = 0;
                    this.pickNewTarget();
                }
                
                pickNewTarget() {
                    const margin = 40;
                    let minY, maxY;
                    // Use scoped constants WIDTH, HEIGHT, RIVER_Y
                    if (this.team === 'player') {
                        minY = RIVER_Y + margin;
                        maxY = HEIGHT - margin;
                    } else {
                        minY = margin;
                        maxY = RIVER_Y - margin;
                    }
                    const minX = margin;
                    const maxX = WIDTH - margin;
                    
                    this.targetX = minX + Math.random() * (maxX - minX);
                    this.targetY = minY + Math.random() * (maxY - minY);
                }

                update() {
                    if (this.health <= 0) return;
                    if (this.dyingAnimationTimer > 0) this.dyingAnimationTimer--;

                    // Handle Pause
                    if (this.pauseTimer > 0) {
                        this.pauseTimer -= deltaTime * 60; /* Scale pause timer by delta time */
                        return;
                    }

                    // Calculate movement
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < 5) {
                        // Reached target -> Pause then pick new target
                        this.pauseTimer = 60 + Math.random() * 60; // Pause 1-2s
                        this.pickNewTarget();
                    } else {
                        // Move towards target
                    this.x += (dx / dist) * this.speed * (deltaTime * 60); /* Scale movement by delta time */
                    this.y += (dy / dist) * this.speed * (deltaTime * 60);
                    }
                }
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.beginPath();
                    ctx.ellipse(0, this.radius * 0.4, this.radius, this.radius * 0.4, 0, 0, Math.PI*2);
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    ctx.fill();
                    ctx.font = '40px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'white';
                    ctx.shadowBlur = 10;
                    ctx.fillText('‚òÉÔ∏è', 0, 0);
                    ctx.restore();
                    this.drawHealthBar();
                }
            }

            // --- EFFECT CLASSES (NEW) ---
            class FreezeEffect extends GameObject {
                constructor(x, y, team, radius, duration) {
                    super(x, y, radius, team, 1);
                    this.duration = duration;
                    this.lifetime = duration;
                    this.frozenObjects = new Map(); // Store original values
                }
                update() {
                    this.lifetime -= deltaTime * 60; /* Scale lifetime by delta time */
                    if (this.lifetime <= 0) {
                        // Restore frozen objects
                        this.frozenObjects.forEach((originalSpeed, obj) => {
                            if (obj && obj.frozen) {
                                obj.speed = originalSpeed;
                                obj.frozen = false;
                                if (obj.frozenCooldown !== undefined) {
                                    obj.cooldownTimer = obj.frozenCooldown;
                                }
                            }
                        });
                        this.health = 0;
                        return;
                    }
                    for (const obj of gameObjects) {
                        if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                            if (getDistance(this, obj) < this.radius) {
                                if (!obj.frozen) {
                                    obj.frozen = true;
                                    this.frozenObjects.set(obj, obj.speed);
                                    obj.speed = 0;
                                    if (obj.cooldownTimer !== undefined) {
                                        obj.frozenCooldown = obj.cooldownTimer;
                                        obj.cooldownTimer = this.lifetime;
                                    }
                                }
                            } else if (obj.frozen && this.frozenObjects.has(obj)) {
                                // Left the area, restore
                                obj.speed = this.frozenObjects.get(obj);
                                obj.frozen = false;
                                if (obj.frozenCooldown !== undefined) {
                                    obj.cooldownTimer = obj.frozenCooldown;
                                }
                                this.frozenObjects.delete(obj);
                            }
                        }
                    }
                }
                draw() {
                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.3;
                    ctx.fillStyle = `rgba(147, 197, 253, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            class HealEffect extends GameObject {
                constructor(x, y, team, radius, duration) {
                    super(x, y, radius, team, 1);
                    this.duration = duration;
                    this.lifetime = duration;
                    this.healTick = 30; // Heal every 0.5 seconds
                    this.tickTimer = this.healTick;
                    this.healAmount = 20;
                }
                update() {
                    this.lifetime -= deltaTime * 60; /* Scale lifetime by delta time */
                    if (this.lifetime <= 0) {
                        this.health = 0;
                        return;
                    }
                    this.tickTimer -= deltaTime * 60; /* Scale tick timer by delta time */
                    if (this.tickTimer <= 0) {
                        this.tickTimer = this.healTick;
                        for (const obj of gameObjects) {
                            if (obj.team === this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                                if (getDistance(this, obj) < this.radius && obj.health < obj.maxHealth) {
                                    obj.health = Math.min(obj.maxHealth, obj.health + this.healAmount);
                                }
                            }
                        }
                    }
                }
                draw() {
                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.3;
                    ctx.fillStyle = `rgba(34, 197, 94, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            class ExplosionEffect extends GameObject {
                constructor(x, y, radius) {
                    super(x, y, radius, 'neutral', 1);
                    this.animationTimer = 20;
                }
                update() {
                    this.animationTimer--;
                    if (this.animationTimer <= 0) {
                        this.health = 0;
                    }
                }
                draw() {
                    const progress = this.animationTimer / 20;
                    ctx.fillStyle = `rgba(239, 68, 68, ${0.8 * (1 - progress)})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * (1 - progress), 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            class AngerSpell extends GameObject {
                constructor(x, y, team, radius, duration, spawnDamage) {
                    super(x, y, radius, team, 1);
                    this.duration = duration * 60;
                    this.lifetime = this.duration;
                    this.angeredUnits = new Set();
                    this.spawnDamage = spawnDamage || 150; // High range damage on spawn
                    this.hasDealtDamage = false;
                }
                update() {
                    this.lifetime--;
                    // Spawn Damage (One-time)
                    if (!this.hasDealtDamage) {
                        this.hasDealtDamage = true;
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                                if (getDistance(this, obj) < this.radius) {
                                    applyDamage(obj, this.spawnDamage);
                                }
                            }
                        }
                        gameObjects.push(new ExplosionEffect(this.x, this.y, this.radius));
                    }
                    if (this.lifetime <= 0) {
                        // Spell expired: all buffed units/buildings/towers immediately lose Anger.
                        this.angeredUnits.forEach(unit => {
                            if (unit && unit.isAngered) {
                                if (unit.originalDamage !== undefined) {
                                    unit.attackDamage = unit.originalDamage;
                                }
                                if (unit.originalCooldown !== undefined) {
                                    unit.attackCooldown = unit.originalCooldown;
                                }
                                unit.isAngered = false;
                                unit.angeredTimer = null;
                            }
                        });
                        this.angeredUnits.clear();
                        this.health = 0;
                        return;
                    }
                    // Pass 1: apply Anger to units in the pool and start trailing timers when they leave.
                    for (const obj of gameObjects) {
                        if (obj.team === this.team && (obj instanceof Unit || obj instanceof Building || obj instanceof Tower)) {
                            const inPool = getDistance(this, obj) < this.radius;
                            if (inPool) {
                                if (!obj.isAngered) {
                                    obj.isAngered = true;
                                    if (obj.attackDamage !== undefined) {
                                        obj.originalDamage = obj.attackDamage;
                                        obj.attackDamage = Math.floor(obj.attackDamage * 1.25); // 1.25x Damage
                                    }
                                    if (obj.attackCooldown !== undefined) {
                                        obj.originalCooldown = obj.attackCooldown;
                                        obj.attackCooldown = Math.floor(obj.attackCooldown / 1.5); // 1.5x Speed
                                    }
                                    this.angeredUnits.add(obj);
                                }
                                // While inside the pool, no trailing timer is counting down.
                                obj.angeredTimer = null;
                            } else if (obj.isAngered && this.angeredUnits.has(obj)) {
                                // Left the pool while the spell is still active: start 2s trailing buff.
                                if (obj.angeredTimer === null || obj.angeredTimer <= 0) {
                                    obj.angeredTimer = 2 * 60;
                                }
                            }
                        }
                    }

                    // Pass 2: tick down trailing timers for angered units that have left the pool.
                    this.angeredUnits.forEach(unit => {
                        if (!unit || !unit.isAngered) {
                            return;
                        }
                        if (unit.angeredTimer !== null && unit.angeredTimer > 0) {
                            unit.angeredTimer -= deltaTime * 60; /* Scale angered timer by delta time */
                            if (unit.angeredTimer <= 0) {
                                if (unit.originalDamage !== undefined) {
                                    unit.attackDamage = unit.originalDamage;
                                }
                                if (unit.originalCooldown !== undefined) {
                                    unit.attackCooldown = unit.originalCooldown;
                                }
                                unit.isAngered = false;
                                unit.angeredTimer = null;
                            }
                        }
                    });
                }
                draw() {
                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.4;
                    ctx.fillStyle = `rgba(147, 51, 234, ${alpha})`; // purple-700
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            class VoidTrapEffect extends GameObject {
                constructor(x, y, team, radius, damage) {
                    super(x, y, radius, team, 1);
                    this.damage = damage;
                    this.animationTimer = 30;
                    this.maxAnimationTimer = 30;
                    this.hit = false;
                    this.hitObjects = new Set();
                }
                update() {
                    if (!this.hit) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && !this.hitObjects.has(obj) && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (getDistance(this, obj) < this.radius) {
                                    applyDamage(obj, this.damage);
                                    this.hitObjects.add(obj);
                                }
                            }
                        }
                        this.hit = true;
                    }
                    this.animationTimer--;
                    if (this.animationTimer <= 0) {
                        this.health = 0;
                    }
                }
                draw() {
                    const progress = this.animationTimer / this.maxAnimationTimer;
                    const alpha = (0.5 - Math.abs(progress - 0.5)) * 2;
                    ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * (1 - progress * 0.3), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = `rgba(147, 51, 234, ${alpha})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.font = `${this.radius * 0.8}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.globalAlpha = alpha;
                    ctx.fillText('‚ö´', this.x, this.y);
                    ctx.globalAlpha = 1;
                }
            }

            class ChaosOrbEffect extends GameObject {
                constructor(x, y, team, radius, damage) {
                    super(x, y, radius, team, 1);
                    this.damage = damage;
                    this.animationTimer = 30;
                    this.maxAnimationTimer = 30;
                    this.hit = false;
                    this.hitObjects = new Set();
                }
                update() {
                    if (!this.hit) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && !this.hitObjects.has(obj) && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (getDistance(this, obj) < this.radius) {
                                    applyDamage(obj, this.damage);
                                    this.hitObjects.add(obj);
                                }
                            }
                        }
                        this.hit = true;
                    }
                    this.animationTimer--;
                    if (this.animationTimer <= 0) {
                        this.health = 0;
                    }
                }
                draw() {
                    const progress = this.animationTimer / this.maxAnimationTimer;
                    const alpha = (0.5 - Math.abs(progress - 0.5)) * 2;
                    ctx.fillStyle = `rgba(200, 100, 255, ${alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * (1 + progress * 0.2), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.font = `${this.radius}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.globalAlpha = alpha;
                    ctx.fillText('üåÄ', this.x, this.y);
                    ctx.globalAlpha = 1;
                }
            }
            
            class SkeletonYard extends GameObject {
                constructor(x, y, team, duration, radius, level) {
                    super(x, y, radius, team, 1);
                    this.duration = duration * 60;
                    this.lifetime = this.duration;
                    this.spawnRate = 30; // 0.5s * 60
                    this.spawnTimer = 0;
                    this.radius = radius;
                    this.level = level;
                }
                update() {
                    this.lifetime -= deltaTime * 60; /* Scale lifetime by delta time */
                    if (this.lifetime <= 0) { this.health = 0; return; }
                    
                    this.spawnTimer -= deltaTime * 60; /* Scale spawn timer by delta time */
                    if (this.spawnTimer <= 0) {
                        this.spawnTimer = this.spawnRate;
                        // Spawn Skeleton at random pos within radius
                        const r = this.radius * Math.sqrt(Math.random());
                        const theta = Math.random() * 2 * Math.PI;
                        const sx = this.x + r * Math.cos(theta);
                        const sy = this.y + r * Math.sin(theta);
                        
                        const clampedX = Math.max(10, Math.min(400-10, sx));
                        const clampedY = Math.max(10, Math.min(500-10, sy));
                        
                        gameObjects.push(new Skeleton(clampedX, clampedY, this.team, this.level));
                    }
                }
                draw() {
                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.3;
                    ctx.fillStyle = `rgba(100, 116, 139, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                    ctx.fill();
                    if (this.lifetime % 60 < 30) {
                        ctx.fillStyle = `rgba(255,255,255, ${alpha})`;
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ü¶¥', this.x, this.y);
                    }
                }
            }

            class Spell extends GameObject {
                constructor(x, y, team, damage, radius, emoji) {
                    super(x, y, radius, team, 1);
                    this.damage = damage;
                    this.animationTimer = 30;
                    this.maxAnimationTimer = 30;
                    this.hit = false;
                    this.emoji = emoji;
                }
                update() {
                    if (!this.hit) {
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (getDistance(this, obj) < this.radius) {
                                    applyDamage(obj, this.damage);
                                }
                            }
                        }
                        this.hit = true;
                    }
                    this.animationTimer--;
                    if (this.animationTimer <= 0) {
                        this.health = 0;
                    }
                }
                draw() {
                    const progress = this.animationTimer / this.maxAnimationTimer;
                    const alpha = (0.5 - Math.abs(progress - 0.5)) * 2;
                    if (this.emoji === 'üéØ') {
                        ctx.fillStyle = `rgba(139, 69, 19, ${alpha * 0.2})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = `20px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = `rgba(101, 67, 33, ${alpha})`;
                        let yOffset = -this.radius + (this.radius * 2 * (1 - progress));
                        ctx.globalAlpha = alpha;
                        ctx.fillText('‚¨áÔ∏è', this.x - 20, this.y - 20 + yOffset);
                        ctx.fillText('‚¨áÔ∏è', this.x + 20, this.y - 10 + yOffset);
                        ctx.fillText('‚¨áÔ∏è', this.x, this.y + 20 + yOffset);
                        ctx.globalAlpha = 1;
                    } else if (this.emoji === 'üî•') {
                        ctx.fillStyle = `rgba(253, 224, 71, ${alpha * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius * (1 - progress), 0, Math.PI * 2);
                        ctx.fill();
                        ctx.font = `${this.radius * 2}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.globalAlpha = alpha;
                        ctx.fillText(this.emoji, this.x, this.y);
                        ctx.globalAlpha = 1;
                    }
                }
            }
            
            // NEW: Poison Spell Class
            class PoisonSpell extends GameObject {
                constructor(x, y, team, damagePerSecond, radius, duration) {
                    super(x, y, radius, team, 1);
                    this.damagePerSecond = damagePerSecond;
                    this.duration = duration * 60; // 5 seconds
                    this.lifetime = this.duration;
                    this.damageTick = 60; // Damage every 1 second
                    this.tickTimer = this.damageTick;
                }
                update() {
                    this.lifetime -= deltaTime * 60; /* Scale lifetime by delta time */
                    if (this.lifetime <= 0) {
                        this.health = 0;
                        return;
                    }
                    this.tickTimer -= deltaTime * 60; /* Scale tick timer by delta time */
                    if (this.tickTimer <= 0) {
                        this.tickTimer = this.damageTick;
                        for (const obj of gameObjects) {
                            if (obj.team !== this.team && (obj instanceof Unit || obj instanceof Tower || obj instanceof Building)) {
                                if (getDistance(this, obj) < this.radius) {
                                    applyDamage(obj, this.damagePerSecond);
                                }
                            }
                        }
                    }
                }
                draw() {
                    const alpha = Math.sin((this.lifetime / this.duration) * Math.PI) * 0.3; // Fades in and out
                    ctx.fillStyle = `rgba(234, 179, 8, ${alpha})`; // yellow-500
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }


            // ==============================================
            // GAME LOGIC (FUNCTIONS)
            // MOVED UP TO FIX DEMO MODE
            // ==============================================

            // --- FIX: Moved initCardSystem to be the FIRST function defined ---
            function initCardSystem() {
                allCards = {
                    // Arena 1
                    'knight': { name: 'Knight', cost: 3, emoji: '‚öîÔ∏è', type: 'Melee', unitClass: Knight, placementRadius: 12, isFlying: false, arena: 1, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 500, damage: 65, hitSpeed: 1.2, speed: 0.9 } } },
                    'archer': { name: 'Archer', cost: 4, emoji: 'üèπ', type: 'Ranged', unitClass: Archer, placementRadius: 10, isFlying: false, arena: 1, targets: 'Air & Ground', aggroRange: 120,
                                stats: { 1: { health: 250, damage: 40, hitSpeed: 1, speed: 0.9 } } },
                    'giant': { name: 'Giant', cost: 5, emoji: 'üí™', type: 'Tank', unitClass: Giant, placementRadius: 18, isFlying: false, arena: 1, targets: 'Buildings', aggroRange: 100,
                                stats: { 1: { health: 1000, damage: 60, hitSpeed: 1.5, speed: 0.5 } } },
                    'goblins': { name: 'Goblins', cost: 2, emoji: 'üë∫', type: 'Swarm', unitClass: Goblins, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { count: 3, health: 100, damage: 20, hitSpeed: 1, speed: 1.0 } } },
                    'skeletons': { name: 'Skeletons', cost: 1, emoji: 'üíÄ', type: 'Swarm', unitClass: Skeletons, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { count: 3, health: 10, damage: 5, hitSpeed: 1.2, speed: 1.2 } } },
                    'tinyBot': { name: 'Tiny Bot', cost: 4, emoji: 'ü§ñ', type: 'Melee', unitClass: TinyBot, placementRadius: 10, isFlying: false, arena: 1, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 700, damage: 250, hitSpeed: 1.8, speed: 0.7 } } },
                    'fireball': { name: 'Fireball', cost: 4, emoji: 'üî•', type: 'Spell', radius: 50, placementRadius: 50, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { damage: 250 } } },
                    'arrows': { name: 'Arrows', cost: 3, emoji: 'üéØ', type: 'Spell', radius: 80, placementRadius: 80, arena: 1, targets: 'Air & Ground',
                                stats: { 1: { damage: 140 } } },
                    // Arena 2
                    'hut': { name: 'Goblin House', cost: 5, emoji: 'üè†', type: 'Building', unitClass: GoblinHut, placementRadius: 20, isFlying: false, arena: 2, targets: '-',
                                stats: { 1: { health: 800, spawn_speed: '5s', lifetime: '30s' } } },
                    'skeletonArmy': { name: 'Skeleton Group', cost: 3, emoji: '‚ò†Ô∏è', type: 'Swarm', unitClass: SkeletonArmy, placementRadius: 10, isFlying: false, arena: 2, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { count: 15, health: 10, damage: 5, hitSpeed: 1.2, speed: 1.4 } } }, // Speed 1.6 -> 1.4, damage buffed to 5
                    'goblinGang': { name: 'Goblin Group', cost: 3, emoji: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶', type: 'Swarm', unitClass: GoblinGang, placementRadius: 10, isFlying: false, arena: 2, targets: 'Air & Ground', aggroRange: 100,
                                stats: { 1: { count: 3, health: 100, damage: 20, hitSpeed: 1, speed: 1.0, spear_count: 3, spear_health: 60, spear_damage: 25, spear_hitSpeed: 1.2, spear_speed: 1.0 } } },
                    'spearGoblins': { name: 'Spear Goblins', cost: 2, emoji: 'üéØ', type: 'Swarm', unitClass: SpearGoblins, placementRadius: 10, isFlying: false, arena: 2, targets: 'Air & Ground', aggroRange: 100,
                                stats: { 1: { count: 3, health: 60, damage: 25, hitSpeed: 1.2, speed: 1.0 } } },
                    // Arena 3
                    'fireDragon': { name: 'Fire Dragon', cost: 4, emoji: 'üê≤', type: 'Air', unitClass: FireDragon, placementRadius: 14, isFlying: true, arena: 3, targets: 'Air & Ground', aggroRange: 120,
                                stats: { 1: { health: 800, damage: 100, hitSpeed: 1.0, speed: 0.8, splashRadius: 20 } } },
                    'barbarians': { name: 'Barbarians', cost: 5, emoji: 'üßî', type: 'Swarm', unitClass: Barbarians, placementRadius: 10, isFlying: false, arena: 3, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { count: 5, health: 300, damage: 60, hitSpeed: 1.4, speed: 0.8 } } },
                    'battleRam': { name: 'Battle Ram', cost: 4, emoji: 'üå≤', type: 'WinCon', unitClass: BattleRam, placementRadius: 10, isFlying: false, arena: 3, targets: 'Buildings', aggroRange: 100,
                                stats: { 1: { health: 700, damage: 200, chargeSpeed: 2.0, barbLevel: 1, speed: 0.8 } } },
                    'barbarianHut': { name: 'Barbarian House', cost: 7, emoji: 'üèòÔ∏è', type: 'Building', unitClass: BarbarianHut, placementRadius: 20, isFlying: false, arena: 3, targets: '-',
                                stats: { 1: { health: 1000, spawn_speed: '10s', lifetime: '40s', barbLevel: 1 } } },
                    'axeSwinger': { name: 'Axe Swinger', cost: 4, emoji: 'ü™ì', type: 'Melee', unitClass: AxeSwinger, placementRadius: 12, isFlying: false, arena: 3, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 700, damage: 100, hitSpeed: 1.5, splashRadius: 24, speed: 0.8 } } },
                    // Arena 4 (NEW CARDS)
                    'pigs': { name: 'Pigs', cost: 4, emoji: 'üê∑', type: 'WinCon', unitClass: Pigs, placementRadius: 10, isFlying: false, arena: 4, targets: 'Buildings', aggroRange: 100,
                                stats: { 1: { count: 4, health: 300, damage: 50, hitSpeed: 1.1, speed: 1.2 } } },
                    'farmer': { name: 'Farmer', cost: 3, emoji: 'üë®‚Äçüåæ', type: 'Melee', unitClass: Farmer, placementRadius: 12, isFlying: false, arena: 4, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 600, damage: 70, hitSpeed: 1.4, attackWidth: 30, attackHeight: 40, speed: 0.8 } } },
                    'poison': { name: 'Poison', cost: 4, emoji: 'ü§¢', type: 'Spell', radius: 60, placementRadius: 60, arena: 4, targets: 'Air & Ground',
                                stats: { 1: { damagePerSecond: 40, duration: 5 } } },
                    // Arena 5 (NEW CARDS)
                    'flyingSkeletons': { name: 'Flying Skeletons', cost: 3, emoji: 'üíÄü¶á', type: 'Swarm', unitClass: FlyingSkeletons, placementRadius: 10, isFlying: true, arena: 5, targets: 'Air & Ground', aggroRange: 100,
                                stats: { 1: { count: 3, health: 40, damage: 40, hitSpeed: 1, speed: 1.2 } } },
                    'megaFlyingSkeleton': { name: 'Mega Flying Skeleton', cost: 4, emoji: 'üíÄü¶á', type: 'Air', unitClass: MegaFlyingSkeleton, placementRadius: 12, isFlying: true, arena: 5, targets: 'Air & Ground', aggroRange: 100,
                                stats: { 1: { health: 600, damage: 100, hitSpeed: 1.3, speed: 1.0 } } },
                    'flyingSkeletonGroup': { name: 'Flying Skeleton Group', cost: 5, emoji: 'üíÄü¶á', type: 'Swarm', unitClass: FlyingSkeletonGroup, placementRadius: 10, isFlying: true, arena: 5, targets: 'Air & Ground', aggroRange: 100,
                                stats: { 1: { count: 6, health: 40, damage: 40, hitSpeed: 1, speed: 1.2 } } },
                    // Arena 6 (NEW CARDS)
                    'warlock': { name: 'Warlock', cost: 5, emoji: 'üîÆ', type: 'Ranged', unitClass: Warlock, placementRadius: 12, isFlying: false, arena: 6, targets: 'Air & Ground', aggroRange: 110,
                                stats: { 1: { health: 600, damage: 140, hitSpeed: 1.5, splashRadius: 30, speed: 0.8 } } },
                    // Arena 7 (NEW)
                    'mage': { name: 'Mage', cost: 5, emoji: 'üßô‚Äç‚ôÄÔ∏è', type: 'Ranged', unitClass: Mage, placementRadius: 12, isFlying: false, arena: 7, targets: 'Air & Ground', aggroRange: 110,
                        stats: { 1: { health: 350, damage: 120, hitSpeed: 1.5, splashRadius: 30, speed: 1.0 } } },
                    // Arena 7 (NEW CARDS)
                                        'phantomKnight': { name: 'Phantom Knight', cost: 4, emoji: 'üëª‚öîÔ∏è', type: 'Melee', unitClass: PhantomKnight, placementRadius: 12, isFlying: false, arena: 7, targets: 'Troops', aggroRange: 110,
                        stats: { 1: { health: 500, damage: 70, hitSpeed: 1.1, speed: 1.2 } } },
                    'spiritLantern': { name: 'Spirit Lantern', cost: 5, emoji: 'üèÆ', type: 'Building', unitClass: SpiritLantern, placementRadius: 18, isFlying: false, arena: 7, targets: '-',
                        stats: { 1: { health: 900, spawn_speed: '6s', lifetime: '24s' } } },
                    'zapSpirit': { name: 'Zap Spirit', cost: 1, emoji: '‚ö°', type: 'Spirit', unitClass: ZapSpirit, placementRadius: 8, isFlying: false, arena: 6, targets: 'Air & Ground', aggroRange: 200,
                                stats: { 1: { health: 150, jumpRadius: 100, effectRadius: 80, damage: 100, speed: 1.2 } } },
                    'coldSpirit': { name: 'Cold Spirit', cost: 1, emoji: '‚ùÑÔ∏è', type: 'Spirit', unitClass: ColdSpirit, placementRadius: 8, isFlying: false, arena: 6, targets: 'Air & Ground', aggroRange: 200,
                                stats: { 1: { health: 150, jumpRadius: 100, effectRadius: 60, freezeDuration: 3, speed: 1.2 } } },
                    'lifeSpirit': { name: 'Life Spirit', cost: 1, emoji: 'üíö', type: 'Spirit', unitClass: LifeSpirit, placementRadius: 8, isFlying: false, arena: 6, targets: '-', aggroRange: 200,
                                stats: { 1: { health: 150, jumpRadius: 100, effectRadius: 60, healDuration: 3, speed: 1.2 } } },
                    'bombSpirit': { name: 'Bomb Spirit', cost: 2, emoji: 'üí£', type: 'Spirit', unitClass: BombSpirit, placementRadius: 8, isFlying: false, arena: 6, targets: 'Air & Ground', aggroRange: 200,
                                stats: { 1: { health: 150, jumpRadius: 100, effectRadius: 50, damage: 200, speed: 1.2 } } },
                    'anger': { name: 'Anger', cost: 3, emoji: 'üò°', type: 'Spell', radius: 60, placementRadius: 60, arena: 6, targets: 'Air & Ground', 
                                stats: { 1: { duration: 5, damage: 110 } } },
                    // Arena 8 (NEW CARDS)
                    'chaosElemental': { name: 'Chaos Elemental', cost: 5, emoji: 'üëπ', type: 'Melee', unitClass: ChaosElemental, placementRadius: 12, isFlying: false, arena: 8, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 750, damage: 110, hitSpeed: 1.1, speed: 0.8 }, 2: { health: 825, damage: 121, hitSpeed: 1.1, speed: 0.8 }, 3: { health: 908, damage: 133, hitSpeed: 1.1, speed: 0.8 }, 4: { health: 998, damage: 146, hitSpeed: 1.1, speed: 0.8 }, 5: { health: 1098, damage: 161, hitSpeed: 1.1, speed: 0.8 }, 6: { health: 1208, damage: 177, hitSpeed: 1.1, speed: 0.8 } } },
                    'shadowClone': { name: 'Shadow Clone', cost: 4, emoji: 'üë§', type: 'Ranged', unitClass: ShadowClone, placementRadius: 10, isFlying: false, arena: 8, targets: 'Air & Ground', aggroRange: 120,
                                stats: { 1: { health: 320, damage: 55, hitSpeed: 1.2, speed: 0.8 }, 2: { health: 352, damage: 61, hitSpeed: 1.2, speed: 0.8 }, 3: { health: 387, damage: 67, hitSpeed: 1.2, speed: 0.8 }, 4: { health: 426, damage: 73, hitSpeed: 1.2, speed: 0.8 }, 5: { health: 469, damage: 81, hitSpeed: 1.2, speed: 0.8 }, 6: { health: 516, damage: 89, hitSpeed: 1.2, speed: 0.8 } } },
                    'voidTrap': { name: 'Void Trap', cost: 4, emoji: '‚ö´', type: 'Spell', radius: 70, placementRadius: 70, arena: 8, targets: 'Air & Ground',
                                stats: { 1: { damage: 180 } } },
                    'stoneGiant': { name: 'Stone Giant', cost: 8, emoji: 'üóø', type: 'Tank', unitClass: StoneGiant, placementRadius: 18, isFlying: false, arena: 8, targets: 'Towers', aggroRange: 100,
                                stats: { 1: { health: 1750, damage: 104, hitSpeed: 1.3, speed: 0.4 }, 2: { health: 1925, damage: 114, hitSpeed: 1.3, speed: 0.4 }, 3: { health: 2118, damage: 125, hitSpeed: 1.3, speed: 0.4 }, 4: { health: 2329, damage: 138, hitSpeed: 1.3, speed: 0.4 }, 5: { health: 2563, damage: 152, hitSpeed: 1.3, speed: 0.4 }, 6: { health: 2819, damage: 167, hitSpeed: 1.3, speed: 0.4 } } },
                    'miniStoneGiant': { name: 'Mini Stone Giant', cost: 0, emoji: 'ü™®', type: 'Troop', unitClass: MiniStoneGiant, placementRadius: 12, isFlying: false, hidden: true, targets: 'Towers', aggroRange: 80,
                            stats: { 1: { health: 700, damage: 41, hitSpeed: 1.3, speed: 0.5 }, 2: { health: 770, damage: 46, hitSpeed: 1.3, speed: 0.5 }, 3: { health: 848, damage: 51, hitSpeed: 1.3, speed: 0.5 }, 4: { health: 931, damage: 55, hitSpeed: 1.3, speed: 0.5 }, 5: { health: 1025, damage: 61, hitSpeed: 1.3, speed: 0.5 }, 6: { health: 1128, damage: 67, hitSpeed: 1.3, speed: 0.5 } } },
                    'chaosOrb': { name: 'Chaos Orb', cost: 3, emoji: 'üåÄ', type: 'Spell', radius: 50, placementRadius: 50, arena: 8, targets: 'Air & Ground',
                                stats: { 1: { damage: 200 } } },
                    // Arena 9 (NEW)
                    'skeletonYard': { name: 'Skeleton Yard', cost: 5, emoji: 'ü™¶', type: 'Spell', radius: 50, placementRadius: 50, arena: 9, targets: 'Ground',
                                stats: { 1: { duration: 7.5 } } },
                    'hugeSkeleton': { name: 'Huge Skeleton', cost: 6, emoji: 'üíÄüí£', type: 'Tank', unitClass: HugeSkeleton, placementRadius: 18, isFlying: false, arena: 9, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 2000, damage: 100, hitSpeed: 1.5, speed: 0.6, bombDamage: 900 } } },
                    'ninja': { name: 'Ninja', cost: 4, emoji: 'ü•∑', type: 'Melee', unitClass: Ninja, placementRadius: 12, isFlying: false, arena: 9, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 200, damage: 50, hitSpeed: 0.7, speed: 1.2 } } },
                                        'meteor': { name: 'Meteor', cost: 6, emoji: '‚òÑÔ∏è', type: 'Spell', radius: 40, placementRadius: 40, arena: 9, targets: 'Air & Ground',
                                stats: { 1: { damage: 250 } } },
                    // Arena 10 (NEW)
                    'megaSmasher': { name: 'Mega Smasher', cost: 7, emoji: 'üí•', type: 'Tank', unitClass: MegaSmasher, placementRadius: 18, isFlying: false, arena: 10, targets: 'Ground', aggroRange: 120,
                                stats: { 1: { health: 1250, damage: 100, hitSpeed: 1.8, speed: 0.4, spawnSplashRadius: 70, jumpDamage: 150, jumpSplashRadius: 80, jumpRange: 100, jumpCooldown: 6, minJumpRange: 40, attackWidth: 60, attackHeight: 40 } } },
                    'zapGiant': { name: 'Zap Giant', cost: 7, emoji: '‚ö°üí™', type: 'Tank', unitClass: ZapGiant, placementRadius: 18, isFlying: false, arena: 10, targets: 'Buildings', aggroRange: 100,
                                stats: { 1: { health: 2200, damage: 80, hitSpeed: 1.5, speed: 0.3, spawnDamage: 200, spawnRadius: 60, zapDamage: 50, zapRadius: 90, zapInterval: 1.5 } } },
                    'flameDragon': { name: 'Flame Dragon', cost: 4, emoji: 'üê≤üî•', type: 'Air', unitClass: FlameDragon, placementRadius: 14, isFlying: true, arena: 10, targets: 'Air & Ground', aggroRange: 120,
                                stats: { 1: { health: 800, damage: 20, hitSpeed: 0.4, speed: 0.8, rampMultiplier: 1.2, maxDamage: 200 } } },

                    'flameTower': { name: 'Flame Tower', cost: 5, emoji: 'üèØüî•', type: 'Building', unitClass: FlameTower, placementRadius: 20, isFlying: false, arena: 10, targets: 'Air & Ground',
                                stats: { 1: { health: 1400, damage: 20, hitSpeed: 1.0, lifetime: '40s', spawn_speed: '0s', rampMultiplier: 1.3, maxDamage: 250 } } },
                    'bot': { name: 'Bot', cost: 7, emoji: 'ü§ñ', type: 'Melee', unitClass: Bot, placementRadius: 15, isFlying: false, arena: 10, targets: 'Ground', aggroRange: 100,
                                stats: { 1: { health: 1800, damage: 350, hitSpeed: 2.0, speed: 0.3 } } },
                    'tower': { name: 'Tower Upgrade', emoji: 'üëë' }
                };
                
                // --- NEW: Auto-calculate stats for levels 2-15 ---
                for (const cardId in allCards) {
                    if (cardId === 'tower') continue; // Allow miniStoneGiant to auto-scale like other cards
                    const card = allCards[cardId];
                    for (let level = 2; level <= 15; level++) { // Cap at 15
                        if (!card.stats[level]) {
                            const prevStats = card.stats[level - 1];
                            const newStats = { ...prevStats };
                            // Increase health and damage by ~10% per level
                            if (newStats.health) newStats.health = Math.round(newStats.health * 1.1);
                            if (newStats.damage) newStats.damage = Math.round(newStats.damage * 1.1);
                            if (newStats.damagePerSecond) newStats.damagePerSecond = Math.round(newStats.damagePerSecond * 1.1); // For Poison
                            // Handle sub-unit stats
                            if (newStats.spear_health) newStats.spear_health = Math.round(newStats.spear_health * 1.1);
                            if (newStats.spear_damage) newStats.spear_damage = Math.round(newStats.spear_damage * 1.1);
                            // Handle spirit stats
                            if (newStats.jumpRadius) newStats.jumpRadius = Math.round(newStats.jumpRadius * 1.05);
                            if (newStats.effectRadius) newStats.effectRadius = Math.round(newStats.effectRadius * 1.05);
                            // Prevent splashRadius upgrade for AxeSwinger
            // Removed the line that upgrades splashRadius for all cards.
            // Update levels for spawner cards
            if (cardId === 'battleRam' || cardId === 'barbarianHut') newStats.barbLevel = level;
            
            // --- ADDED: Max Damage Scaling --- 
            if (newStats.maxDamage) newStats.maxDamage = Math.round(newStats.maxDamage * 1.1);
                            card.stats[level] = newStats;
                        }
                    }
                }
            }
            
            function getDistance(obj1, obj2) {
                const dx = obj1.x - obj2.x; const dy = obj1.y - obj2.y; return Math.sqrt(dx * dx + dy * dy);
            }

            // Helper for Farmer attack
            function isInside(point, cx, cy, width, height, angle) {
                const dx = point.x - cx;
                const dy = point.y - cy;
                const rotatedX = dx * Math.cos(-angle) - dy * Math.sin(-angle);
                const rotatedY = dx * Math.sin(-angle) + dy * Math.cos(-angle);
                // Check if point is inside the rectangle defined in front of the farmer
                return rotatedX > 0 && rotatedX < height && Math.abs(rotatedY) < width / 2;
            }

            function drawArena() {
                // River
                if (gameMode === 'snowman_challenge') {
                     ctx.fillStyle = '#bfdbfe'; // Icy River
                } else if (currentArenaTheme === 'arena-3') {
                    ctx.fillStyle = '#f45d22'; // Lava
                } else if (currentArenaTheme === 'arena-2') {
                    ctx.fillStyle = '#4a90e2'; // Lighter blue
                } else if (currentArenaTheme === 'arena-4') {
                    ctx.fillStyle = '#65a30d'; // Farm river
                } else if (currentArenaTheme === 'arena-5') {
                    ctx.fillStyle = '#4338ca'; // Indigo-700
                } else if (currentArenaTheme === 'arena-6') {
                    ctx.fillStyle = '#92400e'; // Brown-700
                } else if (currentArenaTheme === 'arena-8') {
                    ctx.fillStyle = '#9333ea'; // Purple-600 for chaos
                } else if (currentArenaTheme === 'arena-9') {
                    ctx.fillStyle = '#1e293b'; // Slate-800 for void
                } else {
                    ctx.fillStyle = '#3b82f6'; // Default blue
                }
                ctx.fillRect(0, RIVER_Y - 10, WIDTH, 20);
                
                // Bridges
                ctx.fillStyle = '#a16207'; // Brown
                ctx.fillRect(LANE_LEFT_X - 25, RIVER_Y - 15, 50, 30);
                ctx.fillRect(LANE_RIGHT_X - 25, RIVER_Y - 15, 50, 30);
            }

            function getAILevel() {
                if (trophies >= 2250) return 10;
                else if (trophies >= 2000) return 9;
                else if (trophies >= 1750) return 8;
                else if (trophies >= 1500) return 7;
                else if (trophies >= 1250) return 6;
                else if (trophies >= 1000) return 5;
                else if (trophies >= 750) return 4;
                else if (trophies >= 500) return 3;
                else if (trophies >= 250) return 2;
                return 1;
            }

            function ignoreDuplicates() {
            // REMOVED DUPLICATE BLOCK
            // (Duplicate functions removed to fix SyntaxError)
                let arenaNum = 1;
                if (aiLevel > 0) {
                    arenaNum = aiLevel;
                } else {
                    if (currentArenaFloor >= 2250) arenaNum = 10;
                    else if (currentArenaFloor >= 2000) arenaNum = 9;
                    else if (currentArenaFloor >= 1750) arenaNum = 8;
                    else if (currentArenaFloor >= 1500) arenaNum = 7;
                    else if (currentArenaFloor >= 1250) arenaNum = 6;
                    else if (currentArenaFloor >= 1000) arenaNum = 5;
                    else if (currentArenaFloor >= 750) arenaNum = 4;
                    else if (currentArenaFloor >= 500) arenaNum = 3;
                    else if (currentArenaFloor >= 250) arenaNum = 2;
                    else arenaNum = 1;
                }
                for (const cardId in allCards) {
                    if (cardId === 'tower' || cardId === 'miniStoneGiant') continue; // Never include tower or internal mini in this list
                    if (allCards[cardId].arena <= arenaNum) {
                        unlocked.push(cardId);
                    }
                }
                if (includeTower) {
                    unlocked.push('tower');
                }
                return unlocked;
            }

            function createCardDOM(cardId, isSmall = false, inHand = false) {
                const card = allCards[cardId];
                if (!card) return null;
                
                const cardData = cardCollection[cardId];
                // In 2v2 or Party mode, treat all cards as unlocked and level 15
                const isParty = (gameMode === '2v2' || gameMode === 'party1v1');
                const isLocked = isParty ? false : (!inHand && (!cardData || !cardData.unlocked));
                
                const cardEl = document.createElement('div');
                cardEl.className = `card-ui btn-shine ${isSmall ? 'card-ui-small' : ''}`;
                cardEl.dataset.unit = cardId;
                
                if (isLocked) { // Removed !inHand check, it's now at the top
                    cardEl.classList.add('card-ui-locked');
                    let lockedText = ``;
                    if (card.arena !== 1) {
                        lockedText = `<div class="card-ui-locked-arena">Unlocks in Arena ${card.arena}</div>`;
                    }
                    cardEl.innerHTML = `
                        <div class="card-ui-cost">${card.cost}</div>
                        <span class="card-ui-name">${card.name}</span>
                        <span class="card-ui-emoji">${card.emoji}</span>
                        <span class="card-ui-type">${card.type}</span>
                        ${lockedText}
                    `;
                    return cardEl;
                }

                const displayLevel = isParty ? 15 : ((cardData && cardData.level) ? cardData.level : 1);
                const displayCount = (cardData && cardData.count) ? cardData.count : 0;
                
                cardEl.dataset.cost = card.cost;
                cardEl.dataset.type = card.type;
                cardEl.dataset.emoji = card.emoji;
                cardEl.dataset.radius = card.placementRadius;
                if (card.radius) cardEl.dataset.spellRadius = card.radius;
                let progressBarHTML = '';
                let levelTextHTML = `<div class="card-ui-level">Lvl ${displayLevel}</div>`;
                if (!inHand) {
                    const costs = upgradeCosts[displayLevel];
                    let progress = 0;
                    let canUpgrade = false;
                    if (costs) {
                        progress = (displayCount / costs.cards) * 100;
                        if (displayCount >= costs.cards && gold >= costs.gold) { canUpgrade = true; }
                    } else { progress = 100; } // Max level
                    progressBarHTML = `<div class="card-ui-progress-bar"><div class="card-ui-progress ${canUpgrade ? 'can-upgrade' : ''}" style="width: ${Math.min(100, progress)}%;"></div></div>`;
                } else { levelTextHTML = ''; }
                cardEl.innerHTML = `<div class="card-ui-cost">${card.cost}</div><span class="card-ui-name">${card.name}</span><span class="card-ui-emoji">${card.emoji}</span><span class="card-ui-type">${card.type}</span>${levelTextHTML}${progressBarHTML}`;
                return cardEl;
            }

            function updateCardUI() {
                const elixirInt = Math.floor(playerElixir);
                elixirBar.style.width = `${(playerElixir / MAX_ELIXIR) * 100}%`;
                elixirText.textContent = elixirInt;
                document.querySelectorAll('#cardHand .card-ui').forEach(cardEl => {
                    const cost = parseInt(cardEl.dataset.cost);
                    if (cost > elixirInt) { cardEl.classList.add('disabled'); }
                    else { cardEl.classList.remove('disabled'); }
                });
            }

            function shuffleDeck(deck) {
                let shuffled = [...deck]; for (let i = shuffled.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; } return shuffled;
            }

            function renderHand() {
                cardHandEl.innerHTML = '';
                hand.forEach((cardId, index) => {
                    const cardEl = createCardDOM(cardId, false, true);
                    cardEl.dataset.handIndex = index;
                    // Handle touch/mouse down for card selection
                    cardEl.addEventListener('mousedown', (e) => selectCard(e, cardEl, cardId));
                    cardEl.addEventListener('touchstart', (e) => selectCard(e, cardEl, cardId), { passive: false });
                    cardHandEl.appendChild(cardEl);
                });
                nextCardSlotEl.innerHTML = '';
                if (nextCard) {
                    nextCardSlotEl.appendChild(createCardDOM(nextCard, true, true));
                }
                updateCardUI();
            }
            
            function startGameDecks() {
                // Player
                gameDeck = shuffleDeck(gameMode === '2v2' ? playerDeck2v2 : playerDeck);
                hand = [];
                discardPile = [];
                for (let i = 0; i < 4; i++) { hand.push(gameDeck.pop()); }
                nextCard = gameDeck.pop();
                renderHand();
                
                // AI
                const aiArenaLevel = getAILevel(); // This is 1, 2, 3, 4 or 5
                
                // AI gets cards from its arena level, NO tower card
                const aiArenaCards = getUnlockedCards(false, aiArenaLevel);
                
                // Build a random 8-card deck
                aiDeck = [];
                let availableCards = [...aiArenaCards];
                for (let i = 0; i < 8; i++) {
                    if (availableCards.length === 0) availableCards = [...aiArenaCards]; // Refill if needed
                    let cardIndex = Math.floor(Math.random() * availableCards.length);
                    aiDeck.push(availableCards.splice(cardIndex, 1)[0]);
                }
                
                aiDeck = shuffleDeck(aiDeck);
                aiHand = [];
                aiDiscardPile = [];
                for (let i = 0; i < 4; i++) { if(aiDeck.length > 0) aiHand.push(aiDeck.pop()); }
                if(aiDeck.length > 0) aiNextCard = aiDeck.pop();

                // Initialize second AI for 2v2 - uses all available cards
                if (gameMode === '2v2') {
                    ai2Deck = [];
                    // Get all cards except internal ones
                    const all2v2Cards = Object.keys(allCards).filter(cardId => 
                        cardId !== 'tower' && cardId !== 'miniStoneGiant'
                    );
                    let availableCards2 = [...all2v2Cards];
                    for (let i = 0; i < 8; i++) {
                        if (availableCards2.length === 0) availableCards2 = [...all2v2Cards];
                        let cardIndex = Math.floor(Math.random() * availableCards2.length);
                        ai2Deck.push(availableCards2.splice(cardIndex, 1)[0]);
                    }
                    ai2Deck = shuffleDeck(ai2Deck);
                    ai2Hand = [];
                    ai2DiscardPile = [];
                    for (let i = 0; i < 4; i++) { if(ai2Deck.length > 0) ai2Hand.push(ai2Deck.pop()); }
                    if(ai2Deck.length > 0) ai2NextCard = ai2Deck.pop();
                }
            }

            function playCard(cardId, handIndex) {
                playerElixir -= allCards[cardId].cost;
                discardPile.push(cardId);
                hand.splice(handIndex, 1);
                hand.push(nextCard);
                if (gameDeck.length === 0) { gameDeck = shuffleDeck(discardPile); discardPile = []; }
                nextCard = gameDeck.pop();
                renderHand();
            }

            function aiPlayCard(cardId) {
                if (!allCards[cardId]) return; // Safety check
                aiElixir -= allCards[cardId].cost;
                aiDiscardPile.push(cardId);
                const handIndex = aiHand.indexOf(cardId);
                if (handIndex > -1) { aiHand.splice(handIndex, 1); }
                aiHand.push(aiNextCard);
                if (aiDeck.length === 0) { aiDeck = shuffleDeck(aiDiscardPile); aiDiscardPile = []; }
                aiNextCard = aiDeck.pop() || null;
            }

            function initGame() {
                if (gameLoopId) cancelAnimationFrame(gameLoopId); // Prevent multiple loops
                gameObjects = [];
                playerElixir = 3;
                aiElixir = 3;
                aiTeammateElixir = 3; // Reset AI teammate elixir to 3
                selectedSpawningUnit = null;
                isSpawningSpell = false;
                gameRunning = true;
                aiThinkTimer = 0;
                gameTimer = REGULATION_TIME;
                isOvertime = false;
                isTieBreaker = false;
                tieBreakerTick = 0;
                overtimeInitialPlayerTowers = 0; // NEW
                overtimeInitialAiTowers = 0; // NEW
                
                // Reset spawn zones
                playerLeftTowerDestroyed = false;
                playerRightTowerDestroyed = false;
                aiLeftTowerDestroyed = false;
                aiRightTowerDestroyed = false;
                updatePlacementOverlay();
                
                messageOverlay.style.display = 'none';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';

                const aiArenaLevel = getAILevel();
                // UPDATED AI STAT LEVEL LOGIC
                if (aiArenaLevel === 1) { // Arena 1: 1
                    currentAiStatLevel = 1;
                } else if (aiArenaLevel === 2) { // Arena 2: 1-2
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 1; // 1 or 2
                } else if (aiArenaLevel === 3) { // Arena 3: 2-3
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 2; // 2 or 3
                } else if (aiArenaLevel === 4) { // Arena 4: 2-3
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 2; // 2 or 3
                } else if (aiArenaLevel === 5) { // Arena 5: 4-5
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 4; // 4 or 5
                } else if (aiArenaLevel === 6) { // Arena 6: 4-5
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 4; // 4 or 5
                } else if (aiArenaLevel === 7) { // Arena 7: 5-6
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 5; // 5 or 6
                } else if (aiArenaLevel === 8) { // Arena 8: 5-6
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 5; // 5 or 6
                } else if (aiArenaLevel === 9) { // Arena 9: 6-7
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 6; // 6 or 7
                } else if (aiArenaLevel === 10) { // Arena 10: 7-8
                    currentAiStatLevel = Math.floor(Math.random() * 2) + 7; // 7 or 8
                }
                
                const isParty = (gameMode === '2v2' || gameMode === 'party1v1');
                const playerTowerLevel = isParty ? 15 : towerLevel;
                const aiTowerLevel = isParty ? 15 : currentAiStatLevel;
                
                if (gameMode === '2v2') {
                    // 2v2: Two princess towers per side, one combined double king tower per side
                    gameObjects.push(new Tower(LANE_LEFT_X, HEIGHT - 100, 'player', false, playerTowerLevel, false, selectedTower));
                    gameObjects.push(new Tower(LANE_RIGHT_X, HEIGHT - 100, 'player', false, playerTowerLevel, false, selectedTower));
                    gameObjects.push(new Tower(WIDTH / 2, HEIGHT - 50, 'player', true, playerTowerLevel, true, selectedTower));
                    // AI Random Tower if high level
                    const aiType = (aiArenaLevel >= 10 && Math.random() > 0.5) ? ['waffle','machineGun','rocketeer'][Math.floor(Math.random()*3)] : 'princess';
                    gameObjects.push(new Tower(LANE_LEFT_X, 100, 'ai', false, aiTowerLevel, false, aiType));
                    gameObjects.push(new Tower(LANE_RIGHT_X, 100, 'ai', false, aiTowerLevel, false, aiType));
                    gameObjects.push(new Tower(WIDTH / 2, 50, 'ai', true, aiTowerLevel, true, aiType));
                } else if (gameMode === 'snowman_challenge') {
                    // Snowman Challenge: No Towers, Just Snowman Kings!
                    // Spawn them slightly forward so they have room to run
                    gameObjects.push(new SnowmanKing(WIDTH / 2, HEIGHT - 150, 'player'));
                    gameObjects.push(new SnowmanKing(WIDTH / 2, 150, 'ai'));
                } else {
                    // Normal: two princess towers, one king tower per side
                    const aiType = (aiArenaLevel >= 10 && Math.random() > 0.5) ? ['waffle','machineGun','rocketeer'][Math.floor(Math.random()*3)] : 'princess';
                    // Use collection level if available for player
                    const pTowerData = towerCollection[selectedTower];
                    const pLvl = (gameMode === 'party1v1') ? 15 : (pTowerData ? pTowerData.level : playerTowerLevel);
                    
                    gameObjects.push(new Tower(LANE_LEFT_X, HEIGHT - 100, 'player', false, pLvl, false, selectedTower));
                    gameObjects.push(new Tower(LANE_RIGHT_X, HEIGHT - 100, 'player', false, pLvl, false, selectedTower));
                    gameObjects.push(new Tower(WIDTH / 2, HEIGHT - 50, 'player', true, playerTowerLevel, false, selectedTower));
                    gameObjects.push(new Tower(LANE_LEFT_X, 100, 'ai', false, aiTowerLevel, false, aiType));
                    gameObjects.push(new Tower(LANE_RIGHT_X, 100, 'ai', false, aiTowerLevel, false, aiType));
                    gameObjects.push(new Tower(WIDTH / 2, 50, 'ai', true, aiTowerLevel, false, aiType));
                }

                startGameDecks();
                updateCardUI();

                // Initialize AI teammate if in 2v2 AI mode
                if (gameMode === '2v2' && is2v2AITeammate) {
                    initAITeammate();
                    updateAITeammateUI();
                }
            }

            function runAI() {
                const playerUnits = gameObjects.filter(o => o.team === 'player' && o instanceof Unit && o.y < RIVER_Y + 50);
                if (playerUnits.length > 0) {
                    let bestCardId = null;
                    // --- NEW AI LOGIC ---
                    if (playerUnits.some(u => u instanceof FlyingSkeleton || u instanceof FlyingSkeletonGroup) && aiHand.includes('fireDragon') && aiElixir >= allCards['fireDragon'].cost) {
                         bestCardId = 'fireDragon';
                    } else if (playerUnits.some(u => u instanceof FlyingSkeleton || u instanceof FlyingSkeletonGroup || u instanceof MegaFlyingSkeleton) && aiHand.includes('archer') && aiElixir >= allCards['archer'].cost) {
                         bestCardId = 'archer';
                    } else if (playerUnits.some(u => u instanceof Skeleton || u instanceof SkeletonArmy || u instanceof Barbarians || u instanceof GoblinGang) && aiHand.includes('poison') && aiElixir >= allCards['poison'].cost) {
                        bestCardId = 'poison';
                    } else if (playerUnits.some(u => u instanceof Skeleton || u instanceof SkeletonArmy || u instanceof Barbarians) && aiHand.includes('axeSwinger') && aiElixir >= allCards['axeSwinger'].cost) {
                        bestCardId = 'axeSwinger';
                    } else if (playerUnits.some(u => u instanceof Skeleton || u instanceof SkeletonArmy || u instanceof FlyingSkeleton || u instanceof FlyingSkeletonGroup) && aiHand.includes('arrows') && aiElixir >= allCards['arrows'].cost) {
                        bestCardId = 'arrows';
                    } else if (playerUnits.some(u => u instanceof Giant || u instanceof Pigs) && aiHand.includes('farmer') && aiElixir >= allCards['farmer'].cost) {
                        bestCardId = 'farmer';
                    } else if (playerUnits.some(u => u instanceof Giant) && aiHand.includes('tinyBot') && aiElixir >= allCards['tinyBot'].cost) {
                        bestCardId = 'tinyBot';
                    } else if (playerUnits.some(u => u instanceof Giant) && aiHand.includes('barbarians') && aiElixir >= allCards['barbarians'].cost) {
                        bestCardId = 'barbarians';
                    } else if (playerUnits.some(u => u instanceof FireDragon) && aiHand.includes('archer') && aiElixir >= allCards['archer'].cost) {
                        bestCardId = 'archer';
                    } else if (aiHand.includes('goblins') && aiElixir >= allCards['goblins'].cost) {
                        bestCardId = 'goblins';
                    }
                    if (bestCardId) { spawnAIUnit(bestCardId, currentAiStatLevel, true); return; } // Use global
                }
                
                // Fallback: If elixir is high, play a card
                if (aiElixir > 7) {
                    let bestCardId = null;
                    if(aiHand.includes('pigs') && aiElixir >= allCards['pigs'].cost) { bestCardId = 'pigs'; } // NEW
                    else if(aiHand.includes('giant') && aiElixir >= allCards['giant'].cost) { bestCardId = 'giant'; }
                    else if(aiHand.includes('barbarianHut') && aiElixir >= allCards['barbarianHut'].cost) { bestCardId = 'barbarianHut'; }
                    else if (aiHand.includes('tinyBot') && aiElixir >= allCards['tinyBot'].cost) { bestCardId = 'tinyBot'; }
                    else if (aiHand.includes('megaFlyingSkeleton') && aiElixir >= allCards['megaFlyingSkeleton'].cost) { bestCardId = 'megaFlyingSkeleton'; }
                    else {
                        // Play any random affordable unit
                        let affordableCards = aiHand.filter(id => allCards[id] && allCards[id].cost <= aiElixir && allCards[id].type !== 'Spell');
                        if (affordableCards.length > 0) {
                            bestCardId = affordableCards[Math.floor(Math.random() * affordableCards.length)];
                        }
                    }
                    if (bestCardId) { spawnAIUnit(bestCardId, currentAiStatLevel, false); return; } // Use global
                }

                // Use spell on tower
                if (aiElixir === MAX_ELIXIR && Math.random() < 0.2) {
                    let spellToUse = null;
                    if (aiHand.includes('poison')) spellToUse = 'poison';
                    else if (aiHand.includes('fireball')) spellToUse = 'fireball';
                    if (spellToUse) {
                        spawnAIUnit(spellToUse, currentAiStatLevel, false); // Use global
                        return;
                    }
                }
            }

            function spawnAIUnit(cardId, level, isDefensive = false) {
                const card = allCards[cardId];
                if (!card || card.cost > aiElixir) return;
                
                // Get AI's level for this card (force 15 in 2v2 or Party 1v1)
                const isParty = (gameMode === '2v2' || gameMode === 'party1v1');
                const cardLevel = isParty ? 15 : level;
                
                if (card.type === 'Spell') {
                    let target = null;
                    if (cardId === 'fireball') {
                        target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0 && o.health < 600);
                        if (!target) target = gameObjects.find(o => o.team === 'player' && (o instanceof Barbarian || o instanceof Farmer));
                    } else if (cardId === 'arrows') {
                        target = gameObjects.find(o => o.team === 'player' && (o instanceof Skeleton || o instanceof SkeletonArmy || o instanceof GoblinGang || o instanceof FlyingSkeleton || o instanceof FlyingSkeletonGroup));
                    } else if (cardId === 'poison') { // NEW
                        target = gameObjects.find(o => o.team === 'player' && (o instanceof Tower) && o.health > 0);
                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Unit && o.y > RIVER_Y - 50);
                    } else if (cardId === 'anger') { // NEW
                        target = gameObjects.find(o => o.team === 'ai' && (o instanceof Unit || o instanceof Tower || o instanceof Building) && o.health > 0);
                    } else if (cardId === 'voidTrap') { // NEW
                        target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0);
                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Unit && o.health > 0);
                    } else if (cardId === 'chaosOrb') { // NEW
                        target = gameObjects.find(o => o.team === 'player' && (o instanceof Unit || o instanceof Building) && o.health > 0);
                        if (!target) target = gameObjects.find(o => o.team === 'player' && o instanceof Tower && o.health > 0);
                    }
                    if (target) {
                        if (cardId === 'poison') { // NEW
                            const s = card.stats[cardLevel];
                            gameObjects.push(new PoisonSpell(target.x, target.y, 'ai', s.damagePerSecond, card.radius, s.duration));
                        } else if (cardId === 'anger') { // NEW
                            const s = card.stats[cardLevel];
                            gameObjects.push(new AngerSpell(target.x, target.y, 'ai', card.radius, s.duration, s.damage));
                        } else if (cardId === 'voidTrap') { // NEW
                            const damage = card.stats[cardLevel].damage;
                            gameObjects.push(new VoidTrapEffect(target.x, target.y, 'ai', card.radius, damage));
                        } else if (cardId === 'chaosOrb') { // NEW
                            const damage = card.stats[cardLevel].damage;
                            gameObjects.push(new ChaosOrbEffect(target.x, target.y, 'ai', card.radius, damage));
                        } else {
                            const damage = card.stats[cardLevel].damage;
                            gameObjects.push(new Spell(target.x, target.y, 'ai', damage, card.radius, card.emoji));
                        }
                        aiPlayCard(cardId);
                    }
                    return;
                }
                
                // NEW: Handle spirits
                if (card.type === 'Spirit') {
                    // Safety check: ensure unitClass exists
                    if (!card.unitClass || typeof card.unitClass !== 'function') {
                        console.error('Invalid unitClass for spirit card:', cardId, card);
                        return;
                    }
                    const spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;
                    const spawnY = isDefensive ? 150 + Math.random() * 50 : 50 + Math.random() * 50;
                    const newUnit = new card.unitClass(spawnX, spawnY, 'ai', cardLevel);
                    if (newUnit instanceof GameObject) {
                        gameObjects.push(newUnit);
                    }
                    aiPlayCard(cardId);
                    return;
                }
                
                // Determine spawn Y & X
                let spawnY, spawnX;
                if (isDefensive) {
                    if (gameMode === 'snowman_challenge') {
                         // Snowman Defense: Spawn near the King to protect it
                         const aiKing = gameObjects.find(t => t.team === 'ai' && t.isKing);
                         if (aiKing) {
                             spawnY = aiKing.y + (Math.random() * 60 - 30);
                             spawnX = aiKing.x + (Math.random() * 60 - 30);
                         } else {
                             spawnY = 150 + Math.random() * 50;
                             spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;
                         }
                    } else {
                        // Spawn behind princess towers
                        spawnY = 150 + Math.random() * 50;
                        spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;
                    }
                } else {
                    // Spawn at the back
                    spawnY = 50 + Math.random() * 50;
                    spawnX = Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X;
                }
                
                // Check if spawn is valid (not on top of another building)
                let canSpawn = true;
                if (card.type === 'Building') {
                    for (const obj of gameObjects) {
                        if (obj instanceof Tower || obj instanceof Building) {
                            const dist = getDistance({x: spawnX, y: spawnY}, obj);
                            if (dist < card.placementRadius + obj.radius) { 
                                canSpawn = false; 
                                break; 
                            }
                        }
                    }
                }
                
                if (canSpawn && card.unitClass && typeof card.unitClass === 'function') {
                    const newUnit = new card.unitClass(spawnX, spawnY, 'ai', cardLevel);
                    // --- TYPEERROR FIX ---
                    // This is the bug. 'newUnit' is just the spawner (e.g. Pigs), not an actual Unit (e.g. Pig)
                    // We must check if the *class* is a single unit/building
                    if (newUnit instanceof GameObject) {
                         gameObjects.push(newUnit);
                    }
                    aiPlayCard(cardId);
                }
            }

            // --- AI Teammate (for 2v2) ---
            let aiTeammateTimer = 0;
            let aiTeammateElixir = 0;
            let aiTeammateHandCards = [];
            let aiTeammateDeck = [];
            let aiTeammateDiscardPile = []; // Add discard pile for recycling
            let aiTeammateNextCard = null; // Add NEXT card for proper cycling

            function initAITeammate() {
                // Note: elixir is reset to 3 in initGame(), not here
                aiTeammateHandCards = [];
                aiTeammateDiscardPile = []; // Reset discard pile
                aiTeammateNextCard = null; // Reset NEXT card
                
                // Build an 8-card deck for AI teammate (any card in the game)
                aiTeammateDeck = [];
                // Use all cards in the game for maximum variety
                const allGameCards = Object.keys(allCards).filter(cardId => 
                    cardId !== 'tower' && cardId !== 'miniStoneGiant' // Exclude internal cards
                );
                let availableCards = [...allGameCards];
                
                for (let i = 0; i < 8; i++) {
                    if (availableCards.length === 0) availableCards = [...allGameCards]; // Refill if needed
                    let cardIndex = Math.floor(Math.random() * availableCards.length);
                    aiTeammateDeck.push(availableCards.splice(cardIndex, 1)[0]);
                }
                
                aiTeammateDeck = shuffleDeck(aiTeammateDeck);
                
                // Draw initial hand (4 cards from the 8-card deck)
                for (let i = 0; i < 4; i++) {
                    aiTeammateHandCards.push(aiTeammateDeck.pop());
                }
                
                // Set initial NEXT card from the remaining 4 cards in deck
                if (aiTeammateDeck.length > 0) {
                    aiTeammateNextCard = aiTeammateDeck.pop();
                }
                
                updateAITeammateUI();
            }

            function drawAITeammateCard() {
                // Draw new NEXT card from remaining deck
                if (aiTeammateDeck.length > 0) {
                    aiTeammateNextCard = aiTeammateDeck.pop();
                }
                
                updateAITeammateUI();
            }

            function updateAITeammateUI() {
                if (gameMode !== '2v2' || !is2v2AITeammate) {
                    aiTeammateUI.style.display = 'none';
                    return;
                }
                aiTeammateUI.style.display = 'flex';
                // Render hand (exact same style as player hand)
                aiTeammateHand.innerHTML = '';
                aiTeammateHandCards.forEach(cardId => {
                    const cardEl = createCardDOM(cardId, false, true); // Same as player hand
                    cardEl.style.opacity = '0.8'; // Slightly transparent to distinguish from player
                    aiTeammateHand.appendChild(cardEl);
                });
                // Render next card (same style as player next)
                aiTeammateNext.innerHTML = '';
                if (aiTeammateNextCard) {
                    const cardEl = createCardDOM(aiTeammateNextCard, true, true); // Same as player next
                    cardEl.style.opacity = '0.6'; // Slightly transparent to distinguish from player
                    aiTeammateNext.appendChild(cardEl);
                }
                // Update elixir bar and count
                const elixirPercent = (aiTeammateElixir / MAX_ELIXIR) * 100;
                aiTeammateElixirBar.style.width = `${elixirPercent}%`;
                aiTeammateElixirCount.textContent = `${Math.floor(aiTeammateElixir)}/${MAX_ELIXIR}`;
            }

            function runAI2() {
                if (ai2ThinkTimer > 0) { ai2ThinkTimer--; return; }
                ai2ThinkTimer = 120; // Think every 2 seconds

                const playerUnits = gameObjects.filter(o => o.team === 'player' && o instanceof Unit && o.y < RIVER_Y + 50);
                if (playerUnits.length > 0) {
                    let bestCardId = null;
                    // --- NEW AI LOGIC ---
                    if (playerUnits.some(u => u instanceof FlyingSkeleton || u instanceof FlyingSkeletonGroup) && ai2Hand.includes('fireDragon') && ai2Elixir >= allCards['fireDragon'].cost) {
                         bestCardId = 'fireDragon';
                    } else if (playerUnits.some(u => u.isFlying) && ai2Hand.includes('arrows') && ai2Elixir >= allCards['arrows'].cost) {
                         bestCardId = 'arrows';
                    } else if (playerUnits.some(u => !u.isFlying) && ai2Hand.includes('axeSwinger') && ai2Elixir >= allCards['axeSwinger'].cost) {
                         bestCardId = 'axeSwinger';
                    } else if (ai2Hand.includes('giant') && ai2Elixir >= allCards['giant'].cost) {
                         bestCardId = 'giant';
                    } else if (ai2Hand.includes('stoneGiant') && ai2Elixir >= allCards['stoneGiant'].cost) {
                         bestCardId = 'stoneGiant';
                    } else if (ai2Hand.includes('fireDragon') && ai2Elixir >= allCards['fireDragon'].cost) {
                         bestCardId = 'fireDragon';
                    } else if (ai2Hand.includes('archer') && ai2Elixir >= allCards['archer'].cost) {
                         bestCardId = 'archer';
                    } else if (ai2Hand.includes('mage') && ai2Elixir >= allCards['mage'].cost) {
                         bestCardId = 'mage';
                    } else if (ai2Hand.includes('skeletons') && ai2Elixir >= allCards['skeletons'].cost) {
                         bestCardId = 'skeletons';
                    } else if (ai2Hand.includes('goblinGang') && ai2Elixir >= allCards['goblinGang'].cost) {
                         bestCardId = 'goblinGang';
                    } else if (ai2Hand.includes('barbarians') && ai2Elixir >= allCards['barbarians'].cost) {
                         bestCardId = 'barbarians';
                    } else if (ai2Hand.includes('cannon') && ai2Elixir >= allCards['cannon'].cost) {
                         bestCardId = 'cannon';
                    } else if (ai2Hand.includes('poison') && ai2Elixir >= allCards['poison'].cost) {
                         bestCardId = 'poison';
                    } else if (ai2Hand.includes('rage') && ai2Elixir >= allCards['rage'].cost) {
                         bestCardId = 'rage';
                    } else if (ai2Hand.includes('heal') && ai2Elixir >= allCards['heal'].cost) {
                         bestCardId = 'heal';
                    } else if (ai2Hand.includes('fireball') && ai2Elixir >= allCards['fireball'].cost) {
                         bestCardId = 'fireball';
                    } else if (ai2Hand.includes('lightning') && ai2Elixir >= allCards['lightning'].cost) {
                         bestCardId = 'lightning';
                    }
                    // --- END NEW AI LOGIC ---
                    if (bestCardId && ai2Elixir >= allCards[bestCardId].cost) {
                        const card = allCards[bestCardId];
                        // Safety check: ensure card exists and unitClass exists for non-spells
                        if (!card) {
                            console.error('Card not found:', bestCardId);
                            return;
                        }
                        if (card.type !== 'Spell' && (!card.unitClass || typeof card.unitClass !== 'function')) {
                            console.error('Invalid unitClass for non-spell card:', bestCardId, card);
                            return;
                        }
                        let spawnX = LANE_LEFT_X + Math.random() * (LANE_RIGHT_X - LANE_LEFT_X);
                        let spawnY = 100 + Math.random() * 100;
                        if (checkPlacement(spawnX, spawnY, card.placementRadius, card.type)) {
                            const level = (gameMode === '2v2') ? 15 : currentAi2StatLevel;
                            
                            // Handle spells properly
                            if (card.type === 'Spell') {
                                if (bestCardId === 'poison') {
                                    const s = card.stats[level];
                                    gameObjects.push(new PoisonSpell(spawnX, spawnY, 'ai', s.damagePerSecond, card.radius, s.duration));
                                } else if (bestCardId === 'rage') {
                                    const s = card.stats[level];
                                    gameObjects.push(new AngerSpell(spawnX, spawnY, 'ai', card.radius, s.duration));
                                } else if (bestCardId === 'arrows' || bestCardId === 'fireball') {
                                    const s = card.stats[level];
                                    gameObjects.push(new Projectile(spawnX, spawnY, null, 'ai', s.damage, card.radius));
                                } else if (bestCardId === 'heal') {
                                    const s = card.stats[level];
                                    gameObjects.push(new HealSpell(spawnX, spawnY, 'ai', s.healAmount, card.radius));
                                } else if (bestCardId === 'lightning') {
                                    const s = card.stats[level];
                                    gameObjects.push(new LightningSpell(spawnX, spawnY, 'ai', s.damage, card.radius));
                                }
                            } else if (card.type === 'Building') {
                                const newBuilding = new card.unitClass(spawnX, spawnY, 'ai', level);
                                if (newBuilding instanceof GameObject) gameObjects.push(newBuilding);
                            } else {
                                const newUnit = new card.unitClass(spawnX, spawnY, 'ai', level);
                                if (newUnit instanceof GameObject) {
                                    gameObjects.push(newUnit);
                                }
                            }
                            
                            // Proper card cycling like the first AI
                            const handIndex = ai2Hand.indexOf(bestCardId);
                            if (handIndex > -1) { 
                                ai2Hand.splice(handIndex, 1); 
                                ai2DiscardPile.push(bestCardId); // Add to discard pile
                            }
                            // Add NEXT card to hand (like player system)
                            if (ai2NextCard) {
                                ai2Hand.push(ai2NextCard);
                                ai2NextCard = null;
                            }
                            ai2Elixir -= card.cost;
                            // Draw new NEXT card and handle deck recycling
                            if (ai2Deck.length === 0 && ai2DiscardPile.length > 0) {
                                ai2Deck = shuffleDeck(ai2DiscardPile);
                                ai2DiscardPile = [];
                            }
                            if (ai2Deck.length > 0) {
                                ai2NextCard = ai2Deck.pop();
                            }
                        }
                    }
                }
            }

            function ai2PlayCard(cardId) {
                const index = ai2Hand.indexOf(cardId);
                if (index !== -1) {
                    ai2Hand.splice(index, 1);
                    ai2Elixir -= allCards[cardId].cost;
                    if (ai2Deck.length > 0) {
                        const newCard = ai2Deck.splice(Math.floor(Math.random() * ai2Deck.length), 1)[0];
                        ai2Hand.push(newCard);
                    }
                }
            }

            function runAITeammate() {
                if (gameMode !== '2v2' || !is2v2AITeammate) return;
                if (aiTeammateTimer > 0) { aiTeammateTimer -= deltaTime * 60; return; } /* Scale AI Teammate timer by delta time */
                aiTeammateTimer = 90; // Think every ~1.5s

                // Find an affordable card
                const affordableCards = aiTeammateHandCards.filter(cardId => {
                    const card = allCards[cardId];
                    return card && card.cost <= aiTeammateElixir;
                });
                if (affordableCards.length === 0) return;

                // Smart decision: choose best card based on board state
                let bestCardId = null;
                let bestScore = -Infinity;

                const aiUnits = gameObjects.filter(o => o.team === 'ai' && o instanceof Unit);
                const playerUnits = gameObjects.filter(o => o.team === 'player' && o instanceof Unit);
                const aiTowers = gameObjects.filter(o => o.team === 'ai' && o instanceof Tower && o.health > 0);
                const playerTowers = gameObjects.filter(o => o.team === 'player' && o instanceof Tower && o.health > 0);

                for (const cardId of affordableCards) {
                    const card = allCards[cardId];
                    let score = 0;

                    // Defensive: if our towers are under attack
                    if (aiTowers.length > 0 && playerUnits.some(u => getDistance(u, aiTowers[0]) < 200)) {
                        if (card.type === 'Spell' && (cardId === 'arrows' || cardId === 'fireball' || cardId === 'poison')) {
                            score += 50;
                        } else if (card.type === 'Unit' && (cardId === 'skeletons' || cardId === 'goblinGang' || cardId === 'barbarians')) {
                            score += 30;
                        }
                    }

                    // Offensive: if enemy has units
                    if (playerUnits.length > 0) {
                        if (card.type === 'Unit') {
                            if (cardId === 'giant' || cardId === 'stoneGiant') score += 40;
                            else if (cardId === 'fireDragon' && playerUnits.some(u => u.isFlying)) score += 45;
                            else if (cardId === 'archer' && playerUnits.some(u => u.isFlying)) score += 35;
                            else if (cardId === 'axeSwinger' && playerUnits.some(u => !u.isFlying)) score += 35;
                            else score += 20;
                        } else if (card.type === 'Spell') {
                            if (playerUnits.length >= 3 && (cardId === 'poison' || cardId === 'fireball')) score += 40;
                            else if (playerUnits.some(u => u.isFlying) && cardId === 'arrows') score += 35;
                        } else if (card.type === 'Building') {
                            if (cardId === 'cannon') score += 25;
                        }
                    }

                    // Support: if we have units pushing
                    if (aiUnits.length > 2) {
                        if (cardId === 'rage') score += 30;
                        if (cardId === 'heal') score += 20;
                    }

                    // Randomness
                    score += Math.random() * 10;

                    if (score > bestScore) {
                        bestScore = score;
                        bestCardId = cardId;
                    }
                }

                if (!bestCardId) return;

                const card = allCards[bestCardId];
                const handIndex = aiTeammateHandCards.indexOf(bestCardId);

                // Choose placement
                let targetX, targetY;
                if (card.type === 'Spell') {
                    // Target enemy units or towers
                    const target = playerUnits.length > 0 ? playerUnits[0] : playerTowers[0];
                    if (target) {
                        targetX = target.x;
                        targetY = target.y;
                    } else {
                        return;
                    }
                } else if (card.type === 'Building') {
                    // Place near our king tower
                    targetX = WIDTH / 2 + (Math.random() - 0.5) * 100;
                    targetY = 50 + Math.random() * 50;
                } else {
                    // Units: spawn near river, prefer lanes with enemy units
                    const lane = playerUnits.length > 0 ? (playerUnits[0].x < WIDTH / 2 ? LANE_LEFT_X : LANE_RIGHT_X) : (Math.random() < 0.5 ? LANE_LEFT_X : LANE_RIGHT_X);
                    targetX = lane + (Math.random() - 0.5) * 40;
                    targetY = RIVER_Y + 20 + Math.random() * 80;
                }

                if (card.type === 'Spell' || checkPlacement(targetX, targetY, card.placementRadius || 20, card.type)) {
                    const level = 15;
                    if (card.type === 'Spell') {
                        // Handle spells
                        if (bestCardId === 'poison') {
                            const s = card.stats[level];
                            gameObjects.push(new PoisonSpell(targetX, targetY, 'player', s.damagePerSecond, card.radius, s.duration));
                        } else if (bestCardId === 'rage') {
                            const s = card.stats[level];
                            gameObjects.push(new AngerSpell(targetX, targetY, 'player', card.radius, s.duration));
                        } else if (bestCardId === 'arrows' || bestCardId === 'fireball') {
                            const s = card.stats[level];
                            gameObjects.push(new Projectile(targetX, targetY, null, 'player', s.damage, card.radius));
                        }
                    } else if (card.type === 'Building') {
                        const newBuilding = new card.unitClass(targetX, targetY, 'player', level);
                        if (newBuilding instanceof GameObject) gameObjects.push(newBuilding);
                    } else {
                        const newUnit = new card.unitClass(targetX, targetY, 'player', level);
                        if (newUnit instanceof GameObject) gameObjects.push(newUnit);
                    }

                    showTeammatePlacement(targetX, targetY, card.emoji);
                    aiTeammateHandCards.splice(handIndex, 1);
                    aiTeammateDiscardPile.push(bestCardId); // Add played card to discard pile
                    // Add NEXT card to hand (like player system)
                    if (aiTeammateNextCard) {
                        aiTeammateHandCards.push(aiTeammateNextCard);
                        aiTeammateNextCard = null;
                    }
                    // Draw new NEXT card from remaining deck
                    if (aiTeammateDeck.length > 0) {
                        aiTeammateNextCard = aiTeammateDeck.pop();
                    } else if (aiTeammateDiscardPile.length > 0) {
                        // Recycle discard pile when deck is empty
                        aiTeammateDeck = shuffleDeck(aiTeammateDiscardPile);
                        aiTeammateDiscardPile = [];
                        if (aiTeammateDeck.length > 0) {
                            aiTeammateNextCard = aiTeammateDeck.pop();
                        }
                    }
                    aiTeammateElixir -= card.cost; // Subtract elixir FIRST
                    updateAITeammateUI(); // Then update UI to show correct elixir
                }
            }

            function showTeammatePlacement(x, y, emoji) {
                const indicator = document.createElement('div');
                indicator.className = 'absolute text-2xl pointer-events-none';
                indicator.style.left = `${x - 12}px`;
                indicator.style.top = `${y - 12}px`;
                indicator.textContent = emoji;
                indicator.style.transition = 'opacity 0.5s';
                gameContainer.appendChild(indicator);
                setTimeout(() => {
                    indicator.style.opacity = '0';
                    setTimeout(() => indicator.remove(), 500);
                }, 100);
            }

            function updateTimerAndElixir() {
                const totalSeconds = Math.max(0, Math.floor(gameTimer / 60));
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                if (isOvertime) {
                    timerDisplay.classList.add('text-red-500');
                    currentElixirRate = (gameTimer < 60 * 60) ? BASE_ELIXIR_REGEN_RATE * 3 : BASE_ELIXIR_REGEN_RATE * 2;
                } else {
                    timerDisplay.classList.remove('text-red-500');
                    currentElixirRate = (gameTimer < 60 * 60) ? BASE_ELIXIR_REGEN_RATE * 2 : BASE_ELIXIR_REGEN_RATE;
                }
                if (playerElixir < MAX_ELIXIR) {
                    playerElixir += currentElixirRate * (deltaTime * 60); /* Scale elixir regen by delta time */
                    playerElixir = Math.min(playerElixir, MAX_ELIXIR);
                }
                if (aiElixir < MAX_ELIXIR) {
                    aiElixir += currentElixirRate * (deltaTime * 60); /* Scale elixir regen by delta time */
                    aiElixir = Math.min(aiElixir, MAX_ELIXIR);
                }
                // Second AI elixir (2v2 only)
                if (gameMode === '2v2' && ai2Elixir < MAX_ELIXIR) {
                    ai2Elixir += currentElixirRate * (deltaTime * 60); /* Scale elixir regen by delta time */
                    ai2Elixir = Math.min(ai2Elixir, MAX_ELIXIR);
                }
                // AI teammate elixir (2v2 only)
                if (gameMode === '2v2' && is2v2AITeammate && aiTeammateElixir < MAX_ELIXIR) {
                    aiTeammateElixir += currentElixirRate * (deltaTime * 60); /* Scale elixir regen by delta time */
                    aiTeammateElixir = Math.min(aiTeammateElixir, MAX_ELIXIR);
                    updateAITeammateUI(); // Update UI continuously when elixir is gained
                }
            }
            
            // NEW: Update function to check tower status
            function checkTowerStatus() {
                const aiLeft = gameObjects.find(t => t.team === 'ai' && !t.isKing && t.x < WIDTH / 2);
                const aiRight = gameObjects.find(t => t.team === 'ai' && !t.isKing && t.x > WIDTH / 2);
                
                if (aiLeft && aiLeft.health <= 0 && !aiLeftTowerDestroyed) {
                    aiLeftTowerDestroyed = true;
                    if (selectedSpawningUnit) updatePlacementOverlay();
                }
                if (aiRight && aiRight.health <= 0 && !aiRightTowerDestroyed) {
                    aiRightTowerDestroyed = true;
                    if (selectedSpawningUnit) updatePlacementOverlay();
                }
                
                // Can check player towers here too if AI gets spawn zones
            }
            
            // NEW: Update the clip-path of the red overlay
            function updatePlacementOverlay() {
                // Use M (move) and L (line) path commands
                // `M x y L x y L x y Z` creates a closed shape
                let pathData = "";
                const H = HEIGHT; // 500
                const W = WIDTH; // 400
                const R = RIVER_Y; // 250
                const F = AI_SPAWN_ZONE_LIMIT; // 150 (500 * 0.3)
                const M = W / 2; // 200 (mid-line)

                // Define parts of the player's side that are blocked (red overlay)
                let pathParts = [];
                
                // Always block the very far enemy zone (Y=0 to AI_SPAWN_ZONE_LIMIT)
                pathParts.push(`M0 0 L${W} 0 L${W} ${F} L0 ${F} Z`);

                // Conditionally block the middle zone (AI_SPAWN_ZONE_LIMIT to RIVER_Y) for each lane
                if (!aiLeftTowerDestroyed) {
                    pathParts.push(`M0 ${F} L${M} ${F} L${M} ${R} L0 ${R} Z`);
                }
                if (!aiRightTowerDestroyed) {
                    pathParts.push(`M${M} ${F} L${W} ${F} L${W} ${R} L${M} ${R} Z`);
                }

                // If no enemy princess towers are destroyed, block the full top half up to RIVER_Y.
                // This condition must be last to ensure it overwrites previous pushes if applicable.
                if (!aiLeftTowerDestroyed && !aiRightTowerDestroyed) {
                    pathParts = [`M0 0 L${W} 0 L${W} ${R} L0 ${R} Z`]; // Block entire enemy territory
                } else if (gameMode === 'snowman_challenge') {
                    // Special case for snowman challenge - always block up to river for player
                    pathParts = [`M0 0 L${W} 0 L${W} ${R} L0 ${R} Z`];
                }

                placementOverlay.style.clipPath = `path("${pathParts.join(" ")}")`;
            }


            function checkGameOver() {
                const playerKing = gameObjects.find(t => t.team === 'player' && t.isKing);
                const aiKing = gameObjects.find(t => t.team === 'ai' && t.isKing);
                if (gameRunning && aiKing && aiKing.health <= 0) { showWinScreen(); }
                else if (gameRunning && playerKing && playerKing.health <= 0) { showLoseScreen(); }
            }
            
            function checkOvertime() { // RENAMED
                if (!gameRunning) return;
                const getTowerCount = (team) => { return gameObjects.filter(obj => obj.team === team && (obj instanceof Tower) && obj.health > 0).length; };
                const playerTowers = getTowerCount('player');
                const aiTowers = getTowerCount('ai');
                if (playerTowers === aiTowers) {
                    isOvertime = true;
                    overtimeInitialPlayerTowers = playerTowers; // NEW: Store initial counts
                    overtimeInitialAiTowers = aiTowers; // NEW: Store initial counts
                    gameTimer = OVERTIME_TIME;
                    currentElixirRate = BASE_ELIXIR_REGEN_RATE * 2;
                } else if (playerTowers > aiTowers) {
                    showWinScreen();
                } else {
                    showLoseScreen();
                }
            }

            function startTieBreaker() {
                if (!gameRunning) return;
                gameRunning = true; isTieBreaker = true; gameObjects = gameObjects.filter(obj => (obj instanceof Tower));
                messageText.textContent = 'TIEBREAKER!';
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'none'; // FIX: Hide menu button
                setTimeout(() => { if (isTieBreaker) messageOverlay.style.display = 'none'; }, 2000);
            }

            function tieBreakerLoop() {
                    tieBreakerTick -= deltaTime * 60; /* Scale tiebreaker tick by delta time */
                    if (tieBreakerTick <= 0) {
                    tieBreakerTick = 10;
                    let playerKing = null;
                    let aiKing = null;
                    for (const obj of gameObjects) {
                        if (obj instanceof Tower) { obj.health -= 20; }
                        if (obj.isKing && obj.team === 'player') playerKing = obj;
                        if (obj.isKing && obj.team === 'ai') aiKing = obj;
                    }
                    if (aiKing && aiKing.health <= 0 && playerKing && playerKing.health > 0) {
                        isTieBreaker = false;
                        showWinScreen();
                    } else if (playerKing && playerKing.health <= 0) {
                        isTieBreaker = false;
                        showLoseScreen();
                    }
                }
                ctx.clearRect(0, 0, WIDTH, HEIGHT); drawArena(); gameObjects.forEach(obj => obj.draw());
                if (isTieBreaker) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }

            async function showWinScreen() {
                if (!gameRunning) return;
                gameRunning = false;
                isOvertime = false;
                isTieBreaker = false;
                cancelAnimationFrame(gameLoopId);
                
                // Trophies only for Trophy Road
                if (gameMode === 'trophy') {
                    trophies += 30;
                    updateArena();
                    trophyDisplay.textContent = `üèÜ ${trophies}`;
                }
                
                if (gameMode === 'snowman_challenge') {
                     gold += 50; // Bonus for Challenge
                     messageText.textContent = 'Challenge Complete! (+100 üí∞ & Box üì¶)';
                }
                
                // Show Play Again button for multiplayer
                if (is2v2Friend && !is2v2AITeammate) {
                    startButton.textContent = 'Play Again';
                    startButton.style.display = 'inline-block';
                    startButton.onclick = () => requestRematch();
                    waitingForRematch = true;
                    if (conn && conn.open) {
                        conn.send({ type: 'playerReadyForRematch' });
                    }
                }
                gold += 50;
                goldDisplay.textContent = `üí∞ ${gold}`;
                if (trophyChests.length < 4) {
                    trophyChests.push({ id: 'wood', openTime: 0 });
                    renderChests();
                }
                let msg = 'You Win!';
                if (gameMode === 'trophy') msg += ' (+30 üèÜ, +50 üí∞, üì¶)';
                else msg += ' (+50 üí∞, üì¶)';
                
                messageText.textContent = msg;
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                
                // Give gold/chest in all modes (except trophies in non-trophy modes)
                // Note: showWinScreen runs trophies+=30 only for trophy mode above, but duplication here must be fixed
                // The original code had a bug where it added trophies twice in non-2v2. I will fix.
                if (gameMode !== '2v2') {
                    // Removed duplicate trophies logic
                    // Just gold and chests for now
                }
                // Give rewards for ALL modes
                gold += 50;
                if (trophyChests.length < 4) {
                    trophyChests.push({ id: 'wood', openTime: 0 });
                    renderChests();
                }
                await saveUserData();
            }

            async function showLoseScreen(message = 'You Lose!') {
                if (!gameRunning) return;
                gameRunning = false;
                isOvertime = false; // NEW: Stop overtime check
                isTieBreaker = false;
                cancelAnimationFrame(gameLoopId);
                
                // Show Play Again button for multiplayer
                if (is2v2Friend && !is2v2AITeammate) {
                    startButton.textContent = 'Play Again';
                    startButton.style.display = 'inline-block';
                    startButton.onclick = () => requestRematch();
                    waitingForRematch = true;
                    if (conn && conn.open) {
                        conn.send({ type: 'playerReadyForRematch' });
                    }
                }
                // Calculate minimum trophy floor for current arena
                let minTrophyFloor = 0;
                let lossAmount = 0;
                if (gameMode === 'trophy') {
                    for (const floor in arenaFloors) {
                        if (trophies >= parseInt(floor)) {
                            minTrophyFloor = parseInt(floor);
                        }
                    }
                    lossAmount = 30;
                    if (trophies - lossAmount < minTrophyFloor) {
                        lossAmount = trophies - minTrophyFloor;
                    }
                    if (lossAmount < 0) lossAmount = 0;
                    trophies = Math.max(minTrophyFloor, trophies - lossAmount);
                    updateArena();
                    trophyDisplay.textContent = `üèÜ ${trophies}`;
                }
                
                if (gameMode === 'trophy') {
                     messageText.textContent = `${message} (-${lossAmount} üèÜ)`;
                } else {
                     messageText.textContent = message;
                }
                messageOverlay.style.display = 'flex';
                startButton.style.display = 'none';
                menuButton.style.display = 'inline-block';
                await saveUserData();
            }

            function gameLoop(timestamp) {
                if (isTieBreaker) {
                    tieBreakerLoop();
                    return;
                }
                if (!gameRunning) {
                    cancelAnimationFrame(gameLoopId);
                    return;
                }
                deltaTime = (timestamp - lastTime) / 1000; /* Set global deltaTime */
                if (deltaTime > 0.1) deltaTime = 0.016; // Clamp to prevent huge jumps
                lastTime = timestamp;
                gameTimer -= deltaTime * 60; /* Scale game timer by delta time */
                updateTimerAndElixir();
                aiThinkTimer -= deltaTime * 60; /* Scale AI think timer by delta time */
                if (aiThinkTimer <= 0) {
                    runAI();
                    aiThinkTimer = 30 + Math.random() * 30; // Think every 0.5-1s
                }
                // Second AI (2v2 only)
                if (gameMode === '2v2') {
                    ai2ThinkTimer -= deltaTime * 60; /* Scale AI2 think timer by delta time */
                    if (ai2ThinkTimer <= 0) {
                        runAI2();
                        ai2ThinkTimer = 30 + Math.random() * 30;
                    }
                }
                // AI teammate (2v2 only)
                if (gameMode === '2v2' && is2v2AITeammate) {
                    runAITeammate();
                }
                
                // Update objects
                gameObjects.forEach(obj => obj.update());
                
                // NEW: Sudden Death Overtime Check
                if (gameRunning && isOvertime) {
                    const playerTowers = gameObjects.filter(obj => obj.team === 'player' && (obj instanceof Tower) && obj.health > 0).length;
                    const aiTowers = gameObjects.filter(obj => obj.team === 'ai' && (obj instanceof Tower) && obj.health > 0).length;

                    if (playerTowers < overtimeInitialPlayerTowers) {
                        // Player lost a tower
                        showLoseScreen("Sudden Death!");
                    } else if (aiTowers < overtimeInitialAiTowers) {
                        // AI lost a tower
                        showWinScreen(); // showWinScreen already handles stopping the game
                    }
                }
                
                // Check tower status for spawn zones
                checkTowerStatus();
                
                // Filter dead objects (and handle special death behavior)
                const newGameObjects = [];
                for (const obj of gameObjects) {
                    if (obj.health > 0) {
                        newGameObjects.push(obj);
                        continue;
                    }

                    // Handle units/projectiles/spells
                    if (obj instanceof Unit || obj instanceof Projectile || obj instanceof Spell || obj instanceof PoisonSpell || obj instanceof AngerSpell || obj instanceof FreezeEffect || obj instanceof HealEffect || obj instanceof ExplosionEffect || obj instanceof VoidTrapEffect || obj instanceof ChaosOrbEffect || obj instanceof ParticleExplosion || obj instanceof DeathEffect || obj instanceof GiantBomb) {
                        // Spawn Death Effect for Units
                        if (obj instanceof Unit) {
                             gameObjects.push(new DeathEffect(obj.x, obj.y, obj.emoji));
                        }
                        // Special case: Battle Ram needs to spawn barbs
                        if (obj instanceof BattleRam && !obj.didHit) {
                            obj.spawnBarbs();
                        }
                        // Special case: Stone Giant splits into minis on death
                        if (obj instanceof StoneGiant && !obj.didSpawnMinis) {
                            console.log('Cleanup: StoneGiant died at', obj.x, obj.y, 'spawning minis');
                            obj.spawnMinis();
                        }
                        // Special case: Huge Skeleton drops bomb
                        if (obj instanceof HugeSkeleton && !obj.droppedBomb) {
                            obj.droppedBomb = true;
                            // Push to newGameObjects to ensure the bomb is added to the game after the Huge Skeleton dies
                            newGameObjects.push(new GiantBomb(obj.x, obj.y, obj.team, obj.bombDamage, 100));
                        }
                        continue; // Dead units/effects are not kept
                    }

                    // Handle towers/buildings
                    if (obj instanceof Tower || obj instanceof Building) {
                        if (obj.isKing) {
                            checkGameOver();
                            newGameObjects.push(obj);
                            continue;
                        }
                        if (obj.dyingAnimationTimer === 0) { obj.dyingAnimationTimer = 30; }
                        obj.dyingAnimationTimer--;
                        if (obj.dyingAnimationTimer > 0) {
                            newGameObjects.push(obj);
                        }
                        continue;
                    }
                    // Everything else dead is dropped
                }
                gameObjects = newGameObjects;
                
                updateCardUI();
                if (gameTimer <= 0) {
                    if (isOvertime) { startTieBreaker(); }
                    else { checkOvertime(); }
                }
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                drawArena();
                gameObjects.forEach(obj => obj.draw());
                if (gameRunning) {
                    gameLoopId = requestAnimationFrame(gameLoop);
                }
            }

            function demoGameLoop(timestamp) {
                if (!isDemoMode) {
                    cancelAnimationFrame(gameLoopId);
                    return;
                }
                
                deltaTime = (timestamp - lastTime) / 1000; /* Set global deltaTime */
                lastTime = timestamp;

                const demoFadeOverlay = document.getElementById('demoFadeOverlay');

                // Handle Fading
                if (demoFadingOut) {
                    demoFadeTimer -= deltaTime * 60; /* Scale fade timer by delta time */
                    let fadeProgress = 1 - (demoFadeTimer / DEMO_FADE_TIME);
                    if (demoFadeOverlay) demoFadeOverlay.style.opacity = fadeProgress;

                    if (demoFadeTimer <= 0) {
                        // Reset
                        initGame(); // Reset the board and decks
                        demoLoopTimer = DEMO_LOOP_TIME;
                        demoFadingOut = false;
                        demoFadeTimer = DEMO_FADE_TIME; // Start fade-in
                    }
                } else if (demoFadeTimer > 0) {
                    // Fading IN
                    demoFadeTimer -= deltaTime * 60; /* Scale fade timer by delta time */
                    let fadeProgress = demoFadeTimer / DEMO_FADE_TIME;
                    if (demoFadeOverlay) demoFadeOverlay.style.opacity = fadeProgress;
                } else {
                    // Not fading, run game
                    demoLoopTimer -= deltaTime * 60; /* Scale demo loop timer by delta time */
                    if (demoLoopTimer <= 0) {
                        demoFadingOut = true;
                        demoFadeTimer = DEMO_FADE_TIME;
                    }

                    // Use existing gameTimer to run elixir etc.
                    gameTimer -= deltaTime * 60; /* Scale game timer by delta time */
                    updateTimerAndElixir();
                    aiThinkTimer -= deltaTime * 60; /* Scale AI think timer by delta time */
                    
                    if (aiThinkTimer <= 0) {
                        runAI(); // Existing AI
                        demoRunPlayerAI(); // New Player AI
                        aiThinkTimer = 30 + Math.random() * 30; // Think fast
                    }
                    
                    // Update objects
                    gameObjects.forEach(obj => obj.update());
                    
                    // Filter dead objects (simplified, no win/lose)
                    gameObjects = gameObjects.filter(obj => {
                        if (obj.health > 0) return true;
                        if (obj instanceof Unit || obj instanceof Projectile || obj instanceof Spell || obj instanceof PoisonSpell || obj instanceof VoidTrapEffect || obj instanceof ChaosOrbEffect) { 
                            if (obj instanceof BattleRam && !obj.didHit) obj.spawnBarbs();
                            return false; 
                        }
                        if (obj instanceof Tower || obj instanceof Building) {
                            if (obj.isKing) { obj.health = obj.maxHealth; return true; } // Make kings invincible
                            if (obj.dyingAnimationTimer === 0) obj.dyingAnimationTimer = 30;
                            obj.dyingAnimationTimer--;
                            return obj.dyingAnimationTimer > 0;
                        }
                        return false;
                    });
                }
                
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                drawArena();
                gameObjects.forEach(obj => obj.draw());
                // NEW: Draw zap chains after all objects
                gameObjects.forEach(obj => {
                    if ((obj instanceof ZapSpirit || obj instanceof ZapGiant) && obj.zapChain && obj.zapChain.length > 1) {
                        ctx.strokeStyle = '#fbbf24';
                        ctx.lineWidth = 3;
                        for (let i = 1; i < obj.zapChain.length; i++) {
                            const prev = obj.zapChain[i - 1];
                            const curr = obj.zapChain[i];
                            if (prev && curr && prev.health > 0 && curr.health > 0) {
                                ctx.beginPath();
                                ctx.moveTo(prev.x, prev.y);
                                ctx.lineTo(curr.x, curr.y);
                                ctx.stroke();
                            }
                        }
                    }
                });
                
                gameLoopId = requestAnimationFrame(demoGameLoop);
            }
            // ==============================================
            // INITIALIZATION
            // ==============================================
            
            // This MUST be called after all classes are defined
            initCardSystem();

            // --- BUG FIX: Start demo mode *after* classes and cards are defined ---
            if (isDemoMode) {
                initGame();
                lastTime = performance.now(); // ADDED: Need this for gameLoop
                gameLoopId = requestAnimationFrame(demoGameLoop);
                return; // Stop the rest of onload
            }
            // --- END BUG FIX ---


            // ==============================================
            // EVENT LISTENERS
            // ==============================================
            
            // --- REFERENCEERROR FIX: All function definitions removed from here ---
            
            // --- Event Listeners ---
            
            function getCanvasClickPos(e) {
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) { 
                    clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; 
                } else if (e.changedTouches && e.changedTouches.length > 0) { 
                    clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; 
                } else { 
                    clientX = e.clientX; clientY = e.clientY; 
                }
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                return { x, y };
            }

            function checkPlacement(x, y, radius, cardType) {
                // Check if in allowed zone
                let inAllowedZone = false;
                
                if (gameMode === 'snowman_challenge') {
                    // Strict restriction: Player side only
                    if (y > RIVER_Y) inAllowedZone = true;
                } else {
                    if (y > RIVER_Y) {
                        inAllowedZone = true; // Always allowed in player's base
                    } else if (y > AI_SPAWN_ZONE_LIMIT) { // Can't place in "far end"
                        // Check enemy territory
                        if (aiLeftTowerDestroyed && x < WIDTH / 2) inAllowedZone = true;
                        if (aiRightTowerDestroyed && x > WIDTH / 2) inAllowedZone = true;
                    }
                }
                
                if (!inAllowedZone) return false;

                // Check for collision
                for (const obj of gameObjects) {
                    // NEW: Allow placing on troops, not buildings
                    if (obj instanceof Tower || obj instanceof Building) {
                        const dist = getDistance({x: x, y: y}, obj);
                        if (dist < radius + obj.radius) { return false; }
                    }
                }
                
                return true;
            }

            function handleDragMove(e) {
                if (!selectedSpawningUnit) return;
                e.preventDefault();
                let pos = (e.touches && e.touches[0]) ? e.touches[0] : e;
                
                // NEW: Drag sensitivity logic
                if (!isDragging) {
                    const dx = Math.abs(pos.clientX - dragStartX);
                    const dy = Math.abs(pos.clientY - dragStartY);
                    if (dx > DRAG_SENSITIVITY || dy > DRAG_SENSITIVITY) {
                        isDragging = true;
                    }
                }
                
                // NEW: Only move indicator if mouse is over canvas
                const rect = canvas.getBoundingClientRect();
                const isOverCanvas = (pos.clientX >= rect.left && pos.clientX <= rect.right &&
                                         pos.clientY >= rect.top && pos.clientY <= rect.bottom);
                
                if (isOverCanvas) {
                    placementIndicator.style.display = 'block';
                    movePlacementIndicator(pos);
                } else {
                    placementIndicator.style.display = 'none'; // Hide if off-canvas
                }
            }

            function movePlacementIndicator(e) {
                if (!selectedSpawningUnit) return;
                
                const { x, y } = getCanvasClickPos(e);
                const clampedX = Math.max(0, Math.min(WIDTH, x));
                const clampedY = Math.max(0, Math.min(HEIGHT, y));
                let radius = isSpawningSpell ? spellRadius : placementRadius;
                
                placementIndicator.style.left = `${clampedX}px`;
                placementIndicator.style.top = `${clampedY}px`;
                
                if (isSpawningSpell) {
                    canPlace = true; // Spells can be placed anywhere
                } else {
                    canPlace = checkPlacement(clampedX, clampedY, placementRadius, selectedSpawningUnit.type);
                }
                placementIndicator.classList.toggle('cant-place', !canPlace);
            }
            
            // Re-bind mouse/touch move to window to allow dragging off canvas
            window.addEventListener('mousemove', handleDragMove);
            window.addEventListener('touchmove', handleDragMove, { passive: false });


            function handleDragEnd(e) {
                if (!selectedSpawningUnit || !gameRunning) {
                    cancelPlacement();
                    return;
                }

                // Check if mouse is over canvas
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX; clientY = e.clientY;
                }
                const isOverCanvas = (clientX >= rect.left && clientX <= rect.right &&
                                         clientY >= rect.top && clientY <= rect.bottom);
                
                // --- CLICK-TO-PLACE FIX ---
                if (!isDragging) {
                    // This was a "click"
                    if (isOverCanvas) {
                        // This is a "click-to-place"
                        // canPlace is already set by the last handleDragMove
                    } else {
                        // This was a click off-canvas, or just releasing the mouse from the card
                        // Check if the click-up was on a card
                        if (e.target && e.target.closest('.card-ui')) {
                            // This was the initial click-up on the card. Do nothing.
                            return; 
                        }
                        // Otherwise, it was a click off-canvas to cancel.
                        cancelPlacement();
                        return;
                    }
                } else {
                    // This was a "drag-and-drop"
                    if (!isOverCanvas) {
                        // Dragged off-canvas to cancel
                        cancelPlacement();
                        return;
                    }
                    // canPlace is already set
                }
                // --- END FIX ---
                
                if (!canPlace) {
                    console.log("Cannot spawn there!");
                    cancelPlacement();
                    return;
                }
                
                const { x, y } = getCanvasClickPos(e);
                const clampedX = Math.max(0, Math.min(WIDTH, x));
                const clampedY = Math.max(0, Math.min(HEIGHT, y));
                
                const card = allCards[selectedSpawningUnit.id];
                const isPartyModeForLevel = (gameMode === '2v2' || gameMode === 'party1v1');
                const level = isPartyModeForLevel ? 15 : (cardCollection[selectedSpawningUnit.id] ? cardCollection[selectedSpawningUnit.id].level : 1);
                
                if (card.type === 'Spell') {
                    if (selectedSpawningUnit.id === 'poison') { // NEW
                        const s = card.stats[level];
                        gameObjects.push(new PoisonSpell(clampedX, clampedY, 'player', s.damagePerSecond, card.radius, s.duration));
                    } else if (selectedSpawningUnit.id === 'anger') { // NEW
                        const s = card.stats[level];
                        gameObjects.push(new AngerSpell(clampedX, clampedY, 'player', card.radius, s.duration, s.damage));
                    } else if (selectedSpawningUnit.id === 'voidTrap') { // NEW
                        const damage = card.stats[level].damage;
                        gameObjects.push(new VoidTrapEffect(clampedX, clampedY, 'player', card.radius, damage));
                    } else if (selectedSpawningUnit.id === 'chaosOrb') { // NEW
                        const damage = card.stats[level].damage;
                        gameObjects.push(new ChaosOrbEffect(clampedX, clampedY, 'player', card.radius, damage));
                    } else if (selectedSpawningUnit.id === 'skeletonYard') { // NEW
                        const duration = card.stats[level].duration;
                        gameObjects.push(new SkeletonYard(clampedX, clampedY, 'player', duration, card.radius, level));
                    } else if (selectedSpawningUnit.id === 'meteor') {
                         // Meteor spawns a projectile that takes time to land (simulated by slow projectile or effect)
                         // For simplicity, we use a slower projectile visual
                         const damage = card.stats[level].damage;
                         gameObjects.push(new Projectile(clampedX, clampedY - 200, {x: clampedX, y: clampedY, health: 1}, 'player', damage, card.radius)); 
                         // Hacky: create a dummy target? No, Projectile needs target object.
                         // Let's use standard Spell for now but with different visual or use FireballProjectile logic manually
                         // Actually, let's just use Spell immediate effect for stability as per request "spell"
                         gameObjects.push(new Spell(clampedX, clampedY, 'player', damage, card.radius, card.emoji));
                    } else {
                        const damage = card.stats[level].damage;
                        gameObjects.push(new Spell(clampedX, clampedY, 'player', damage, card.radius, card.emoji));
                    }
                } else if (card.type === 'Spirit') { // NEW: Handle spirits
                    const newUnit = new card.unitClass(clampedX, clampedY, 'player', level);
                    if (newUnit instanceof GameObject) {
                        gameObjects.push(newUnit);
                    }
                } else {
                    const newUnit = new card.unitClass(clampedX, clampedY, 'player', level);
                    // --- TYPEERROR FIX ---
                    // Check if the returned object is an actual game object (for single units/buildings)
                    // If it's a spawner, it's not a GameObject and shouldn't be pushed.
                    if (newUnit instanceof GameObject) {
                        gameObjects.push(newUnit);
                    }
                }
                
                playCard(selectedSpawningUnit.id, selectedSpawningUnit.handIndex);
                cancelPlacement();
            }

            // Use mouseup/touchend on the *window* to catch drags released off-canvas
            window.addEventListener('mouseup', handleDragEnd);
            window.addEventListener('touchend', handleDragEnd, { passive: false });

            // --- CLICK-TO-PLACE FIX: This listener is now removed ---
            // canvas.addEventListener('click', (e) => {
            //     if (selectedSpawningUnit && !isDragging) {
            //         handleDragEnd(e);
            //     }
            // });

            if (cardInfoCloseBtn) cardInfoCloseBtn.addEventListener('click', closeModal);
            
            // --- Init App ---
            // initCardSystem(); // <-- MOVED
            onAuthStateChanged(auth, handleAuth); // Wait for user login

            // --- NEW: Intro Animation Timer ---
            setTimeout(() => {
                if (currentScreen === 'intro') { 
                    showScreen('login');
                }
            }, 2500); 
            
            // Initialize Button Effects
            const rippleTargets = 'button, .card-ui, .nav-btn, .mode-tab, .chest-slot, .login-btn, .arena-btn, .debug-btn';
            
            function addRippleEffect(btn) {
                if (btn.dataset.hasRipple) return;
                btn.dataset.hasRipple = 'true';
                // Only add btn-shine if not already present to avoid overriding specific styles
                if (!btn.classList.contains('btn-shine')) btn.classList.add('btn-shine');
                
                // Ensure relative positioning for ripple containment
                const computedStyle = window.getComputedStyle(btn);
                if (computedStyle.position === 'static') {
                    btn.style.position = 'relative';
                }
                if (computedStyle.overflow !== 'hidden') {
                    btn.style.overflow = 'hidden';
                }

                btn.addEventListener('click', function(e) {
                    const rect = this.getBoundingClientRect();
                    // Fallback for non-mouse events
                    const clientX = e.clientX !== undefined ? e.clientX : (rect.left + rect.width / 2);
                    const clientY = e.clientY !== undefined ? e.clientY : (rect.top + rect.height / 2);
                    
                    const x = clientX - rect.left;
                    const y = clientY - rect.top;
                    
                    const ripple = document.createElement('span');
                    ripple.className = 'ripple-btn';
                    // Center the ripple on the click
                    ripple.style.left = `${x}px`;
                    ripple.style.top = `${y}px`;
                    // Make it big enough
                    ripple.style.width = '1px';
                    ripple.style.height = '1px';
                    
                    this.appendChild(ripple);
                    setTimeout(() => ripple.remove(), 600);

                    // Trigger Pulse Ring
                    this.classList.remove('btn-pulse-anim');
                    void this.offsetWidth; // Trigger reflow
                    this.classList.add('btn-pulse-anim');
                });
            }
            
            // Apply to existing buttons
            document.querySelectorAll(rippleTargets).forEach(btn => addRippleEffect(btn));
            
            // MutationObserver to handle dynamic elements
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) {
                            if (node.matches(rippleTargets)) addRippleEffect(node);
                            node.querySelectorAll(rippleTargets).forEach(btn => addRippleEffect(btn));
                        }
                    });
                });
            });
            observer.observe(document.body, { childList: true, subtree: true });
            // --- END: Intro Animation ---
        } // Close window.onload function
    </script>

    <!-- 2v2 Teammate Choice Modal -->
    <div id="teammateChoiceModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg p-6 w-80">
            <h2 class="text-2xl font-bold text-center mb-4">Choose Teammate</h2>
            <button id="aiTeammateBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-bold mb-3 transition">
                Play with AI Teammate
            </button>
            <button id="friendTeammateBtn" class="w-full bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-bold mb-3 transition" style="display:none">
                Play with Friend
            </button>
            <button id="cancelTeammateBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-lg font-bold transition">
                Cancel
            </button>
        </div>
    </div>

    <!-- 2v2 Friend Code Modal -->
    <div id="friendCodeModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg p-6 w-80">
            <h2 class="text-2xl font-bold text-center mb-4">Play with Friend</h2>
            <button id="createCodeBtn" class="w-full bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-bold mb-3 transition">
                Create Code
            </button>
            <button id="joinCodeBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-bold mb-3 transition">
                Join with Code
            </button>
            <button id="cancelFriendBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-lg font-bold transition">
                Cancel
            </button>
        </div>
    </div>

    <!-- 2v2 Create Code Modal -->
    <div id="createCodeModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg p-6 w-80">
            <h2 class="text-2xl font-bold text-center mb-4">Lobby Code</h2>
            <div class="bg-gray-700 p-4 rounded-lg mb-4">
                <p class="text-3xl font-mono text-center text-green-400" id="generatedCode">-----</p>
            </div>
            <p class="text-sm text-gray-300 mb-4">Share this code with your friend to join.</p>
            <p class="text-sm text-yellow-300 mb-4">Waiting for teammate...</p>
            <button id="cancelCreateBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-lg font-bold transition">
                Cancel
            </button>
        </div>
    </div>

    <!-- 2v2 Join Code Modal -->
    <div id="joinCodeModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg p-6 w-80">
            <h2 class="text-2xl font-bold text-center mb-4">Enter Lobby Code</h2>
            <input type="text" id="codeInput" maxlength="5" placeholder="5-digit code" class="w-full bg-gray-700 text-white px-4 py-3 rounded-lg text-center text-2xl font-mono mb-4">
            <button id="confirmJoinBtn" class="w-full bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-bold mb-3 transition">
                Join
            </button>
            <button id="cancelJoinBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-lg font-bold transition">
                Cancel
            </button>
        </div>
    </div>
</div>


</body>
</html>
